{
  
    
        "post0": {
            "title": "Title",
            "content": "",
            "url": "https://guebin.github.io/DV2022/2022/10/17/(7%EC%A3%BC%EC%B0%A8)-10%EC%9B%9417%EC%9D%BC-lecture.html",
            "relUrl": "/2022/10/17/(7%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1)-10%E1%84%8B%E1%85%AF%E1%86%AF17%E1%84%8B%E1%85%B5%E1%86%AF-lecture.html",
            "date": " • Oct 17, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "(7주차) 10월17일 -- draft",
            "content": "&#44053;&#51032;&#50689;&#49345; . imports . import numpy as np import pandas as pd import matplotlib.pyplot as plt from plotnine import * . df: &#51064;&#45937;&#49905; 3&#45800;&#44228;-- column&#51032; &#49440;&#53469; (with &#49892;&#51204;&#50696;&#51228;) . - 지금까지 정리 . . [] .iloc .loc . row/단일레이블 | X | X | O | O | . col/단일레이블 | O | O | O | O | . row/레이블리스트 | X | X | O | O | . col/레이블리스트 | X | O | O | O | . row/슬라이싱 | X | O | O | O | . col/슬라이싱 | X | X | O | O | . row/bool,list | X | O | O | O | . row/bool,ser | X | O | X | O | . row/bool,map | X | X | O | O | . col/bool,list | X | ? | ? | ? | . col/bool,ser | X | ? | ? | ? | . col/bool,map | X | ? | ? | ? | . - 채워보세요 (숙제입니다) . . [] .iloc .loc commnets . row/단일레이블 | X | X | O | O | | . col/단일레이블 | O | O | O | O | | . row/레이블리스트 | X | X | O | O | | . col/레이블리스트 | X | O | O | O | | . row/슬라이싱 | X | O | O | O | | . col/슬라이싱 | X | X | O | O | | . row/bool,list | X | O | O | O | | . row/bool,ser | X | O | X | O | | . row/bool,map | X | X | O | O | | . col/bool,list | X | ? | ? | ? | | . col/bool,ser | X | X | X | X | 쓸일이없음 | . col/bool,map | X | ? | ? | ? | . &#45936;&#51060;&#53552; . df=pd.read_csv(&#39;https://raw.githubusercontent.com/PacktPublishing/Pandas-Cookbook/master/data/movie.csv&#39;) df . color director_name num_critic_for_reviews duration director_facebook_likes actor_3_facebook_likes actor_2_name actor_1_facebook_likes gross genres ... num_user_for_reviews language country content_rating budget title_year actor_2_facebook_likes imdb_score aspect_ratio movie_facebook_likes . 0 Color | James Cameron | 723.0 | 178.0 | 0.0 | 855.0 | Joel David Moore | 1000.0 | 760505847.0 | Action|Adventure|Fantasy|Sci-Fi | ... | 3054.0 | English | USA | PG-13 | 237000000.0 | 2009.0 | 936.0 | 7.9 | 1.78 | 33000 | . 1 Color | Gore Verbinski | 302.0 | 169.0 | 563.0 | 1000.0 | Orlando Bloom | 40000.0 | 309404152.0 | Action|Adventure|Fantasy | ... | 1238.0 | English | USA | PG-13 | 300000000.0 | 2007.0 | 5000.0 | 7.1 | 2.35 | 0 | . 2 Color | Sam Mendes | 602.0 | 148.0 | 0.0 | 161.0 | Rory Kinnear | 11000.0 | 200074175.0 | Action|Adventure|Thriller | ... | 994.0 | English | UK | PG-13 | 245000000.0 | 2015.0 | 393.0 | 6.8 | 2.35 | 85000 | . 3 Color | Christopher Nolan | 813.0 | 164.0 | 22000.0 | 23000.0 | Christian Bale | 27000.0 | 448130642.0 | Action|Thriller | ... | 2701.0 | English | USA | PG-13 | 250000000.0 | 2012.0 | 23000.0 | 8.5 | 2.35 | 164000 | . 4 NaN | Doug Walker | NaN | NaN | 131.0 | NaN | Rob Walker | 131.0 | NaN | Documentary | ... | NaN | NaN | NaN | NaN | NaN | NaN | 12.0 | 7.1 | NaN | 0 | . ... ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | . 4911 Color | Scott Smith | 1.0 | 87.0 | 2.0 | 318.0 | Daphne Zuniga | 637.0 | NaN | Comedy|Drama | ... | 6.0 | English | Canada | NaN | NaN | 2013.0 | 470.0 | 7.7 | NaN | 84 | . 4912 Color | NaN | 43.0 | 43.0 | NaN | 319.0 | Valorie Curry | 841.0 | NaN | Crime|Drama|Mystery|Thriller | ... | 359.0 | English | USA | TV-14 | NaN | NaN | 593.0 | 7.5 | 16.00 | 32000 | . 4913 Color | Benjamin Roberds | 13.0 | 76.0 | 0.0 | 0.0 | Maxwell Moody | 0.0 | NaN | Drama|Horror|Thriller | ... | 3.0 | English | USA | NaN | 1400.0 | 2013.0 | 0.0 | 6.3 | NaN | 16 | . 4914 Color | Daniel Hsia | 14.0 | 100.0 | 0.0 | 489.0 | Daniel Henney | 946.0 | 10443.0 | Comedy|Drama|Romance | ... | 9.0 | English | USA | PG-13 | NaN | 2012.0 | 719.0 | 6.3 | 2.35 | 660 | . 4915 Color | Jon Gunn | 43.0 | 90.0 | 16.0 | 16.0 | Brian Herzlinger | 86.0 | 85222.0 | Documentary | ... | 84.0 | English | USA | PG | 1100.0 | 2004.0 | 23.0 | 6.6 | 1.85 | 456 | . 4916 rows × 28 columns . - 열의 이름을 출력하여 보자. . &#44592;&#48376;&#51064;&#45937;&#49905; (df &#51064;&#45937;&#49905;&#44277;&#48512; 1&#45800;&#44228; &#45236;&#50857;) . - color ~ num_voted_user 를 뽑고 + aspect_ratio 도 추가적으로 뽑고싶다. . df.loc[:,[&#39;color&#39;:&#39;num_voted_users&#39;,&#39;aspect_ratio&#39;]] . File &#34;/tmp/ipykernel_1576771/1210972629.py&#34;, line 1 df.loc[:,[&#39;color&#39;:&#39;num_voted_users&#39;,&#39;aspect_ratio&#39;]] ^ SyntaxError: invalid syntax . - (팁) 복잡한 조건은 iloc으로 쓰는게 편할때가 있다. $ to$ 그런데 df.columns 변수들이 몇번인지 알아보기 힘듬 $ to$ 아래와 같이 하면 열의 이름을 인덱스와 함께 출력할 수 있음 . pd.Series(df.columns) . 0 color 1 director_name 2 num_critic_for_reviews 3 duration 4 director_facebook_likes 5 actor_3_facebook_likes 6 actor_2_name 7 actor_1_facebook_likes 8 gross 9 genres 10 actor_1_name 11 movie_title 12 num_voted_users 13 cast_total_facebook_likes 14 actor_3_name 15 facenumber_in_poster 16 plot_keywords 17 movie_imdb_link 18 num_user_for_reviews 19 language 20 country 21 content_rating 22 budget 23 title_year 24 actor_2_facebook_likes 25 imdb_score 26 aspect_ratio 27 movie_facebook_likes dtype: object . list(range(13))+[26] . [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 26] . df.iloc[:,list(range(13))+[26]] . color director_name num_critic_for_reviews duration director_facebook_likes actor_3_facebook_likes actor_2_name actor_1_facebook_likes gross genres actor_1_name movie_title num_voted_users aspect_ratio . 0 Color | James Cameron | 723.0 | 178.0 | 0.0 | 855.0 | Joel David Moore | 1000.0 | 760505847.0 | Action|Adventure|Fantasy|Sci-Fi | CCH Pounder | Avatar | 886204 | 1.78 | . 1 Color | Gore Verbinski | 302.0 | 169.0 | 563.0 | 1000.0 | Orlando Bloom | 40000.0 | 309404152.0 | Action|Adventure|Fantasy | Johnny Depp | Pirates of the Caribbean: At World&#39;s End | 471220 | 2.35 | . 2 Color | Sam Mendes | 602.0 | 148.0 | 0.0 | 161.0 | Rory Kinnear | 11000.0 | 200074175.0 | Action|Adventure|Thriller | Christoph Waltz | Spectre | 275868 | 2.35 | . 3 Color | Christopher Nolan | 813.0 | 164.0 | 22000.0 | 23000.0 | Christian Bale | 27000.0 | 448130642.0 | Action|Thriller | Tom Hardy | The Dark Knight Rises | 1144337 | 2.35 | . 4 NaN | Doug Walker | NaN | NaN | 131.0 | NaN | Rob Walker | 131.0 | NaN | Documentary | Doug Walker | Star Wars: Episode VII - The Force Awakens | 8 | NaN | . ... ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | . 4911 Color | Scott Smith | 1.0 | 87.0 | 2.0 | 318.0 | Daphne Zuniga | 637.0 | NaN | Comedy|Drama | Eric Mabius | Signed Sealed Delivered | 629 | NaN | . 4912 Color | NaN | 43.0 | 43.0 | NaN | 319.0 | Valorie Curry | 841.0 | NaN | Crime|Drama|Mystery|Thriller | Natalie Zea | The Following | 73839 | 16.00 | . 4913 Color | Benjamin Roberds | 13.0 | 76.0 | 0.0 | 0.0 | Maxwell Moody | 0.0 | NaN | Drama|Horror|Thriller | Eva Boehnke | A Plague So Pleasant | 38 | NaN | . 4914 Color | Daniel Hsia | 14.0 | 100.0 | 0.0 | 489.0 | Daniel Henney | 946.0 | 10443.0 | Comedy|Drama|Romance | Alan Ruck | Shanghai Calling | 1255 | 2.35 | . 4915 Color | Jon Gunn | 43.0 | 90.0 | 16.0 | 16.0 | Brian Herzlinger | 86.0 | 85222.0 | Documentary | John August | My Date with Drew | 4285 | 1.85 | . 4916 rows × 14 columns . - 다시열의 이름들을 확인 . df.columns . Index([&#39;color&#39;, &#39;director_name&#39;, &#39;num_critic_for_reviews&#39;, &#39;duration&#39;, &#39;director_facebook_likes&#39;, &#39;actor_3_facebook_likes&#39;, &#39;actor_2_name&#39;, &#39;actor_1_facebook_likes&#39;, &#39;gross&#39;, &#39;genres&#39;, &#39;actor_1_name&#39;, &#39;movie_title&#39;, &#39;num_voted_users&#39;, &#39;cast_total_facebook_likes&#39;, &#39;actor_3_name&#39;, &#39;facenumber_in_poster&#39;, &#39;plot_keywords&#39;, &#39;movie_imdb_link&#39;, &#39;num_user_for_reviews&#39;, &#39;language&#39;, &#39;country&#39;, &#39;content_rating&#39;, &#39;budget&#39;, &#39;title_year&#39;, &#39;actor_2_facebook_likes&#39;, &#39;imdb_score&#39;, &#39;aspect_ratio&#39;, &#39;movie_facebook_likes&#39;], dtype=&#39;object&#39;) . actor&#46972;&#45716; &#45800;&#50612;&#44032; &#54252;&#54632;&#46108; column &#49440;&#53469; . - 방법1 . df.iloc[:,list(map(lambda x : &#39;actor&#39; in x, df.columns) )] . actor_3_facebook_likes actor_2_name actor_1_facebook_likes actor_1_name actor_3_name actor_2_facebook_likes . 0 855.0 | Joel David Moore | 1000.0 | CCH Pounder | Wes Studi | 936.0 | . 1 1000.0 | Orlando Bloom | 40000.0 | Johnny Depp | Jack Davenport | 5000.0 | . 2 161.0 | Rory Kinnear | 11000.0 | Christoph Waltz | Stephanie Sigman | 393.0 | . 3 23000.0 | Christian Bale | 27000.0 | Tom Hardy | Joseph Gordon-Levitt | 23000.0 | . 4 NaN | Rob Walker | 131.0 | Doug Walker | NaN | 12.0 | . ... ... | ... | ... | ... | ... | ... | . 4911 318.0 | Daphne Zuniga | 637.0 | Eric Mabius | Crystal Lowe | 470.0 | . 4912 319.0 | Valorie Curry | 841.0 | Natalie Zea | Sam Underwood | 593.0 | . 4913 0.0 | Maxwell Moody | 0.0 | Eva Boehnke | David Chandler | 0.0 | . 4914 489.0 | Daniel Henney | 946.0 | Alan Ruck | Eliza Coupe | 719.0 | . 4915 16.0 | Brian Herzlinger | 86.0 | John August | Jon Gunn | 23.0 | . 4916 rows × 6 columns . - 방법2 . df.loc[:,list(map(lambda x : &#39;actor&#39; in x, df.columns) )] . actor_3_facebook_likes actor_2_name actor_1_facebook_likes actor_1_name actor_3_name actor_2_facebook_likes . 0 855.0 | Joel David Moore | 1000.0 | CCH Pounder | Wes Studi | 936.0 | . 1 1000.0 | Orlando Bloom | 40000.0 | Johnny Depp | Jack Davenport | 5000.0 | . 2 161.0 | Rory Kinnear | 11000.0 | Christoph Waltz | Stephanie Sigman | 393.0 | . 3 23000.0 | Christian Bale | 27000.0 | Tom Hardy | Joseph Gordon-Levitt | 23000.0 | . 4 NaN | Rob Walker | 131.0 | Doug Walker | NaN | 12.0 | . ... ... | ... | ... | ... | ... | ... | . 4911 318.0 | Daphne Zuniga | 637.0 | Eric Mabius | Crystal Lowe | 470.0 | . 4912 319.0 | Valorie Curry | 841.0 | Natalie Zea | Sam Underwood | 593.0 | . 4913 0.0 | Maxwell Moody | 0.0 | Eva Boehnke | David Chandler | 0.0 | . 4914 489.0 | Daniel Henney | 946.0 | Alan Ruck | Eliza Coupe | 719.0 | . 4915 16.0 | Brian Herzlinger | 86.0 | John August | Jon Gunn | 23.0 | . 4916 rows × 6 columns . - 방법3 . df.iloc[:,map(lambda x : &#39;actor&#39; in x, df.columns)] . actor_3_facebook_likes actor_2_name actor_1_facebook_likes actor_1_name actor_3_name actor_2_facebook_likes . 0 855.0 | Joel David Moore | 1000.0 | CCH Pounder | Wes Studi | 936.0 | . 1 1000.0 | Orlando Bloom | 40000.0 | Johnny Depp | Jack Davenport | 5000.0 | . 2 161.0 | Rory Kinnear | 11000.0 | Christoph Waltz | Stephanie Sigman | 393.0 | . 3 23000.0 | Christian Bale | 27000.0 | Tom Hardy | Joseph Gordon-Levitt | 23000.0 | . 4 NaN | Rob Walker | 131.0 | Doug Walker | NaN | 12.0 | . ... ... | ... | ... | ... | ... | ... | . 4911 318.0 | Daphne Zuniga | 637.0 | Eric Mabius | Crystal Lowe | 470.0 | . 4912 319.0 | Valorie Curry | 841.0 | Natalie Zea | Sam Underwood | 593.0 | . 4913 0.0 | Maxwell Moody | 0.0 | Eva Boehnke | David Chandler | 0.0 | . 4914 489.0 | Daniel Henney | 946.0 | Alan Ruck | Eliza Coupe | 719.0 | . 4915 16.0 | Brian Herzlinger | 86.0 | John August | Jon Gunn | 23.0 | . 4916 rows × 6 columns . - 방법4 . df.loc[:,map(lambda x : &#39;actor&#39; in x, df.columns)] . actor_3_facebook_likes actor_2_name actor_1_facebook_likes actor_1_name actor_3_name actor_2_facebook_likes . 0 855.0 | Joel David Moore | 1000.0 | CCH Pounder | Wes Studi | 936.0 | . 1 1000.0 | Orlando Bloom | 40000.0 | Johnny Depp | Jack Davenport | 5000.0 | . 2 161.0 | Rory Kinnear | 11000.0 | Christoph Waltz | Stephanie Sigman | 393.0 | . 3 23000.0 | Christian Bale | 27000.0 | Tom Hardy | Joseph Gordon-Levitt | 23000.0 | . 4 NaN | Rob Walker | 131.0 | Doug Walker | NaN | 12.0 | . ... ... | ... | ... | ... | ... | ... | . 4911 318.0 | Daphne Zuniga | 637.0 | Eric Mabius | Crystal Lowe | 470.0 | . 4912 319.0 | Valorie Curry | 841.0 | Natalie Zea | Sam Underwood | 593.0 | . 4913 0.0 | Maxwell Moody | 0.0 | Eva Boehnke | David Chandler | 0.0 | . 4914 489.0 | Daniel Henney | 946.0 | Alan Ruck | Eliza Coupe | 719.0 | . 4915 16.0 | Brian Herzlinger | 86.0 | John August | Jon Gunn | 23.0 | . 4916 rows × 6 columns . s&#47196; &#45149;&#45208;&#45716; column &#49440;&#53469; . - 방법1 . df.iloc[:,map(lambda x: &#39;s&#39; == x[-1],df.columns )] . num_critic_for_reviews director_facebook_likes actor_3_facebook_likes actor_1_facebook_likes gross genres num_voted_users cast_total_facebook_likes plot_keywords num_user_for_reviews actor_2_facebook_likes movie_facebook_likes . 0 723.0 | 0.0 | 855.0 | 1000.0 | 760505847.0 | Action|Adventure|Fantasy|Sci-Fi | 886204 | 4834 | avatar|future|marine|native|paraplegic | 3054.0 | 936.0 | 33000 | . 1 302.0 | 563.0 | 1000.0 | 40000.0 | 309404152.0 | Action|Adventure|Fantasy | 471220 | 48350 | goddess|marriage ceremony|marriage proposal|pi... | 1238.0 | 5000.0 | 0 | . 2 602.0 | 0.0 | 161.0 | 11000.0 | 200074175.0 | Action|Adventure|Thriller | 275868 | 11700 | bomb|espionage|sequel|spy|terrorist | 994.0 | 393.0 | 85000 | . 3 813.0 | 22000.0 | 23000.0 | 27000.0 | 448130642.0 | Action|Thriller | 1144337 | 106759 | deception|imprisonment|lawlessness|police offi... | 2701.0 | 23000.0 | 164000 | . 4 NaN | 131.0 | NaN | 131.0 | NaN | Documentary | 8 | 143 | NaN | NaN | 12.0 | 0 | . ... ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | . 4911 1.0 | 2.0 | 318.0 | 637.0 | NaN | Comedy|Drama | 629 | 2283 | fraud|postal worker|prison|theft|trial | 6.0 | 470.0 | 84 | . 4912 43.0 | NaN | 319.0 | 841.0 | NaN | Crime|Drama|Mystery|Thriller | 73839 | 1753 | cult|fbi|hideout|prison escape|serial killer | 359.0 | 593.0 | 32000 | . 4913 13.0 | 0.0 | 0.0 | 0.0 | NaN | Drama|Horror|Thriller | 38 | 0 | NaN | 3.0 | 0.0 | 16 | . 4914 14.0 | 0.0 | 489.0 | 946.0 | 10443.0 | Comedy|Drama|Romance | 1255 | 2386 | NaN | 9.0 | 719.0 | 660 | . 4915 43.0 | 16.0 | 16.0 | 86.0 | 85222.0 | Documentary | 4285 | 163 | actress name in title|crush|date|four word tit... | 84.0 | 23.0 | 456 | . 4916 rows × 12 columns . - 방법2 . df.loc[:,map(lambda x: &#39;s&#39; == x[-1],df.columns )] . num_critic_for_reviews director_facebook_likes actor_3_facebook_likes actor_1_facebook_likes gross genres num_voted_users cast_total_facebook_likes plot_keywords num_user_for_reviews actor_2_facebook_likes movie_facebook_likes . 0 723.0 | 0.0 | 855.0 | 1000.0 | 760505847.0 | Action|Adventure|Fantasy|Sci-Fi | 886204 | 4834 | avatar|future|marine|native|paraplegic | 3054.0 | 936.0 | 33000 | . 1 302.0 | 563.0 | 1000.0 | 40000.0 | 309404152.0 | Action|Adventure|Fantasy | 471220 | 48350 | goddess|marriage ceremony|marriage proposal|pi... | 1238.0 | 5000.0 | 0 | . 2 602.0 | 0.0 | 161.0 | 11000.0 | 200074175.0 | Action|Adventure|Thriller | 275868 | 11700 | bomb|espionage|sequel|spy|terrorist | 994.0 | 393.0 | 85000 | . 3 813.0 | 22000.0 | 23000.0 | 27000.0 | 448130642.0 | Action|Thriller | 1144337 | 106759 | deception|imprisonment|lawlessness|police offi... | 2701.0 | 23000.0 | 164000 | . 4 NaN | 131.0 | NaN | 131.0 | NaN | Documentary | 8 | 143 | NaN | NaN | 12.0 | 0 | . ... ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | . 4911 1.0 | 2.0 | 318.0 | 637.0 | NaN | Comedy|Drama | 629 | 2283 | fraud|postal worker|prison|theft|trial | 6.0 | 470.0 | 84 | . 4912 43.0 | NaN | 319.0 | 841.0 | NaN | Crime|Drama|Mystery|Thriller | 73839 | 1753 | cult|fbi|hideout|prison escape|serial killer | 359.0 | 593.0 | 32000 | . 4913 13.0 | 0.0 | 0.0 | 0.0 | NaN | Drama|Horror|Thriller | 38 | 0 | NaN | 3.0 | 0.0 | 16 | . 4914 14.0 | 0.0 | 489.0 | 946.0 | 10443.0 | Comedy|Drama|Romance | 1255 | 2386 | NaN | 9.0 | 719.0 | 660 | . 4915 43.0 | 16.0 | 16.0 | 86.0 | 85222.0 | Documentary | 4285 | 163 | actress name in title|crush|date|four word tit... | 84.0 | 23.0 | 456 | . 4916 rows × 12 columns . c &#54841;&#51008; d&#47196; &#49884;&#51089;&#54616;&#45716; column &#49440;&#53469; . - 방법1 . df.iloc[:,map(lambda x: &#39;c&#39; == x[0] or &#39;d&#39; == x[0] ,df.columns )] . color director_name duration director_facebook_likes cast_total_facebook_likes country content_rating . 0 Color | James Cameron | 178.0 | 0.0 | 4834 | USA | PG-13 | . 1 Color | Gore Verbinski | 169.0 | 563.0 | 48350 | USA | PG-13 | . 2 Color | Sam Mendes | 148.0 | 0.0 | 11700 | UK | PG-13 | . 3 Color | Christopher Nolan | 164.0 | 22000.0 | 106759 | USA | PG-13 | . 4 NaN | Doug Walker | NaN | 131.0 | 143 | NaN | NaN | . ... ... | ... | ... | ... | ... | ... | ... | . 4911 Color | Scott Smith | 87.0 | 2.0 | 2283 | Canada | NaN | . 4912 Color | NaN | 43.0 | NaN | 1753 | USA | TV-14 | . 4913 Color | Benjamin Roberds | 76.0 | 0.0 | 0 | USA | NaN | . 4914 Color | Daniel Hsia | 100.0 | 0.0 | 2386 | USA | PG-13 | . 4915 Color | Jon Gunn | 90.0 | 16.0 | 163 | USA | PG | . 4916 rows × 7 columns . - 방법2 . df.loc[:,map(lambda x: &#39;c&#39; == x[0] or &#39;d&#39; == x[0] ,df.columns )] . color director_name duration director_facebook_likes cast_total_facebook_likes country content_rating . 0 Color | James Cameron | 178.0 | 0.0 | 4834 | USA | PG-13 | . 1 Color | Gore Verbinski | 169.0 | 563.0 | 48350 | USA | PG-13 | . 2 Color | Sam Mendes | 148.0 | 0.0 | 11700 | UK | PG-13 | . 3 Color | Christopher Nolan | 164.0 | 22000.0 | 106759 | USA | PG-13 | . 4 NaN | Doug Walker | NaN | 131.0 | 143 | NaN | NaN | . ... ... | ... | ... | ... | ... | ... | ... | . 4911 Color | Scott Smith | 87.0 | 2.0 | 2283 | Canada | NaN | . 4912 Color | NaN | 43.0 | NaN | 1753 | USA | TV-14 | . 4913 Color | Benjamin Roberds | 76.0 | 0.0 | 0 | USA | NaN | . 4914 Color | Daniel Hsia | 100.0 | 0.0 | 2386 | USA | PG-13 | . 4915 Color | Jon Gunn | 90.0 | 16.0 | 163 | USA | PG | . 4916 rows × 7 columns . df: &#49352;&#47196;&#50868; &#50676;&#51032; &#54624;&#45817; 1&#45800;&#44228; . &#48169;&#48277;1: concat . &#48169;&#48277;2: 4&#44032;&#51648; &#52968;&#49481;&#50640; &#46384;&#47480; &#54624;&#45817; . # &#52968;&#49481;1: &#48520;&#44032;&#45733; . df = pd.DataFrame({&#39;a&#39;:[1,2,3],&#39;b&#39;:[2,3,4]}) df . a b . 0 1 | 2 | . 1 2 | 3 | . 2 3 | 4 | . df.c = pd.Series([1,2,3]) df . /home/cgb2/anaconda3/envs/py37/lib/python3.7/site-packages/ipykernel_launcher.py:1: UserWarning: Pandas doesn&#39;t allow columns to be created via a new attribute name - see https://pandas.pydata.org/pandas-docs/stable/indexing.html#attribute-access . a b . 0 1 | 2 | . 1 2 | 3 | . 2 3 | 4 | . # &#52968;&#49481;2: &#44032;&#45733; . (예시1) . df = pd.DataFrame({&#39;a&#39;:[1,2,3],&#39;b&#39;:[2,3,4]}) df . a b . 0 1 | 2 | . 1 2 | 3 | . 2 3 | 4 | . df[&#39;c&#39;]=[3,4,5] df . a b c . 0 1 | 2 | 2 | . 1 2 | 3 | 3 | . 2 3 | 4 | 4 | . (예시2) . df = pd.DataFrame({&#39;a&#39;:[1,2,3],&#39;b&#39;:[2,3,4]}) df . a b . 0 1 | 2 | . 1 2 | 3 | . 2 3 | 4 | . df[[&#39;c&#39;,&#39;d&#39;]]=np.array([[3,4,5],[4,5,6]]).T # 굳이.. df . a b c d . 0 1 | 2 | 3 | 4 | . 1 2 | 3 | 4 | 5 | . 2 3 | 4 | 5 | 6 | . (예시3) . df = pd.DataFrame({&#39;a&#39;:[1,2,3],&#39;b&#39;:[2,3,4]}) df . a b . 0 1 | 2 | . 1 2 | 3 | . 2 3 | 4 | . df[&#39;c&#39;],df[&#39;d&#39;]=[3,4,5],[4,5,6] df . a b c d . 0 1 | 2 | 3 | 4 | . 1 2 | 3 | 4 | 5 | . 2 3 | 4 | 5 | 6 | . # &#52968;&#49481;3: &#48520;&#44032;&#45733; . (예시1) . df = pd.DataFrame({&#39;a&#39;:[1,2,3],&#39;b&#39;:[2,3,4]}) df . a b . 0 1 | 2 | . 1 2 | 3 | . 2 3 | 4 | . df.iloc[:,2] = [3,4,5] df . IndexError Traceback (most recent call last) /tmp/ipykernel_1576771/2293349637.py in &lt;module&gt; -&gt; 1 df.iloc[:,2] = [3,4,5] 2 df ~/anaconda3/envs/py37/lib/python3.7/site-packages/pandas/core/indexing.py in __setitem__(self, key, value) 718 key = com.apply_if_callable(key, self.obj) 719 indexer = self._get_setitem_indexer(key) --&gt; 720 self._has_valid_setitem_indexer(key) 721 722 iloc = self if self.name == &#34;iloc&#34; else self.obj.iloc ~/anaconda3/envs/py37/lib/python3.7/site-packages/pandas/core/indexing.py in _has_valid_setitem_indexer(self, indexer) 1459 elif is_integer(i): 1460 if i &gt;= len(ax): -&gt; 1461 raise IndexError(&#34;iloc cannot enlarge its target object&#34;) 1462 elif isinstance(i, dict): 1463 raise IndexError(&#34;iloc cannot enlarge its target object&#34;) IndexError: iloc cannot enlarge its target object . # &#52968;&#49481;4: &#44032;&#45733; . (예시1) . df = pd.DataFrame({&#39;a&#39;:[1,2,3],&#39;b&#39;:[2,3,4]}) df . a b . 0 1 | 2 | . 1 2 | 3 | . 2 3 | 4 | . df.loc[:,&#39;c&#39;] = [3,4,5] df . a b c . 0 1 | 2 | 3 | . 1 2 | 3 | 4 | . 2 3 | 4 | 5 | . (예시2) . df = pd.DataFrame({&#39;a&#39;:[1,2,3],&#39;b&#39;:[2,3,4]}) df . a b . 0 1 | 2 | . 1 2 | 3 | . 2 3 | 4 | . df.loc[:,[&#39;c&#39;,&#39;d&#39;]] = np.array([[3,4,5],[4,5,6]]).T # 이거 솔직히 되는지 몰랐어요.. df . a b c d . 0 1 | 2 | 3 | 4 | . 1 2 | 3 | 4 | 5 | . 2 3 | 4 | 5 | 6 | . (예시3) . df = pd.DataFrame({&#39;a&#39;:[1,2,3],&#39;b&#39;:[2,3,4]}) df . a b . 0 1 | 2 | . 1 2 | 3 | . 2 3 | 4 | . df.loc[:,&#39;c&#39;],df.loc[:,&#39;d&#39;] = [3,4,5],[4,5,6] df . a b c d . 0 1 | 2 | 3 | 4 | . 1 2 | 3 | 4 | 5 | . 2 3 | 4 | 5 | 6 | . &#48169;&#48277;3: .assign&#51004;&#47196; &#54624;&#45817; ($ star$) -- &#51228; &#52572;&#50528; . df = pd.DataFrame({&#39;a&#39;:[1,2,3],&#39;b&#39;:[2,3,4]}) df . a b . 0 1 | 2 | . 1 2 | 3 | . 2 3 | 4 | . df.assign(c=[3,4,5]) . a b c . 0 1 | 2 | 3 | . 1 2 | 3 | 4 | . 2 3 | 4 | 5 | . df.assign(c=[3,4,5],d=[4,5,6]) . a b c d . 0 1 | 2 | 3 | 4 | . 1 2 | 3 | 4 | 5 | . 2 3 | 4 | 5 | 6 | . df.assign(c=[3,4,5]).assign(d=[4,5,6]) . a b c d . 0 1 | 2 | 3 | 4 | . 1 2 | 3 | 4 | 5 | . 2 3 | 4 | 5 | 6 | . &#48169;&#48277;4: .eval&#51012; &#51060;&#50857;&#54620; &#54624;&#45817; . df = pd.DataFrame({&#39;a&#39;:[1,2,3],&#39;b&#39;:[2,3,4]}) df . a b . 0 1 | 2 | . 1 2 | 3 | . 2 3 | 4 | . df.eval(&#39;c=[3,4,5]&#39;) . a b c . 0 1 | 2 | 3 | . 1 2 | 3 | 4 | . 2 3 | 4 | 5 | . df.eval(&#39;c=[3,4,5]&#39;).eval(&#39;d=[4,5,6]&#39;) . a b c d . 0 1 | 2 | 3 | 4 | . 1 2 | 3 | 4 | 5 | . 2 3 | 4 | 5 | 6 | . &#50672;&#49845;&#54644;&#48372;&#44592; . # &#45936;&#51060;&#53552;&#54532;&#47112;&#51076; &#49373;&#49457; . df=pd.DataFrame({&#39;x&#39;:np.random.randn(1000),&#39;y&#39;:np.random.randn(1000)}) df . x y . 0 -0.764383 | -0.210562 | . 1 0.158599 | 0.519075 | . 2 1.310067 | 1.195781 | . 3 1.218756 | -0.461920 | . 4 -0.659421 | -1.291390 | . ... ... | ... | . 995 0.785107 | 0.389029 | . 996 -0.336152 | -0.069667 | . 997 -0.102498 | -1.220610 | . 998 -0.529699 | -0.718744 | . 999 0.943236 | 1.015053 | . 1000 rows × 2 columns . # &#49352;&#47196;&#50868;&#50676; r&#51012; &#49373;&#49457;&#54616;&#44256; $r= sqrt{x^2 + y^2}$&#47484; &#44228;&#49328; . - 방법1: 브로드캐스팅 . df.assign(r=np.sqrt(df.x**2 + df.y**2)) . x y r . 0 -0.764383 | -0.210562 | 0.792854 | . 1 0.158599 | 0.519075 | 0.542764 | . 2 1.310067 | 1.195781 | 1.773744 | . 3 1.218756 | -0.461920 | 1.303356 | . 4 -0.659421 | -1.291390 | 1.450008 | . ... ... | ... | ... | . 995 0.785107 | 0.389029 | 0.876206 | . 996 -0.336152 | -0.069667 | 0.343296 | . 997 -0.102498 | -1.220610 | 1.224906 | . 998 -0.529699 | -0.718744 | 0.892846 | . 999 0.943236 | 1.015053 | 1.385650 | . 1000 rows × 3 columns . - 방법2: lambda + map을 이용한 개별원소 계산 . df.assign(r=list(map(lambda x,y: np.sqrt(x**2+y**2), df.x,df.y))) . x y r . 0 -0.764383 | -0.210562 | 0.792854 | . 1 0.158599 | 0.519075 | 0.542764 | . 2 1.310067 | 1.195781 | 1.773744 | . 3 1.218756 | -0.461920 | 1.303356 | . 4 -0.659421 | -1.291390 | 1.450008 | . ... ... | ... | ... | . 995 0.785107 | 0.389029 | 0.876206 | . 996 -0.336152 | -0.069667 | 0.343296 | . 997 -0.102498 | -1.220610 | 1.224906 | . 998 -0.529699 | -0.718744 | 0.892846 | . 999 0.943236 | 1.015053 | 1.385650 | . 1000 rows × 3 columns . - 방법3: eval . df.eval(&#39;r=sqrt(x**2+y**2)&#39;) . x y r . 0 -0.764383 | -0.210562 | 0.792854 | . 1 0.158599 | 0.519075 | 0.542764 | . 2 1.310067 | 1.195781 | 1.773744 | . 3 1.218756 | -0.461920 | 1.303356 | . 4 -0.659421 | -1.291390 | 1.450008 | . ... ... | ... | ... | . 995 0.785107 | 0.389029 | 0.876206 | . 996 -0.336152 | -0.069667 | 0.343296 | . 997 -0.102498 | -1.220610 | 1.224906 | . 998 -0.529699 | -0.718744 | 0.892846 | . 999 0.943236 | 1.015053 | 1.385650 | . 1000 rows × 3 columns . &#50500;&#51060;&#49828;&#53356;&#47548;&#51012; &#47566;&#51060; &#47673;&#51004;&#47732; &#44152;&#47532;&#45716; &#48337; . - ref- 데이터 과학자의 사고법: 더 나은 선택을 위한 통계학적 통찰의 힘 . 구매할만한 책입니다 | . - 내용요약 . 여름 $ to$ 수영장 $ to$ 소아마비 | 여름 $ to$ 아이스크림 | 아이스크림과 소아마비는 상관관계가 높다: 아이스크림 성분중에서 소아마비를 유발하는 유해물질이 있을 것이다 (?) | . - 아래와 같이 모형을 간단하게 하자. . 온도 $ to$ 소아마비 | 온도 $ to$ 아이스크림 | . Toy exam . import numpy as np import matplotlib.pyplot as plt import pandas as pd . - 교재의 예제상황은 예를들면 아래와 같다. . (숨은진짜상황1) . $$ text{아이스크림 판매량} = 20 + 2 times text{온도} + epsilon$$ . np.random.seed(1) temp= np.array([-10.2, -5.2, 0.1, 10.1, 12.2, 14.7, 25.4, 26.8, 28.9, 35.1, 32.2, 34.6]) eps= np.random.normal(size=12,scale=5) icecream= 20 + temp * 2 + eps . plt.plot(temp,icecream,&#39;.&#39;) . [&lt;matplotlib.lines.Line2D at 0x7fe6f819b090&gt;] . 온도와 아이스크림 판매량의 산점도 | . (숨은진짜상황2) . - 소아마비 = 30 + 온도 $ times$ 0.5 + $ epsilon^*$ . 좌변의 &quot;소아마비&quot;는 소아마비임을 나타내는 어떠한 반응수치라고 생각하자. | . np.random.seed(2) eps = np.random.normal(size=12,scale=5) disease = 30+ temp* 0.5 + eps . plt.plot(temp,disease,&#39;.&#39;) . [&lt;matplotlib.lines.Line2D at 0x7fe6bb52d950&gt;] . 온도와 소아마비의 산점도 | . (우리가 데이터로부터 관측한 상황) . - 아이스크림과 질병의 산점도를 그려보자. . plt.plot(icecream,disease,&#39;.&#39;) . [&lt;matplotlib.lines.Line2D at 0x7fe6b7f11850&gt;] . 양의 상관관계에 있다. | . - 아이스크림 중 어떠한 물질이 소아마비를 일으키는것이 분명하므로 (인과성이 분명해보이니까) 아래와 같은 모형을 세우자. &lt;-- 여기서부터 틀렸음 . $${ tt disease}_i = beta_0 + beta_1 { tt icecream}_i + epsilon_i, quad textbf{for} ~~ i=1,2, dots, 12$$ . - 적절한 $ beta_0$와 $ beta_1$을 추정하면 우리는 아이스크림과 소아마비의 관계를 알 수 있다. &lt;-- 틀린주장 . 틀린 모형 | 도데체 우리가 뭘 잘못했는가? | . - 두 변수 사이에 상관관계가 있어도 실제 원인은 다른 변수에 숨겨져 있는 경우가 많다. . (ex1) . 온도 $ to$ 익사 | 온도 $ to$ 아이스크림 | 아이스크림과 익사자도 양의 상관관계에 있을것이다. | 아이스크림을 먹이면 물에 빠져 죽는다 $ to$ 틀린주장 | 사실 기온이 숨겨진 원인이다. 기온이 증가하면 아이스크림 판매량도 증가하고 폭염때문에 익사사고율도 높아지는 구조이다. | . (ex2) . 인구수 $ to$ 교회 | 인구수 $ to$ 범죄건수 | 지역별 교회와 범죄건수를 살펴보면 상관관계가 높게 나올것임 | 교회를 지으면 범죄건수도 증가한다? $ to$ 틀린주장 | 사실 인구가 숨겨진 요인임 | . - ex2, ex1에 대하여 바른 분석을 하려면? . ex2: 인구가 비슷한 도시끼리 묶어서 비교해보면 교회와 범죄의 건수는 양의 상관관계에 있지 않을것임 | ex1: 온도가 비슷한 그룹끼리 묶어보자. | . - 올바른 분석: 온도가 비슷한 그룹끼리 묶어서 그려보자. $ to$ 상관계수가 줄어들 것이다. . plt.plot(icecream[:6],disease[:6],&#39;.&#39;) . [&lt;matplotlib.lines.Line2D at 0x7fe6c3f7f9d0&gt;] . plt.plot(icecream[6:],disease[6:],&#39;.&#39;) . [&lt;matplotlib.lines.Line2D at 0x7fe6c3d157d0&gt;] . 진짜로 선형관계가 약해졌다.. | . &#51328; &#45908; &#44536;&#47092;&#46319;&#54620; &#51088;&#47308; . - 위의 toy example은 데이터가 너무 작아서 억지스러움 . df=pd.read_csv(&#39;https://raw.githubusercontent.com/guebin/2021DV/master/_notebooks/extremum.csv&#39;) . df . 지점번호 지점명 일시 평균기온(℃) 최고기온(℃) 최고기온시각 최저기온(℃) 최저기온시각일교차 Unnamed: 8 . 0 146 | 전주 | 2020-01-01 | -0.5 | 4.3 | 15:09 | -6.4 | 1:42 | 10.7 | . 1 146 | 전주 | 2020-01-02 | 1.4 | 6.5 | 14:12 | -3.0 | 7:55 | 9.5 | . 2 146 | 전주 | 2020-01-03 | 2.6 | 7.6 | 13:32 | -0.5 | 23:53 | 8.1 | . 3 146 | 전주 | 2020-01-04 | 2.0 | 7.7 | 13:51 | -2.6 | 5:30 | 10.3 | . 4 146 | 전주 | 2020-01-05 | 2.5 | 8.6 | 14:05 | -3.2 | 7:36 | 11.8 | . ... ... | ... | ... | ... | ... | ... | ... | ... | ... | . 651 146 | 전주 | 2021-10-13 | 19.9 | 25.5 | 14:29 | 15.6 | 3:49 | 9.9 | . 652 146 | 전주 | 2021-10-14 | 20.4 | 25.5 | 13:36 | 17.0 | 6:15 | 8.5 | . 653 146 | 전주 | 2021-10-15 | 18.3 | 22.0 | 13:47 | 15.7 | 4:48 | 6.3 | . 654 146 | 전주 | 2021-10-16 | 12.8 | 17.4 | 0:01 | 6.5 | 23:31 | 10.9 | . 655 146 | 전주 | 2021-10-17 | 6.7 | 12.4 | 15:18 | 2.2 | 6:43 | 10.2 | . 656 rows × 9 columns . - 평균기온만 선택하여 뽑자. . dict(pd.Series(df.columns)) . {0: &#39;지점번호&#39;, 1: &#39;지점명&#39;, 2: &#39;일시&#39;, 3: &#39;평균기온(℃)&#39;, 4: &#39;최고기온(℃)&#39;, 5: &#39;최고기온시각&#39;, 6: &#39;최저기온(℃)&#39;, 7: &#39;최저기온시각일교차&#39;, 8: &#39;Unnamed: 8&#39;} . temp=np.array(df.iloc[:,3]) . len(temp) . 656 . - 온도 vs 아이스크림 판매량 . np.random.seed(1) ϵ1=np.random.normal(size=656, scale=10) icecream=temp*2 + 30 + ϵ1 . plt.plot(temp,icecream,&#39;.&#39;) . [&lt;matplotlib.lines.Line2D at 0x7fe6c3a735d0&gt;] . - 온도 vs 소아마비 . np.random.seed(2) ϵ2=np.random.normal(size=656,scale=1) disease=temp*0.5 + 40 +ϵ2 . plt.plot(temp,disease,&#39;.&#39;) . [&lt;matplotlib.lines.Line2D at 0x7fe6c390af90&gt;] . - 아이스크림판매량 vs 소아마비 . plt.plot(icecream,disease,&#39;.&#39;) . [&lt;matplotlib.lines.Line2D at 0x7fe6c4509e50&gt;] . np.corrcoef(icecream,disease) . array([[1. , 0.86298975], [0.86298975, 1. ]]) . 0.86정도.. | . - 여름만 뽑아서 그러보면? . plt.plot(icecream[temp&gt;25],disease[temp&gt;25], &#39;.&#39;) ## 평균기온이 25도가 넘어가면 여름 . [&lt;matplotlib.lines.Line2D at 0x7fe6c37c99d0&gt;] . - 산점도 . fig , ((ax1,ax2), (ax3,ax4)) = plt.subplots(2,2) ax1.plot(temp,icecream,&#39;.&#39;) ax2.plot(temp,disease,&#39;.&#39;) ax3.plot(icecream,disease,&#39;.&#39;) ax4.plot(icecream[temp&gt;25],disease[temp&gt;25],&#39;.&#39;) . [&lt;matplotlib.lines.Line2D at 0x7fe6c324fd90&gt;] . fig , ((ax1,ax2), (ax3,ax4)) = plt.subplots(2,2) ax1.plot(temp,icecream,&#39;.&#39;) ax2.plot(temp,disease,&#39;.&#39;) ax3.plot(icecream,disease,&#39;.&#39;) ax4.plot(icecream,disease,&#39;.&#39;) ax4.plot(icecream[temp&gt;25],disease[temp&gt;25],&#39;.&#39;) . [&lt;matplotlib.lines.Line2D at 0x7fe6c3163910&gt;] . &#50728;&#46020;&#44396;&#44036;&#51012; &#49464;&#48516;&#54868; &#54616;&#50668; &#49884;&#44033;&#54868; . - 목표: 모든 온도구간에 대하여 각각 색을 다르게 하여 그려보자. . 사실 지금 변수는 온도, 아이스크림판매량, 소아마비 | 지금까지는 기본산점도만 사용하였기에 2차원플랏만 그렸음 $ to$ 그래서 각각의 산점도를 정신없이 그려왔음 | 온도가 유사한 지역을 색으로 묶으면 3차원 플랏이 가능함 | . - 일단 데이터 프레임을 정리하자. . df1=pd.DataFrame({&#39;temp&#39;:temp, &#39;icecream&#39;:icecream, &#39;disease&#39;:disease}) . df1 . temp icecream disease . 0 -0.5 | 45.243454 | 39.333242 | . 1 1.4 | 26.682436 | 40.643733 | . 2 2.6 | 29.918282 | 39.163804 | . 3 2.0 | 23.270314 | 42.640271 | . 4 2.5 | 43.654076 | 39.456564 | . ... ... | ... | ... | . 651 19.9 | 78.839992 | 49.633906 | . 652 20.4 | 86.554679 | 48.920443 | . 653 18.3 | 78.666079 | 49.882650 | . 654 12.8 | 52.771364 | 46.613159 | . 655 6.7 | 40.736731 | 44.902513 | . 656 rows × 3 columns . - 온도를 카테고리화 하자 $ to$ 적당한 구긴을 설정하기 위해서 히스토그램을 그려보자. . df1.temp.hist() . &lt;AxesSubplot:&gt; . plt.hist(df1.temp) . (array([ 3., 9., 29., 60., 92., 86., 65., 93., 139., 80.]), array([-12.4 , -8.16, -3.92, 0.32, 4.56, 8.8 , 13.04, 17.28, 21.52, 25.76, 30. ]), &lt;BarContainer object of 10 artists&gt;) . - 구간은 5정도로 하면 적당할것 같다. . def f(x): if x&lt;0: y=&#39;Temp: &lt;0&#39; elif x&lt;5: y=&#39;Temp: 0~5&#39; elif x&lt;10: y=&#39;Temp: 5~10&#39; elif x&lt;15: y=&#39;Temp: 10~15&#39; elif x&lt;20: y=&#39;Temp: 15~20&#39; elif x&lt;25: y=&#39;Temp: 20~25&#39; else: y=&#39;Temp: &gt;30&#39; return y . df1[&#39;temp2&#39;]=list(map(f,df1.temp)) . df1 . temp icecream disease temp2 . 0 -0.5 | 45.243454 | 39.333242 | Temp: &lt;0 | . 1 1.4 | 26.682436 | 40.643733 | Temp: 0~5 | . 2 2.6 | 29.918282 | 39.163804 | Temp: 0~5 | . 3 2.0 | 23.270314 | 42.640271 | Temp: 0~5 | . 4 2.5 | 43.654076 | 39.456564 | Temp: 0~5 | . ... ... | ... | ... | ... | . 651 19.9 | 78.839992 | 49.633906 | Temp: 15~20 | . 652 20.4 | 86.554679 | 48.920443 | Temp: 20~25 | . 653 18.3 | 78.666079 | 49.882650 | Temp: 15~20 | . 654 12.8 | 52.771364 | 46.613159 | Temp: 10~15 | . 655 6.7 | 40.736731 | 44.902513 | Temp: 5~10 | . 656 rows × 4 columns . from plotnine import * . ggplot(data=df1)+geom_point(aes(x=&#39;icecream&#39;,y=&#39;disease&#39;,colour=&#39;temp2&#39;),alpha=0.5) . &lt;ggplot: (8789318085145)&gt; . ggplot(data=df1)+geom_point(aes(x=&#39;icecream&#39;,y=&#39;disease&#39;,colour=&#39;temp2&#39;),alpha=0.2)+geom_smooth(aes(x=&#39;icecream&#39;,y=&#39;disease&#39;,colour=&#39;temp2&#39;),size=2,linetype=&#39;dashed&#39;) . /home/cgb2/anaconda3/envs/py37/lib/python3.7/site-packages/plotnine/stats/smoothers.py:311: PlotnineWarning: Confidence intervals are not yet implementedfor lowess smoothings. . &lt;ggplot: (8789316439909)&gt; . - 온도를 통제하니까 아이스크림과 질병은 관련이 없어보인다. . &#51652;&#51676; &#47564;&#50557;&#50640; &#50500;&#51060;&#49828;&#53356;&#47548;&#44284; &#49548;&#50500;&#47560;&#48708;&#44032; &#44288;&#47144;&#51080;&#45716; &#44221;&#50864;&#46972;&#47732;? . np.random.seed(1) ϵ1=np.random.normal(size=656, scale=10) icecream=temp*2 + 30 + ϵ1 . np.random.seed(2) ϵ2=np.random.normal(size=656,scale=1) disease= 30+ temp*0.0 + icecream*0.15 +ϵ2*2 . df2=pd.DataFrame({&#39;temp&#39;:temp,&#39;icecream&#39;:icecream,&#39;disease&#39;:disease}) df2[&#39;temp2&#39;]=list(map(f,df2.temp)) . df2 . temp icecream disease temp2 . 0 -0.5 | 45.243454 | 35.953002 | Temp: &lt;0 | . 1 1.4 | 26.682436 | 33.889832 | Temp: 0~5 | . 2 2.6 | 29.918282 | 30.215350 | Temp: 0~5 | . 3 2.0 | 23.270314 | 36.771089 | Temp: 0~5 | . 4 2.5 | 43.654076 | 32.961240 | Temp: 0~5 | . ... ... | ... | ... | ... | . 651 19.9 | 78.839992 | 41.193811 | Temp: 15~20 | . 652 20.4 | 86.554679 | 40.424088 | Temp: 20~25 | . 653 18.3 | 78.666079 | 43.265212 | Temp: 15~20 | . 654 12.8 | 52.771364 | 38.342022 | Temp: 10~15 | . 655 6.7 | 40.736731 | 39.215537 | Temp: 5~10 | . 656 rows × 4 columns . ggplot(data=df2)+geom_point(aes(x=&#39;icecream&#39;,y=&#39;disease&#39;,colour=&#39;temp2&#39;),alpha=0.2)+geom_smooth(aes(x=&#39;icecream&#39;,y=&#39;disease&#39;,colour=&#39;temp2&#39;),size=2,linetype=&#39;dashed&#39;) . /home/cgb2/anaconda3/envs/py37/lib/python3.7/site-packages/plotnine/stats/smoothers.py:311: PlotnineWarning: Confidence intervals are not yet implementedfor lowess smoothings. . &lt;ggplot: (8789318111317)&gt; . df1.corr() . temp icecream disease . temp 1.000000 | 0.884366 | 0.975609 | . icecream 0.884366 | 1.000000 | 0.862990 | . disease 0.975609 | 0.862990 | 1.000000 | . df2.corr() . temp icecream disease . temp 1.000000 | 0.884366 | 0.725505 | . icecream 0.884366 | 1.000000 | 0.830539 | . disease 0.725505 | 0.830539 | 1.000000 | . FIFA &#49440;&#49688;&#46308; &#49884;&#44033;&#54868; . FIFA data . - FIFA22라는 축구게임이 있음 (굉장히 인기있음) . - 게임에 실제 선수들이 나오면서 선수들의 능력치가 세밀하게 구현되어 있음 . - 이 능력치에 대한 데이터셋은 캐글에 공개되어 있음 . Data . fifa22=pd.read_csv(&#39;https://raw.githubusercontent.com/guebin/2021DV/master/_notebooks/2021-10-25-FIFA22_official_data.csv&#39;) . - Overall을 기준으로 정렬하여 보자. . fifa22=fifa22.sort_values(by=&#39;Overall&#39;,ascending=False).reset_index().rename(columns={&#39;index&#39;:&#39;index_old&#39;}) . fifa22.head() . index_old ID Name Age Photo Nationality Flag Overall Potential Club ... SlidingTackle GKDiving GKHandling GKKicking GKPositioning GKReflexes Best Position Best Overall Rating Release Clause DefensiveAwareness . 0 29 | 158023 | L. Messi | 34 | https://cdn.sofifa.com/players/158/023/22_60.png | Argentina | https://cdn.sofifa.com/flags/ar.png | 93 | 93 | Paris Saint-Germain | ... | 24.0 | 6.0 | 11.0 | 15.0 | 14.0 | 8.0 | RW | 93.0 | €144.3M | 20.0 | . 1 33 | 188545 | R. Lewandowski | 32 | https://cdn.sofifa.com/players/188/545/22_60.png | Poland | https://cdn.sofifa.com/flags/pl.png | 92 | 92 | FC Bayern München | ... | 19.0 | 15.0 | 6.0 | 12.0 | 8.0 | 10.0 | ST | 92.0 | €197.2M | 35.0 | . 2 14244 | 200389 | J. Oblak | 28 | https://cdn.sofifa.com/players/200/389/22_60.png | Slovenia | https://cdn.sofifa.com/flags/si.png | 91 | 93 | Atlético de Madrid | ... | 18.0 | 87.0 | 92.0 | 78.0 | 90.0 | 90.0 | GK | 91.0 | €238M | 27.0 | . 3 3 | 192985 | K. De Bruyne | 30 | https://cdn.sofifa.com/players/192/985/22_60.png | Belgium | https://cdn.sofifa.com/flags/be.png | 91 | 91 | Manchester City | ... | 53.0 | 15.0 | 13.0 | 5.0 | 10.0 | 13.0 | CM | 91.0 | €232.2M | 68.0 | . 4 64 | 190871 | Neymar Jr | 29 | https://cdn.sofifa.com/players/190/871/22_60.png | Brazil | https://cdn.sofifa.com/flags/br.png | 91 | 91 | Paris Saint-Germain | ... | 29.0 | 9.0 | 9.0 | 15.0 | 15.0 | 11.0 | LW | 91.0 | €238.7M | 35.0 | . 5 rows × 66 columns . Overall vs Potential . ggplot(data=fifa22)+geom_point(aes(x=&#39;Overall&#39;, y=&#39;Potential&#39;)) . &lt;ggplot: (8789316217305)&gt; . - 뭔가 Potential &gt; Overall 인 관계가 성립하는것 같다. $ to$ Potetial_Delta = Potential - Overall 인 변수를 새로 만들고 시각화해보자. . 판다스: 새로운열 추가 | . fifa22[&#39;Potential_Delta&#39;] = fifa22[&#39;Potential&#39;] - fifa22[&#39;Overall&#39;] . ggplot(data=fifa22)+geom_point(aes(x=&#39;Overall&#39;, y=&#39;Potential_Delta&#39;),alpha=0.1) . &lt;ggplot: (8789310568869)&gt; . ggplot(data=fifa22)+geom_point(aes(x=&#39;Overall&#39;, y=&#39;Potential_Delta&#39;),alpha=0.1,position=&#39;jitter&#39;) . &lt;ggplot: (8789315452065)&gt; . - Potential_Delta가 너무 0근처인 선수들이 있다. (아마 은퇴한 선수가 아닐까?) $ to$ 제외하고 그리자. . ggplot(data=fifa22.query(&#39;Potential_Delta&gt;0.1&#39;))+geom_point(aes(x=&#39;Overall&#39;, y=&#39;Potential_Delta&#39;),alpha=0.1,position=&#39;jitter&#39;) . &lt;ggplot: (8789315250289)&gt; . - 해석 . 음의 상관관계가 있다. | 오버올이 클수록 Potential_Delta의 분산이 작아진다. (오버올이 클수록 더 성장할 부분이 없으니까) | . - Overall을 구간별로 나누자: 어느정도가 적당한 구간일까? . fifa22.Overall.describe() . count 16710.000000 mean 67.646320 std 6.457695 min 28.000000 25% 63.000000 50% 68.000000 75% 72.000000 max 93.000000 Name: Overall, dtype: float64 . import matplotlib.pyplot as plt . fifa22.Overall.hist() . &lt;AxesSubplot:&gt; . def f(x): if x&gt;72: y=&#39;Q1&#39; elif x&gt;68: y=&#39;Q2&#39; elif x&gt;63: y=&#39;Q3&#39; else: y=&#39;Q4&#39; return y . fifa22[&#39;Q&#39;]=list(map(f,fifa22.Overall)) fifa22[[&#39;Q&#39;,&#39;Overall&#39;]] . Q Overall . 0 Q1 | 93 | . 1 Q1 | 92 | . 2 Q1 | 91 | . 3 Q1 | 91 | . 4 Q1 | 91 | . ... ... | ... | . 16705 Q4 | 46 | . 16706 Q4 | 46 | . 16707 Q4 | 44 | . 16708 Q4 | 44 | . 16709 Q4 | 28 | . 16710 rows × 2 columns . ggplot(data=fifa22.query(&#39;Potential2&gt;0.1&#39;)) +geom_boxplot(aes(x=&#39;Q&#39;,y=&#39;Potential2&#39;)) . &lt;ggplot: (8789310724501)&gt; . - Q1으로 갈수록 분산이 작아짐! $ to$ 헷갈린다... . - 산점도와 박스플랏을 겹쳐서 그린다면 좀더 이해가 쉬울것 같다. . - x축의 위치를 조정하면 될것 같다 $ to$ Q1, Q2, Q3, Q4 각 그룹별로 x축의 위치를 구하자. . fifa22.query(&#39;Q==&quot;Q1&quot;&#39;).Overall.mean() . 76.3506528835691 . 이런식으로 해도 되지만 | . fifa22.groupby(by=&#39;Q&#39;).mean().Overall . Q Q1 76.350653 Q2 70.411781 Q3 66.074449 Q4 59.602691 Name: Overall, dtype: float64 . l=fifa22.groupby(by=&#39;Q&#39;).mean().Overall.to_list() l . [76.3506528835691, 70.4117807472048, 66.07444942506334, 59.60269121813031] . - 이제 박스플랏이 들어갈 x축의 위치를 저장할 컬럼을 추가하고 그 이름을 Qx 라고 하자. . def g(x): if x==&#39;Q1&#39;: y=l[0] elif x==&#39;Q2&#39;: y=l[1] elif x==&#39;Q3&#39;: y=l[2] else: y=l[3] return y . fifa22[&#39;Qx&#39;]=list(map(g,fifa22.Q)) . fifa22 . index_old ID Name Age Photo Nationality Flag Overall Potential Club ... GKPositioning GKReflexes Best Position Best Overall Rating Release Clause DefensiveAwareness Potential2 Potential_Delta Q Qx . 0 29 | 158023 | L. Messi | 34 | https://cdn.sofifa.com/players/158/023/22_60.png | Argentina | https://cdn.sofifa.com/flags/ar.png | 93 | 93 | Paris Saint-Germain | ... | 14.0 | 8.0 | RW | 93.0 | €144.3M | 20.0 | 0 | 0 | Q1 | 76.350653 | . 1 33 | 188545 | R. Lewandowski | 32 | https://cdn.sofifa.com/players/188/545/22_60.png | Poland | https://cdn.sofifa.com/flags/pl.png | 92 | 92 | FC Bayern München | ... | 8.0 | 10.0 | ST | 92.0 | €197.2M | 35.0 | 0 | 0 | Q1 | 76.350653 | . 2 14244 | 200389 | J. Oblak | 28 | https://cdn.sofifa.com/players/200/389/22_60.png | Slovenia | https://cdn.sofifa.com/flags/si.png | 91 | 93 | Atlético de Madrid | ... | 90.0 | 90.0 | GK | 91.0 | €238M | 27.0 | 2 | 2 | Q1 | 76.350653 | . 3 3 | 192985 | K. De Bruyne | 30 | https://cdn.sofifa.com/players/192/985/22_60.png | Belgium | https://cdn.sofifa.com/flags/be.png | 91 | 91 | Manchester City | ... | 10.0 | 13.0 | CM | 91.0 | €232.2M | 68.0 | 0 | 0 | Q1 | 76.350653 | . 4 64 | 190871 | Neymar Jr | 29 | https://cdn.sofifa.com/players/190/871/22_60.png | Brazil | https://cdn.sofifa.com/flags/br.png | 91 | 91 | Paris Saint-Germain | ... | 15.0 | 11.0 | LW | 91.0 | €238.7M | 35.0 | 0 | 0 | Q1 | 76.350653 | . ... ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | . 16705 15593 | 235352 | 18 T. Käßemodel | 28 | https://cdn.sofifa.com/players/235/352/18_60.png | Germany | https://cdn.sofifa.com/flags/de.png | 46 | 46 | FC Erzgebirge Aue | ... | 13.0 | 6.0 | CM | 45.0 | €47K | NaN | 0 | 0 | Q4 | 59.602691 | . 16706 15685 | 219735 | 15 T. Fletcher | 19 | https://cdn.sofifa.com/players/219/735/15_60.png | England | https://cdn.sofifa.com/flags/gb-eng.png | 46 | 52 | Wycombe Wanderers | ... | 14.0 | 11.0 | CB | 46.0 | NaN | NaN | 6 | 6 | Q4 | 59.602691 | . 16707 16572 | 19334 | 10 I. Baraclough | 38 | https://cdn.sofifa.com/players/019/334/10_60.png | England | https://cdn.sofifa.com/flags/gb-eng.png | 44 | 65 | NaN | ... | 20.0 | 20.0 | CM | 46.0 | NaN | NaN | 21 | 21 | Q4 | 59.602691 | . 16708 15999 | 220806 | 16 E. Redman | 18 | https://cdn.sofifa.com/players/220/806/16_60.png | Wales | https://cdn.sofifa.com/flags/gb-wls.png | 44 | 57 | Newport County | ... | 9.0 | 7.0 | CB | 44.0 | NaN | NaN | 13 | 13 | Q4 | 59.602691 | . 16709 16709 | 178453 | 07 A. Censori | 17 | https://cdn.sofifa.com/players/178/453/07_60.png | Italy | https://cdn.sofifa.com/flags/it.png | 28 | 38 | Arezzo | ... | 6.0 | 9.0 | ST | 36.0 | NaN | NaN | 10 | 10 | Q4 | 59.602691 | . 16710 rows × 70 columns . ggplot(data=fifa22.query(&#39;Potential2&gt;0.1&#39;)) +geom_point(aes(x=&#39;Overall&#39;, y=&#39;Potential2&#39;,color=&#39;Q&#39;),alpha=0.1,size=0.1,position=&#39;jitter&#39;) +geom_boxplot(aes(x=&#39;Qx&#39;, y=&#39;Potential2&#39;,color=&#39;Q&#39;)) . &lt;ggplot: (8789309901365)&gt; .",
            "url": "https://guebin.github.io/DV2022/2022/10/17/(7%EC%A3%BC%EC%B0%A8)-10%EC%9B%9417%EC%9D%BC-draft.html",
            "relUrl": "/2022/10/17/(7%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1)-10%E1%84%8B%E1%85%AF%E1%86%AF17%E1%84%8B%E1%85%B5%E1%86%AF-draft.html",
            "date": " • Oct 17, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "draft",
            "content": "mpl &#48120;&#49464;&#47676;&#51648;&#54017; . Latex . - 예시1 . import numpy as np import matplotlib.pyplot as plt . x1= np.linspace(-2,2,1000) y1= (x1-1)**2 fig, ax = plt.subplots() ax.plot(x1,y1,&#39;--&#39;) ax.set_title(&#39;$y_1=(x_1-1)^2$&#39;) . Text(0.5, 1.0, &#39;$y_1=(x_1-1)^2$&#39;) . - 예시2 . x1 = np.linspace(-2,2,1000) y1 = 0.5*(x1-1)**2 fig, ax = plt.subplots() ax.plot(x1,y1,&#39;--&#39;) ax.set_title(r&#39;$y_1= frac{1}{2}(x_1-1)^2$&#39;,size=20); . - 예시3 . x1 = np.linspace(-2,2,1000) y1 = 0.5*(x1-1)**2 fig, ax = plt.subplots() ax.plot(x1,y1,&#39;--&#39;) ax.set_title(r&#39;$y_1= frac{1}{2}(x_1-1)^2$&#39;,size=20) ax.set_xlabel(r&#39;$x_1$&#39;,size=15) ax.set_ylabel(r&#39;$y_1$&#39;,size=15); . - 예시4 . x1 = np.linspace(-2,2,1000) y1 = 0.5*(x1-1)**2 y2 = 0.5*(x1+1)**2 fig, ax = plt.subplots() ax.plot(x1,y1,&#39;--&#39;,label=r&#39;$ frac{1}{2}(x-1)^2$&#39;) ax.plot(x1,y2,&#39;--&#39;,label=r&#39;$ frac{1}{2}(x+1)^2$&#39;) ax.legend() . &lt;matplotlib.legend.Legend at 0x7f0076915510&gt; . fig.subplots() . fig,ax = plt.subplots(2,2) ax[0,0].plot([1,2,4,3],&#39;o&#39;,color=&#39;C0&#39;) ax[0,1].plot([1,2,4,3],&#39;o&#39;,color=&#39;C1&#39;) ax[1,0].plot([1,2,4,3],&#39;o&#39;,color=&#39;C2&#39;) ax[1,1].plot([1,2,4,3],&#39;o&#39;,color=&#39;C3&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f007c350e10&gt;] . fig = plt.figure() ax = fig.subplots(2,2) ax[0,0].plot([1,2,4,3],&#39;o&#39;,color=&#39;C0&#39;) ax[0,1].plot([1,2,4,3],&#39;o&#39;,color=&#39;C1&#39;) ax[1,0].plot([1,2,4,3],&#39;o&#39;,color=&#39;C2&#39;) ax[1,1].plot([1,2,4,3],&#39;o&#39;,color=&#39;C3&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f007cfcce90&gt;] . plt.subplot . 끝에 s가 없어요!! | . - 기능1: 몰라도 됩니당.. (아마도) . - 기능2: 특이해요.. fig를 안받아도 무방함 . ax1 = plt.subplot(221) ax2 = plt.subplot(222) ax3 = plt.subplot(223) ax4 = plt.subplot(224) ax1.plot([1,2,4,3],&#39;o&#39;,color=&#39;C0&#39;);ax1.set_title(&#39;221&#39;) ax2.plot([1,2,4,3],&#39;o&#39;,color=&#39;C1&#39;);ax2.set_title(&#39;222&#39;) ax3.plot([1,2,4,3],&#39;o&#39;,color=&#39;C2&#39;);ax3.set_title(&#39;223&#39;) ax4.plot([1,2,4,3],&#39;o&#39;,color=&#39;C3&#39;);ax4.set_title(&#39;224&#39;) fig=plt.gcf() fig.suptitle(&quot;plt.subplot(22x)&quot;,size=15) fig.tight_layout() . 위는 아래와 같은 코드임 . fig = plt.figure() ax1 = fig.add_subplot(221) ax2 = fig.add_subplot(222) ax3 = fig.add_subplot(223) ax4 = fig.add_subplot(224) ax1.plot([1,2,4,3],&#39;o&#39;,color=&#39;C0&#39;);ax1.set_title(&#39;221&#39;) ax2.plot([1,2,4,3],&#39;o&#39;,color=&#39;C1&#39;);ax2.set_title(&#39;222&#39;) ax3.plot([1,2,4,3],&#39;o&#39;,color=&#39;C2&#39;);ax3.set_title(&#39;223&#39;) ax4.plot([1,2,4,3],&#39;o&#39;,color=&#39;C3&#39;);ax4.set_title(&#39;224&#39;) fig.tight_layout() fig.suptitle(&quot;fig.add_subplot(22x)&quot;,size=15) fig.tight_layout() . - fig.add_subplot() vs fig.add_axes() . fig.add_subplot(): 입력으로 nrows, ncols, index 전달 (편하게 쓰기엔 좋아) | fig.add_axes(): 입력으로 left, bottom, width, height 전달 (이상한 그래프 만들기 좋아) | . - plt.subplots() vs plt.subplot() . plt.subplots(): 넣을 수 있는 액시즈 종류가 한가지 | plt.subplot(): 여러 (특이한) 액시즈를 넣을 수 있음 | . (기본액시즈) . plt.subplot(111,projection=None) . &lt;AxesSubplot:&gt; . (3d 액시즈) . ax=plt.subplot(111,projection=&#39;3d&#39;) ax.plot([1,2,3,4],[1,2,-3,4],[1,2,-3,-4],&#39;--o&#39;) fig=plt.gcf() fig.set_figheight(12) . (polar 액시즈) . ax=plt.subplot(111,projection=&#39;polar&#39;) r = np.linspace(0,5,100) theta = np.linspace(0,2*np.pi,100) ax.plot(theta,r) . [&lt;matplotlib.lines.Line2D at 0x7f007e52e650&gt;] .",
            "url": "https://guebin.github.io/DV2022/2022/10/16/Untitled1.html",
            "relUrl": "/2022/10/16/Untitled1.html",
            "date": " • Oct 16, 2022"
        }
        
    
  
    
        ,"post3": {
            "title": "(6주차) 10월12일, 10월14일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . imports . import numpy as np import pandas as pd import matplotlib.pyplot as plt . lambda, map ($ star$) . lambda . - 예제1: 람다표현식(lambda expression)자체가 하나의 오브젝트임 . lambda x: (x-2)**2 ### lambda x: (x-2)**2 가 실행되는 순간 메모리상에 함수 오브젝트가 저장됨 . &lt;function __main__.&lt;lambda&gt;(x)&gt; . &quot;lambda x: (x-2)**2&quot; 는 $lambda(x)=(x-2)^2$의 느낌으로 기억하면 쉬움 | . (사용방법) . (lambda x: (x-2)**2)(2) # 입력2 -&gt; 출력 (2-2)^2 =0 . 0 . (lambda x: (x-2)**2)(4) # 입력5 -&gt; 출력 (4-2)^2 =4 . 4 . (lambda x: (x-2)**2)(6) # 입력6 -&gt; 출력 (6-2)^2 =16 . 16 . (lambda x: (x-2)**2)(-2) # 입력-2 -&gt; 출력 (-2-2)^2 =16 . 16 . - 예제2: 람다표현식에 이름을 줄 수 있음. . f = lambda x: (x-2)**2 . f(2),f(4),f(6),f(-2) . (0, 4, 16, 16) . 위의 코드는 아래와 같다. . def f(x): return (x-2)**2 f(2),f(4),f(6),f(-2) . (0, 4, 16, 16) . - 예제3: 조건부 출력 . f = lambda x,y: x if x&gt;y else y # x,y가 입력 -&gt; x&gt;y 일때만 x를 리턴하고 그렇지않으면 y를 리턴 = 큰값을 리턴하라는 소리임 . f(1,20) . 20 . - 예제4: 람다표현식들의 리스트 . fl = [lambda x: x, lambda x: x**2, lambda x: x**3] . for f in fl: print(f(2)) . 2 4 8 . x = np.linspace(-1,1,100) for f in fl: plt.plot(x,f(x),&#39;--&#39;) . - 예제5: 람다표현식들의 딕셔너리 . fd = {&#39;f1&#39;:lambda x: x, &#39;f2&#39;:lambda x: x**2, &#39;f3&#39;:lambda x: x**3} fd . {&#39;f1&#39;: &lt;function __main__.&lt;lambda&gt;(x)&gt;, &#39;f2&#39;: &lt;function __main__.&lt;lambda&gt;(x)&gt;, &#39;f3&#39;: &lt;function __main__.&lt;lambda&gt;(x)&gt;} . for k in fd: plt.plot(x,fd[k](x),&#39;--&#39;) . - 예제6: 람다표현식을 리턴하는 함수 (함수를 리턴하는 함수) . (예비학습) 함수 $g(x)$가 정의되어 있을때 $ frac{d}{dx}g(x)$의 값을 계산해보기 . g = lambda x: x**2 . gg = lambda x : (g(x+0.001)-g(x))/0.001 . gg(4) . 8.0010000000037 . (목표) 도함수를 구해주는 derivate 함수를 정의하자. 이 함수는 임의의 함수 g를 입력으로 받으면, g의 도함수(gg)가 리턴되는 기능을 가진다. . def derivate(g): return lambda x: (g(x+0.001)-g(x))/0.001 . (사용1) . g = lambda x: np.sin(x) . gg = derivate(g) . x = np.linspace(0,6.28,1000) . plt.plot(x,g(x),label=r&#39;$f(x)=sin(x)$&#39;) plt.plot(x,gg(x),label=r&#39;$ frac{d}{dx}f(x)=cos(x)$&#39;) plt.legend(fontsize=15) . &lt;matplotlib.legend.Legend at 0x7fa54cde3a50&gt; . (사용2) . g0 = lambda x: (1/6)*x**3 g1 = derivate(g0) # (1/2)x^2 g2 = derivate(g1) # x . x = np.linspace(-1,1,100) plt.plot(x,g0(x),&#39;--&#39;,label=r&#39;$g_0(x)= frac{1}{6}x^3$&#39;) plt.plot(x,g1(x),&#39;--&#39;,label=r&#39;$g_1(x)= frac{1}{2}x^2$&#39;) plt.plot(x,g2(x),&#39;--&#39;,label=r&#39;$g_2(x)=x$&#39;) plt.legend(fontsize=15) . &lt;matplotlib.legend.Legend at 0x7fa54cccc2d0&gt; . - 예제7: 예제6의 다른표현 . derivate = lambda g: lambda x: (g(x+0.001)-g(x))/0.001 . (사용1) . g = lambda x: np.sin(x) . gg = derivate(g) . x = np.linspace(0,6.28,1000) . plt.plot(x,g(x),label=r&#39;$f(x)=sin(x)$&#39;) plt.plot(x,gg(x),label=r&#39;$ frac{d}{dx}f(x)=cos(x)$&#39;) plt.legend(fontsize=15) . &lt;matplotlib.legend.Legend at 0x7fa54cdb1b10&gt; . (사용2) . g0 = lambda x: (1/6)*x**3 g1 = derivate(g0) # (1/2)x^2 g2 = derivate(g1) # x . x = np.linspace(-1,1,100) plt.plot(x,g0(x),&#39;--&#39;,label=r&#39;$g_0(x)= frac{1}{6}x^3$&#39;) plt.plot(x,g1(x),&#39;--&#39;,label=r&#39;$g_1(x)= frac{1}{2}x^2$&#39;) plt.plot(x,g2(x),&#39;--&#39;,label=r&#39;$g_2(x)=x$&#39;) plt.legend(fontsize=15) . &lt;matplotlib.legend.Legend at 0x7fa54cee96d0&gt; . map . - 개념: $ text{map} left(f,[x_1,x_2, dots,x_n] right)= left[f(x_1),f(x_2), dots,f(x_n) right] $ . - 예제1: . x=[1,2,3] f = lambda x: x+1 y = list(map(f,x)) . (다른구현1) . list(map(lambda x: x+1,[1,2,3])) . [2, 3, 4] . (다른구현2) . f = lambda x: x+1 [f(xi) for xi in [1,2,3]] . [2, 3, 4] . (다른구현3) . [(lambda x: x+1)(xi) for xi in [1,2,3]] . [2, 3, 4] . (다른구현4)--최악 . y = [] x = [1,2,3] f = lambda x: x+1 for xi in x: y.append(f(xi)) . y . [2, 3, 4] . (다른구현5)--더 최악 . y = [] x = [1,2,3] f = lambda x: x+1 for i in range(len(x)): y.append(f(x[i])) . y . [2, 3, 4] . - 예제2: 문자열을 입력으로 받고 대문자이면 True, 소문자이면 False . 입력: A,B,C,a,b,c 출력: T,T,T,F,F,F . x= list(&#39;ABCabc&#39;) # x = [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;] f = lambda s: s.isupper() y = list(map(f,x)) . x,y . ([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;], [True, True, True, False, False, False]) . - 예제3: 두개의 입력을 받는 함수 (map을 이용하는 것이 리스트 컴프리헨션보다 조금 편한것 같다) . list(map(lambda x,y: x+y, [1,2,3],[-1,-2,-3])) . [0, 0, 0] . (다른구현)-- 리스트컴프리헨션 . f = lambda x,y: x+y [f(x,y) for x,y in zip([1,2,3],[-1,-2,-3])] . [0, 0, 0] . - 예제4: map은 &quot;하나의 함수에 다양한 입력&quot;을 적용하는 경우에만 사용가능, 리스트컴프리헨션은 &quot;다양한 함수에 다양한 입력&quot; 지원 . flst = [lambda x: x+1, lambda x: x+2, lambda x:x+3] . map으로 구현시도 $ to$ 실패 . list(map(flst,[-1,-2,-3])) # 결과가 0,0,0 . TypeError Traceback (most recent call last) /tmp/ipykernel_1457577/3991505680.py in &lt;module&gt; -&gt; 1 list(map(flst,[-1,-2,-3])) # 결과가 0,0,0 TypeError: &#39;list&#39; object is not callable . 리스트컴프리헨션으로 구현시도 $ to$ 성공 . [f(x) for f,x in zip(flst,[-1,-2,-3])] . [0, 0, 0] . - 종합: map과 리스트컴프리헨션과 비교 . map은 for문을 위한 $i$등의 인덱스를 쓰지 않지만 리스트컴프리헨션은 필요함 | map은 좀더 리스트컴프리헨션보다 제약적으로 사용할 수 밖에 없음. | . df: &#51064;&#45937;&#49905; 1&#45800;&#44228;-- &#51064;&#45937;&#49905;&#51032; 4&#44032;&#51648; &#52968;&#49481; . &#45936;&#51060;&#53552;&#54532;&#47112;&#51076; &#51456;&#48708; . - 데이터준비 . df=pd.read_csv(&#39;https://raw.githubusercontent.com/guebin/DV2022/master/_notebooks/dv2022.csv&#39;) df . att rep mid fin . 0 65 | 45 | 0 | 10 | . 1 95 | 30 | 60 | 10 | . 2 65 | 85 | 15 | 20 | . 3 55 | 35 | 35 | 5 | . 4 80 | 60 | 55 | 70 | . ... ... | ... | ... | ... | . 195 55 | 70 | 40 | 95 | . 196 65 | 85 | 25 | 85 | . 197 85 | 85 | 100 | 10 | . 198 80 | 65 | 35 | 60 | . 199 50 | 95 | 45 | 85 | . 200 rows × 4 columns . - 앞으로는 위와 같은 df형태를 가정할 것이다. 즉 column의 이름은 문자열, row의 이름은 0부터 시작하는 정수로 가정한다. . - 아래와 같은 형태는 일단 생각하지 않는다. . pd.DataFrame({&#39;att&#39;:[60,65,80,90],&#39;rep&#39;:[50,100,90,100]},index=[&#39;규빈&#39;,&#39;영미&#39;,&#39;성준&#39;,&#39;혜미&#39;]) . att rep . 규빈 60 | 50 | . 영미 65 | 100 | . 성준 80 | 90 | . 혜미 90 | 100 | . df&#51032; 4&#44032;&#51648; &#52968;&#49481; . - 원소에 접근하는 4가지 방법: ., [], .iloc[], .loc[] . &#52968;&#49481;1: &#53364;&#47000;&#49828;&#45712;&#45196; . - 컨셉1: df는 인스턴스이다. 그리고 df.att, df.rep,df.mid, df.fin 와 같이 col이름에 대응하는 속성이 있다. . df.head() . att rep mid fin . 0 65 | 45 | 0 | 10 | . 1 95 | 30 | 60 | 10 | . 2 65 | 85 | 15 | 20 | . 3 55 | 35 | 35 | 5 | . 4 80 | 60 | 55 | 70 | . df.fin . 0 10 1 10 2 20 3 5 4 70 .. 195 95 196 85 197 10 198 60 199 85 Name: fin, Length: 200, dtype: int64 . - 언제유용? col의 이름을 대충 알고 있을 경우 자동완성으로 쉽게 선택가능 . &#52968;&#49481;2: &#46357;&#49492;&#45320;&#47532; + $ alpha$ &#45712;&#45196; . - 컨셉2: df는 컬럼이름이 key, 컬럼의데이터가 value가 되는 dictionary로 이해할 수 있다. 즉 아래의 dct와 같은 딕셔너리로 이해할 수 있다. . dct = dict(df) #dct . (예시) .keys() 메소드를 이용하여 컬럼들의 이름을 살펴볼 수 있음. . dct.keys(), df.keys() . (dict_keys([&#39;att&#39;, &#39;rep&#39;, &#39;mid&#39;, &#39;fin&#39;]), Index([&#39;att&#39;, &#39;rep&#39;, &#39;mid&#39;, &#39;fin&#39;], dtype=&#39;object&#39;)) . # col indexing . - 예시1: dct가 가능하면 df도 가능하다. . df[&#39;att&#39;] #dct[&#39;att&#39;] . 0 65 1 95 2 65 3 55 4 80 .. 195 55 196 65 197 85 198 80 199 50 Name: att, Length: 200, dtype: int64 . - 예시2: dct가 가능하면 df도 가능하다. (2) . df.get(&#39;att&#39;) #dct.get(&#39;att&#39;) . 0 65 1 95 2 65 3 55 4 80 .. 195 55 196 65 197 85 198 80 199 50 Name: att, Length: 200, dtype: int64 . - 예시3: dct에서 불가능하지만 df에서 가능한것도 있다. . dct.get([&#39;att&#39;,&#39;rep&#39;]) . TypeError Traceback (most recent call last) /tmp/ipykernel_1457577/2570151095.py in &lt;module&gt; -&gt; 1 dct.get([&#39;att&#39;,&#39;rep&#39;]) TypeError: unhashable type: &#39;list&#39; . df.get([&#39;att&#39;,&#39;rep&#39;]) . att rep . 0 65 | 45 | . 1 95 | 30 | . 2 65 | 85 | . 3 55 | 35 | . 4 80 | 60 | . ... ... | ... | . 195 55 | 70 | . 196 65 | 85 | . 197 85 | 85 | . 198 80 | 65 | . 199 50 | 95 | . 200 rows × 2 columns . - 예시4: dct에서 불가능하지만 df에서 가능한것도 있다. (2) . dct[[&#39;att&#39;,&#39;rep&#39;]] . TypeError Traceback (most recent call last) /tmp/ipykernel_1457577/2053155993.py in &lt;module&gt; -&gt; 1 dct[[&#39;att&#39;,&#39;rep&#39;]] TypeError: unhashable type: &#39;list&#39; . df[[&#39;att&#39;,&#39;rep&#39;]] . att rep . 0 65 | 45 | . 1 95 | 30 | . 2 65 | 85 | . 3 55 | 35 | . 4 80 | 60 | . ... ... | ... | . 195 55 | 70 | . 196 65 | 85 | . 197 85 | 85 | . 198 80 | 65 | . 199 50 | 95 | . 200 rows × 2 columns . # row indexing . - 예시5: dct에서 불가능하지만 df에서 가능한것도 있다. (3) . dct[:5] . TypeError Traceback (most recent call last) /tmp/ipykernel_1457577/3946458840.py in &lt;module&gt; -&gt; 1 dct[:5] TypeError: unhashable type: &#39;slice&#39; . df[:5] . att rep mid fin . 0 65 | 45 | 0 | 10 | . 1 95 | 30 | 60 | 10 | . 2 65 | 85 | 15 | 20 | . 3 55 | 35 | 35 | 5 | . 4 80 | 60 | 55 | 70 | . &#52968;&#49481;3: &#45336;&#54028;&#51060;&#45712;&#45196; . - 컨셉3: df.iloc은 넘파이에러이처럼 생각가능하다. 즉 아래의 arr와 같은 넘파이어레이로 생각가능하다. . arr = np.array(df) #arr . # row indexing . - 예시1: 단일레이블 . arr[0,:] # first row arr[0,] arr[0] . array([65, 45, 0, 10]) . df.iloc[0,:] # first row df.iloc[0,] df.iloc[0] . att 65 rep 45 mid 0 fin 10 Name: 0, dtype: int64 . - 예시2: 레이블의 리스트 . arr[[0,1,2],:] # 처음 3개의 row 선택 arr[[0,1,2],] arr[[0,1,2]] . array([[65, 45, 0, 10], [95, 30, 60, 10], [65, 85, 15, 20]]) . df.iloc[[0,1,2],:] # 처음 3개의 row 선택 df.iloc[[0,1,2],] df.iloc[[0,1,2]] . att rep mid fin . 0 65 | 45 | 0 | 10 | . 1 95 | 30 | 60 | 10 | . 2 65 | 85 | 15 | 20 | . - 예시3: 슬랑이싱 . arr[0:3,:] # 처음 3개의 row선택, 끝점포함X arr[0:3,] arr[0:3] . array([[65, 45, 0, 10], [95, 30, 60, 10], [65, 85, 15, 20]]) . df.iloc[0:3,:] # 처음 3개의 row선택, 끝점포함X df.iloc[0:3,] df.iloc[0:3] . att rep mid fin . 0 65 | 45 | 0 | 10 | . 1 95 | 30 | 60 | 10 | . 2 65 | 85 | 15 | 20 | . # col indexing . - 예시1: 단일레이블 . df.iloc[:,0] # first column # arr[:,0] # first column . 0 65 1 95 2 65 3 55 4 80 .. 195 55 196 65 197 85 198 80 199 50 Name: att, Length: 200, dtype: int64 . - 예시2: 레이블의 리스트 . df.iloc[:,[0,2]] # col1, col3 을 선택 # arr[:,[0,2]] # col1, col3 을 선택 . att mid . 0 65 | 0 | . 1 95 | 60 | . 2 65 | 15 | . 3 55 | 35 | . 4 80 | 55 | . ... ... | ... | . 195 55 | 40 | . 196 65 | 25 | . 197 85 | 100 | . 198 80 | 35 | . 199 50 | 45 | . 200 rows × 2 columns . - 예시3: 슬랑이싱 . df.iloc[:,0:3] # 처음 3개의 col선택, 끝점포함X #arr[:,0:3] . att rep mid . 0 65 | 45 | 0 | . 1 95 | 30 | 60 | . 2 65 | 85 | 15 | . 3 55 | 35 | 35 | . 4 80 | 60 | 55 | . ... ... | ... | ... | . 195 55 | 70 | 40 | . 196 65 | 85 | 25 | . 197 85 | 85 | 100 | . 198 80 | 65 | 35 | . 199 50 | 95 | 45 | . 200 rows × 3 columns . # row + col indexing . df.iloc[::2,0:3] . att rep mid . 0 65 | 45 | 0 | . 2 65 | 85 | 15 | . 4 80 | 60 | 55 | . 6 65 | 70 | 60 | . 8 95 | 55 | 65 | . ... ... | ... | ... | . 190 95 | 35 | 40 | . 192 100 | 40 | 80 | . 194 65 | 40 | 65 | . 196 65 | 85 | 25 | . 198 80 | 65 | 35 | . 100 rows × 3 columns . &#52968;&#49481;4: &#45936;&#51060;&#53552;&#54532;&#47112;&#51076; &#45712;&#45196; . - 컨셉4: df.loc은 새로운 느낌.. (R에 익숙하면 df.loc이 dataframe 혹은 티블느낌이라고 보시면 됩니다) . import rpy2 %load_ext rpy2.ipython . %%R library(tidyverse) mpg[1:5,c(&#39;model&#39;,&#39;year&#39;)] . # A tibble: 5 × 2 model year &lt;chr&gt; &lt;int&gt; 1 a4 1999 2 a4 1999 3 a4 2008 4 a4 2008 5 a4 1999 . # row indexing . - 예시1: 단일레이블 . df.loc[0,:] # 첫번째 row를 선택 df.loc[0,] df.loc[0] . att 65 rep 45 mid 0 fin 10 Name: 0, dtype: int64 . - 예시2: 레이블의 리스트 . df.loc[[0,1,2],:] # 처음 3개의 row를 선택 df.loc[[0,1,2],] df.loc[[0,1,2]] . att rep mid fin . 0 65 | 45 | 0 | 10 | . 1 95 | 30 | 60 | 10 | . 2 65 | 85 | 15 | 20 | . - 예시3: 슬라이싱 (끝점포함 O) . df.loc[0:3,:] # 처음 4개의 row를 선택, 끝점포함 df.loc[0:3,] df.loc[0:3] . att rep mid fin . 0 65 | 45 | 0 | 10 | . 1 95 | 30 | 60 | 10 | . 2 65 | 85 | 15 | 20 | . 3 55 | 35 | 35 | 5 | . # col indexing . - 예시1: 단일레이블 . df.loc[:,&#39;att&#39;] . 0 65 1 95 2 65 3 55 4 80 .. 195 55 196 65 197 85 198 80 199 50 Name: att, Length: 200, dtype: int64 . - 예시2: 레이블의 리스트 . df.loc[:,[&#39;att&#39;,&#39;mid&#39;]] . att mid . 0 65 | 0 | . 1 95 | 60 | . 2 65 | 15 | . 3 55 | 35 | . 4 80 | 55 | . ... ... | ... | . 195 55 | 40 | . 196 65 | 25 | . 197 85 | 100 | . 198 80 | 35 | . 199 50 | 45 | . 200 rows × 2 columns . - 예시3: 슬라이싱 (끝점포함 O) . df.loc[:,&#39;att&#39;:&#39;mid&#39;] # 끝점포함 . att rep mid . 0 65 | 45 | 0 | . 1 95 | 30 | 60 | . 2 65 | 85 | 15 | . 3 55 | 35 | 35 | . 4 80 | 60 | 55 | . ... ... | ... | ... | . 195 55 | 70 | 40 | . 196 65 | 85 | 25 | . 197 85 | 85 | 100 | . 198 80 | 65 | 35 | . 199 50 | 95 | 45 | . 200 rows × 3 columns . # row + col indexing . df.loc[::-1,&#39;att&#39;:&#39;mid&#39;] # 끝점포함 . att rep mid . 199 50 | 95 | 45 | . 198 80 | 65 | 35 | . 197 85 | 85 | 100 | . 196 65 | 85 | 25 | . 195 55 | 70 | 40 | . ... ... | ... | ... | . 4 80 | 60 | 55 | . 3 55 | 35 | 35 | . 2 65 | 85 | 15 | . 1 95 | 30 | 60 | . 0 65 | 45 | 0 | . 200 rows × 3 columns . &#52968;&#49481;1~4 &#51221;&#47532; . . [] .iloc .loc . row/단일레이블 | X | X | O | O | . col/단일레이블 | O | O | O | O | . row/레이블리스트 | X | X | O | O | . col/레이블리스트 | X | O | O | O | . row/슬라이싱 | X | O | O | O | . col/슬라이싱 | X | X | O | O | . - col 이름을 알아야하는 부담감 . . : 앞글자만 대충 알아도 자동완성 가능 | []: 정확한 col 이름을 알아야 함 | .loc: 보통 정확한 col 이름을 알아야 하지만 슬라이싱 이용시 양 끝의 컬럼이름만 알면 무방 | .iloc: 정확한 col 이름을 몰라도 번호로 인덱싱 가능 | . - 자주하는 실수 . df[&#39;att&#39;] # 가능 # df.loc[&#39;att&#39;] # 불가능 df.loc[:,&#39;att&#39;] # 가능 . 0 65 1 95 2 65 3 55 4 80 .. 195 55 196 65 197 85 198 80 199 50 Name: att, Length: 200, dtype: int64 . df: &#51064;&#45937;&#49905; 2&#45800;&#44228;-- &#54596;&#53552;&#47553;(&#53945;&#51221;&#51312;&#44148;&#50640; &#47582;&#45716; row&#47484; &#49440;&#53469;) . att &gt; 90 and rep &lt; 50 . - 방법1: .query()를 이용 . df.query(&#39;att&gt;90 and rep&lt;50&#39;) . att rep mid fin . 1 95 | 30 | 60 | 10 | . 12 95 | 35 | 0 | 25 | . 48 95 | 45 | 35 | 80 | . 56 95 | 25 | 95 | 90 | . 78 95 | 45 | 90 | 35 | . 107 100 | 30 | 60 | 65 | . 112 100 | 35 | 70 | 0 | . 113 95 | 45 | 55 | 65 | . 163 100 | 25 | 10 | 20 | . 174 100 | 40 | 40 | 15 | . 176 100 | 30 | 70 | 70 | . 184 100 | 30 | 30 | 85 | . 190 95 | 35 | 40 | 95 | . 192 100 | 40 | 80 | 80 | . df.query(&#39;(att&gt;90)&amp;(rep&lt;50)&#39;) . att rep mid fin . 1 95 | 30 | 60 | 10 | . 12 95 | 35 | 0 | 25 | . 48 95 | 45 | 35 | 80 | . 56 95 | 25 | 95 | 90 | . 78 95 | 45 | 90 | 35 | . 107 100 | 30 | 60 | 65 | . 112 100 | 35 | 70 | 0 | . 113 95 | 45 | 55 | 65 | . 163 100 | 25 | 10 | 20 | . 174 100 | 40 | 40 | 15 | . 176 100 | 30 | 70 | 70 | . 184 100 | 30 | 30 | 85 | . 190 95 | 35 | 40 | 95 | . 192 100 | 40 | 80 | 80 | . df.query(&#39;att&gt;90 &amp; rep&lt;50&#39;) . att rep mid fin . 1 95 | 30 | 60 | 10 | . 12 95 | 35 | 0 | 25 | . 48 95 | 45 | 35 | 80 | . 56 95 | 25 | 95 | 90 | . 78 95 | 45 | 90 | 35 | . 107 100 | 30 | 60 | 65 | . 112 100 | 35 | 70 | 0 | . 113 95 | 45 | 55 | 65 | . 163 100 | 25 | 10 | 20 | . 174 100 | 40 | 40 | 15 | . 176 100 | 30 | 70 | 70 | . 184 100 | 30 | 30 | 85 | . 190 95 | 35 | 40 | 95 | . 192 100 | 40 | 80 | 80 | . - 방법2: [], .iloc, .loc . df[(df.att &gt; 90)&amp;(df.rep &lt; 50)] df.loc[(df.att &gt; 90)&amp;(df.rep &lt; 50)] df.iloc[list((df.att &gt; 90)&amp;(df.rep &lt; 50))] . att rep mid fin . 1 95 | 30 | 60 | 10 | . 12 95 | 35 | 0 | 25 | . 48 95 | 45 | 35 | 80 | . 56 95 | 25 | 95 | 90 | . 78 95 | 45 | 90 | 35 | . 107 100 | 30 | 60 | 65 | . 112 100 | 35 | 70 | 0 | . 113 95 | 45 | 55 | 65 | . 163 100 | 25 | 10 | 20 | . 174 100 | 40 | 40 | 15 | . 176 100 | 30 | 70 | 70 | . 184 100 | 30 | 30 | 85 | . 190 95 | 35 | 40 | 95 | . 192 100 | 40 | 80 | 80 | . - 방법3: [], .iloc, .loc // map, lambda . df[list(map(lambda x,y: (x&gt;90)&amp;(y&lt;50), df.att, df.rep))] # df[map(lambda x,y: (x&gt;90)&amp;(y&lt;50), df.att, df.rep)] # 이것은 불가능 . att rep mid fin . 1 95 | 30 | 60 | 10 | . 12 95 | 35 | 0 | 25 | . 48 95 | 45 | 35 | 80 | . 56 95 | 25 | 95 | 90 | . 78 95 | 45 | 90 | 35 | . 107 100 | 30 | 60 | 65 | . 112 100 | 35 | 70 | 0 | . 113 95 | 45 | 55 | 65 | . 163 100 | 25 | 10 | 20 | . 174 100 | 40 | 40 | 15 | . 176 100 | 30 | 70 | 70 | . 184 100 | 30 | 30 | 85 | . 190 95 | 35 | 40 | 95 | . 192 100 | 40 | 80 | 80 | . df.iloc[list(map(lambda x,y: (x&gt;90)&amp;(y&lt;50), df.att, df.rep))] df.iloc[map(lambda x,y: (x&gt;90)&amp;(y&lt;50), df.att, df.rep)] . att rep mid fin . 1 95 | 30 | 60 | 10 | . 12 95 | 35 | 0 | 25 | . 48 95 | 45 | 35 | 80 | . 56 95 | 25 | 95 | 90 | . 78 95 | 45 | 90 | 35 | . 107 100 | 30 | 60 | 65 | . 112 100 | 35 | 70 | 0 | . 113 95 | 45 | 55 | 65 | . 163 100 | 25 | 10 | 20 | . 174 100 | 40 | 40 | 15 | . 176 100 | 30 | 70 | 70 | . 184 100 | 30 | 30 | 85 | . 190 95 | 35 | 40 | 95 | . 192 100 | 40 | 80 | 80 | . df.loc[list(map(lambda x,y: (x&gt;90)&amp;(y&lt;50), df.att, df.rep))] df.loc[map(lambda x,y: (x&gt;90)&amp;(y&lt;50), df.att, df.rep)] . att rep mid fin . 1 95 | 30 | 60 | 10 | . 12 95 | 35 | 0 | 25 | . 48 95 | 45 | 35 | 80 | . 56 95 | 25 | 95 | 90 | . 78 95 | 45 | 90 | 35 | . 107 100 | 30 | 60 | 65 | . 112 100 | 35 | 70 | 0 | . 113 95 | 45 | 55 | 65 | . 163 100 | 25 | 10 | 20 | . 174 100 | 40 | 40 | 15 | . 176 100 | 30 | 70 | 70 | . 184 100 | 30 | 30 | 85 | . 190 95 | 35 | 40 | 95 | . 192 100 | 40 | 80 | 80 | . att &gt; mean(att) . - 방법1: .query()를 이용 . df.query(&#39;att&gt; att.mean()&#39;) . att rep mid fin . 1 95 | 30 | 60 | 10 | . 4 80 | 60 | 55 | 70 | . 8 95 | 55 | 65 | 90 | . 9 90 | 25 | 95 | 50 | . 11 95 | 60 | 25 | 55 | . ... ... | ... | ... | ... | . 184 100 | 30 | 30 | 85 | . 190 95 | 35 | 40 | 95 | . 192 100 | 40 | 80 | 80 | . 197 85 | 85 | 100 | 10 | . 198 80 | 65 | 35 | 60 | . 95 rows × 4 columns . - 방법2: [], .iloc, .loc . df[df.att &gt; df.att.mean()] df.loc[df.att &gt; df.att.mean()] df.iloc[list(df.att &gt; df.att.mean())] . att rep mid fin . 1 95 | 30 | 60 | 10 | . 4 80 | 60 | 55 | 70 | . 8 95 | 55 | 65 | 90 | . 9 90 | 25 | 95 | 50 | . 11 95 | 60 | 25 | 55 | . ... ... | ... | ... | ... | . 184 100 | 30 | 30 | 85 | . 190 95 | 35 | 40 | 95 | . 192 100 | 40 | 80 | 80 | . 197 85 | 85 | 100 | 10 | . 198 80 | 65 | 35 | 60 | . 95 rows × 4 columns . - 방법3: [], .iloc, .loc // map, lambda . df[list(map(lambda x: x&gt;df.att.mean() , df.att))] # df[map(lambda x: x&gt;df.att.mean() , df.att)] # 이것은 불가능 . att rep mid fin . 1 95 | 30 | 60 | 10 | . 4 80 | 60 | 55 | 70 | . 8 95 | 55 | 65 | 90 | . 9 90 | 25 | 95 | 50 | . 11 95 | 60 | 25 | 55 | . ... ... | ... | ... | ... | . 184 100 | 30 | 30 | 85 | . 190 95 | 35 | 40 | 95 | . 192 100 | 40 | 80 | 80 | . 197 85 | 85 | 100 | 10 | . 198 80 | 65 | 35 | 60 | . 95 rows × 4 columns . df.iloc[list(map(lambda x: x&gt;df.att.mean() , df.att))] df.iloc[map(lambda x: x&gt;df.att.mean() , df.att)] . att rep mid fin . 1 95 | 30 | 60 | 10 | . 4 80 | 60 | 55 | 70 | . 8 95 | 55 | 65 | 90 | . 9 90 | 25 | 95 | 50 | . 11 95 | 60 | 25 | 55 | . ... ... | ... | ... | ... | . 184 100 | 30 | 30 | 85 | . 190 95 | 35 | 40 | 95 | . 192 100 | 40 | 80 | 80 | . 197 85 | 85 | 100 | 10 | . 198 80 | 65 | 35 | 60 | . 95 rows × 4 columns . df.loc[list(map(lambda x: x&gt;df.att.mean() , df.att))] df.loc[map(lambda x: x&gt;df.att.mean() , df.att)] . att rep mid fin . 1 95 | 30 | 60 | 10 | . 4 80 | 60 | 55 | 70 | . 8 95 | 55 | 65 | 90 | . 9 90 | 25 | 95 | 50 | . 11 95 | 60 | 25 | 55 | . ... ... | ... | ... | ... | . 184 100 | 30 | 30 | 85 | . 190 95 | 35 | 40 | 95 | . 192 100 | 40 | 80 | 80 | . 197 85 | 85 | 100 | 10 | . 198 80 | 65 | 35 | 60 | . 95 rows × 4 columns . . [] .iloc .loc . row/단일레이블 | X | X | O | O | . col/단일레이블 | O | O | O | O | . row/레이블리스트 | X | X | O | O | . col/레이블리스트 | X | O | O | O | . row/슬라이싱 | X | O | O | O | . col/슬라이싱 | X | X | O | O | . row/bool,list | X | O | O | O | . row/bool,ser | X | O | X | O | . row/bool,map | X | X | O | O | . &#49689;&#51228; . 1. 10&#50900;12&#51068; &#49689;&#51228; . 아래와 같이 0~9까지 포함된 리스트를 만들어라 . x=list(range(10)) x . [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] . 아래와 동일한 기능을 수행하는 함수를 lambda expression으로 정의하라. . def f(xi): return &#39;짝&#39; if (xi % 2)==0 else &#39;홀&#39; . map과 lambda expression 을 이용하여 아래와 같은 결과를 만들어라. (리스트컴프리헨션, for문 사용금지) . # 구현예시 . [&#39;짝&#39;, &#39;홀&#39;, &#39;짝&#39;, &#39;홀&#39;, &#39;짝&#39;, &#39;홀&#39;, &#39;짝&#39;, &#39;홀&#39;, &#39;짝&#39;, &#39;홀&#39;] . 2. 10&#50900;14&#51068; &#49689;&#51228; . 다음과 같은 데이터프레임을 불러온 뒤 물음에 답하라 . df=pd.read_csv(&#39;https://raw.githubusercontent.com/guebin/DV2022/master/_notebooks/dv2022.csv&#39;) df . att rep mid fin . 0 65 | 45 | 0 | 10 | . 1 95 | 30 | 60 | 10 | . 2 65 | 85 | 15 | 20 | . 3 55 | 35 | 35 | 5 | . 4 80 | 60 | 55 | 70 | . ... ... | ... | ... | ... | . 195 55 | 70 | 40 | 95 | . 196 65 | 85 | 25 | 85 | . 197 85 | 85 | 100 | 10 | . 198 80 | 65 | 35 | 60 | . 199 50 | 95 | 45 | 85 | . 200 rows × 4 columns . (1) 기말고사 성적이 중간고사 성적보다 향상된 학생들을 출력하라. 즉 mid &lt; fin 인 학생들을 출력하라. (다양한 방법으로 연습할 것, 제출은 한 가지 방법으로 구현해도 감점없음) . # 구현결과가 아래와 같아야 한다. . att rep mid fin . 0 65 | 45 | 0 | 10 | . 2 65 | 85 | 15 | 20 | . 4 80 | 60 | 55 | 70 | . 5 75 | 40 | 75 | 85 | . 6 65 | 70 | 60 | 75 | . ... ... | ... | ... | ... | . 194 65 | 40 | 65 | 70 | . 195 55 | 70 | 40 | 95 | . 196 65 | 85 | 25 | 85 | . 198 80 | 65 | 35 | 60 | . 199 50 | 95 | 45 | 85 | . 93 rows × 4 columns . (2) 기말고사 성적이 중간고사 성적보다 향상된 학생들의 출석과 레포트 점수를 출력하라. . # 구현결과가 아래와 같아야 한다. . att rep . 0 65 | 45 | . 2 65 | 85 | . 4 80 | 60 | . 5 75 | 40 | . 6 65 | 70 | . ... ... | ... | . 194 65 | 40 | . 195 55 | 70 | . 196 65 | 85 | . 198 80 | 65 | . 199 50 | 95 | . 93 rows × 2 columns .",
            "url": "https://guebin.github.io/DV2022/2022/10/12/(6%EC%A3%BC%EC%B0%A8)-10%EC%9B%9412%EC%9D%BC.html",
            "relUrl": "/2022/10/12/(6%EC%A3%BC%EC%B0%A8)-10%EC%9B%9412%EC%9D%BC.html",
            "date": " • Oct 12, 2022"
        }
        
    
  
    
        ,"post4": {
            "title": "(6주차) 10월12일, 10월14일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . imports . import numpy as np import pandas as pd import matplotlib.pyplot as plt . lambda, map ($ star$) . lambda . - 예제1: 람다표현식(lambda expression)자체가 하나의 오브젝트임 . lambda x: (x-2)**2 ### lambda x: (x-2)**2 가 실행되는 순간 메모리상에 함수 오브젝트가 저장됨 . &lt;function __main__.&lt;lambda&gt;(x)&gt; . &quot;lambda x: (x-2)**2&quot; 는 $lambda(x)=(x-2)^2$의 느낌으로 기억하면 쉬움 | . (사용방법) . (lambda x: (x-2)**2)(2) # 입력2 -&gt; 출력 (2-2)^2 =0 . 0 . (lambda x: (x-2)**2)(4) # 입력5 -&gt; 출력 (4-2)^2 =4 . 4 . (lambda x: (x-2)**2)(6) # 입력6 -&gt; 출력 (6-2)^2 =16 . 16 . (lambda x: (x-2)**2)(-2) # 입력-2 -&gt; 출력 (-2-2)^2 =16 . 16 . - 예제2: 람다표현식에 이름을 줄 수 있음. . f = lambda x: (x-2)**2 . f(2),f(4),f(6),f(-2) . (0, 4, 16, 16) . 위의 코드는 아래와 같다. . def f(x): return (x-2)**2 f(2),f(4),f(6),f(-2) . (0, 4, 16, 16) . - 예제3: 조건부 출력 . f = lambda x,y: x if x&gt;y else y # x,y가 입력 -&gt; x&gt;y 일때만 x를 리턴하고 그렇지않으면 y를 리턴 = 큰값을 리턴하라는 소리임 . f(1,20) . 20 . - 예제4: 람다표현식들의 리스트 . fl = [lambda x: x, lambda x: x**2, lambda x: x**3] . for f in fl: print(f(2)) . 2 4 8 . x = np.linspace(-1,1,100) for f in fl: plt.plot(x,f(x),&#39;--&#39;) . - 예제5: 람다표현식들의 딕셔너리 . fd = {&#39;f1&#39;:lambda x: x, &#39;f2&#39;:lambda x: x**2, &#39;f3&#39;:lambda x: x**3} fd . {&#39;f1&#39;: &lt;function __main__.&lt;lambda&gt;(x)&gt;, &#39;f2&#39;: &lt;function __main__.&lt;lambda&gt;(x)&gt;, &#39;f3&#39;: &lt;function __main__.&lt;lambda&gt;(x)&gt;} . for k in fd: plt.plot(x,fd[k](x),&#39;--&#39;) . - 예제6: 람다표현식을 리턴하는 함수 (함수를 리턴하는 함수) . (예비학습) 함수 $g(x)$가 정의되어 있을때 $ frac{d}{dx}g(x)$의 값을 계산해보기 . g = lambda x: x**2 . gg = lambda x : (g(x+0.001)-g(x))/0.001 . gg(4) . 8.0010000000037 . (목표) 도함수를 구해주는 derivate 함수를 정의하자. 이 함수는 임의의 함수 g를 입력으로 받으면, g의 도함수(gg)가 리턴되는 기능을 가진다. . def derivate(g): return lambda x: (g(x+0.001)-g(x))/0.001 . (사용1) . g = lambda x: np.sin(x) . gg = derivate(g) . x = np.linspace(0,6.28,1000) . plt.plot(x,g(x),label=r&#39;$f(x)=sin(x)$&#39;) plt.plot(x,gg(x),label=r&#39;$ frac{d}{dx}f(x)=cos(x)$&#39;) plt.legend(fontsize=15) . &lt;matplotlib.legend.Legend at 0x7fa54cde3a50&gt; . (사용2) . g0 = lambda x: (1/6)*x**3 g1 = derivate(g0) # (1/2)x^2 g2 = derivate(g1) # x . x = np.linspace(-1,1,100) plt.plot(x,g0(x),&#39;--&#39;,label=r&#39;$g_0(x)= frac{1}{6}x^3$&#39;) plt.plot(x,g1(x),&#39;--&#39;,label=r&#39;$g_1(x)= frac{1}{2}x^2$&#39;) plt.plot(x,g2(x),&#39;--&#39;,label=r&#39;$g_2(x)=x$&#39;) plt.legend(fontsize=15) . &lt;matplotlib.legend.Legend at 0x7fa54cccc2d0&gt; . - 예제7: 예제6의 다른표현 . derivate = lambda g: lambda x: (g(x+0.001)-g(x))/0.001 . (사용1) . g = lambda x: np.sin(x) . gg = derivate(g) . x = np.linspace(0,6.28,1000) . plt.plot(x,g(x),label=r&#39;$f(x)=sin(x)$&#39;) plt.plot(x,gg(x),label=r&#39;$ frac{d}{dx}f(x)=cos(x)$&#39;) plt.legend(fontsize=15) . &lt;matplotlib.legend.Legend at 0x7fa54cdb1b10&gt; . (사용2) . g0 = lambda x: (1/6)*x**3 g1 = derivate(g0) # (1/2)x^2 g2 = derivate(g1) # x . x = np.linspace(-1,1,100) plt.plot(x,g0(x),&#39;--&#39;,label=r&#39;$g_0(x)= frac{1}{6}x^3$&#39;) plt.plot(x,g1(x),&#39;--&#39;,label=r&#39;$g_1(x)= frac{1}{2}x^2$&#39;) plt.plot(x,g2(x),&#39;--&#39;,label=r&#39;$g_2(x)=x$&#39;) plt.legend(fontsize=15) . &lt;matplotlib.legend.Legend at 0x7fa54cee96d0&gt; . map . - 개념: $ text{map} left(f,[x_1,x_2, dots,x_n] right)= left[f(x_1),f(x_2), dots,f(x_n) right] $ . - 예제1: . x=[1,2,3] f = lambda x: x+1 y = list(map(f,x)) . (다른구현1) . list(map(lambda x: x+1,[1,2,3])) . [2, 3, 4] . (다른구현2) . f = lambda x: x+1 [f(xi) for xi in [1,2,3]] . [2, 3, 4] . (다른구현3) . [(lambda x: x+1)(xi) for xi in [1,2,3]] . [2, 3, 4] . (다른구현4)--최악 . y = [] x = [1,2,3] f = lambda x: x+1 for xi in x: y.append(f(xi)) . y . [2, 3, 4] . (다른구현5)--더 최악 . y = [] x = [1,2,3] f = lambda x: x+1 for i in range(len(x)): y.append(f(x[i])) . y . [2, 3, 4] . - 예제2: 문자열을 입력으로 받고 대문자이면 True, 소문자이면 False . 입력: A,B,C,a,b,c 출력: T,T,T,F,F,F . x= list(&#39;ABCabc&#39;) # x = [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;] f = lambda s: s.isupper() y = list(map(f,x)) . x,y . ([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;], [True, True, True, False, False, False]) . - 예제3: 두개의 입력을 받는 함수 (map을 이용하는 것이 리스트 컴프리헨션보다 조금 편한것 같다) . list(map(lambda x,y: x+y, [1,2,3],[-1,-2,-3])) . [0, 0, 0] . (다른구현)-- 리스트컴프리헨션 . f = lambda x,y: x+y [f(x,y) for x,y in zip([1,2,3],[-1,-2,-3])] . [0, 0, 0] . - 예제4: map은 &quot;하나의 함수에 다양한 입력&quot;을 적용하는 경우에만 사용가능, 리스트컴프리헨션은 &quot;다양한 함수에 다양한 입력&quot; 지원 . flst = [lambda x: x+1, lambda x: x+2, lambda x:x+3] . map으로 구현시도 $ to$ 실패 . list(map(flst,[-1,-2,-3])) # 결과가 0,0,0 . TypeError Traceback (most recent call last) /tmp/ipykernel_1457577/3991505680.py in &lt;module&gt; -&gt; 1 list(map(flst,[-1,-2,-3])) # 결과가 0,0,0 TypeError: &#39;list&#39; object is not callable . 리스트컴프리헨션으로 구현시도 $ to$ 성공 . [f(x) for f,x in zip(flst,[-1,-2,-3])] . [0, 0, 0] . - 종합: map과 리스트컴프리헨션과 비교 . map은 for문을 위한 $i$등의 인덱스를 쓰지 않지만 리스트컴프리헨션은 필요함 | map은 좀더 리스트컴프리헨션보다 제약적으로 사용할 수 밖에 없음. | . df: &#51064;&#45937;&#49905; 1&#45800;&#44228;-- &#51064;&#45937;&#49905;&#51032; 4&#44032;&#51648; &#52968;&#49481; . &#45936;&#51060;&#53552;&#54532;&#47112;&#51076; &#51456;&#48708; . - 데이터준비 . df=pd.read_csv(&#39;https://raw.githubusercontent.com/guebin/DV2022/master/_notebooks/dv2022.csv&#39;) df . att rep mid fin . 0 65 | 45 | 0 | 10 | . 1 95 | 30 | 60 | 10 | . 2 65 | 85 | 15 | 20 | . 3 55 | 35 | 35 | 5 | . 4 80 | 60 | 55 | 70 | . ... ... | ... | ... | ... | . 195 55 | 70 | 40 | 95 | . 196 65 | 85 | 25 | 85 | . 197 85 | 85 | 100 | 10 | . 198 80 | 65 | 35 | 60 | . 199 50 | 95 | 45 | 85 | . 200 rows × 4 columns . - 앞으로는 위와 같은 df형태를 가정할 것이다. 즉 column의 이름은 문자열, row의 이름은 0부터 시작하는 정수로 가정한다. . - 아래와 같은 형태는 일단 생각하지 않는다. . pd.DataFrame({&#39;att&#39;:[60,65,80,90],&#39;rep&#39;:[50,100,90,100]},index=[&#39;규빈&#39;,&#39;영미&#39;,&#39;성준&#39;,&#39;혜미&#39;]) . att rep . 규빈 60 | 50 | . 영미 65 | 100 | . 성준 80 | 90 | . 혜미 90 | 100 | . df&#51032; 4&#44032;&#51648; &#52968;&#49481; . - 원소에 접근하는 4가지 방법: ., [], .iloc[], .loc[] . &#52968;&#49481;1: &#53364;&#47000;&#49828;&#45712;&#45196; . - 컨셉1: df는 인스턴스이다. 그리고 df.att, df.rep,df.mid, df.fin 와 같이 col이름에 대응하는 속성이 있다. . df.head() . att rep mid fin . 0 65 | 45 | 0 | 10 | . 1 95 | 30 | 60 | 10 | . 2 65 | 85 | 15 | 20 | . 3 55 | 35 | 35 | 5 | . 4 80 | 60 | 55 | 70 | . df.fin . 0 10 1 10 2 20 3 5 4 70 .. 195 95 196 85 197 10 198 60 199 85 Name: fin, Length: 200, dtype: int64 . - 언제유용? col의 이름을 대충 알고 있을 경우 자동완성으로 쉽게 선택가능 . &#52968;&#49481;2: &#46357;&#49492;&#45320;&#47532; + $ alpha$ &#45712;&#45196; . - 컨셉2: df는 컬럼이름이 key, 컬럼의데이터가 value가 되는 dictionary로 이해할 수 있다. 즉 아래의 dct와 같은 딕셔너리로 이해할 수 있다. . dct = dict(df) #dct . (예시) .keys() 메소드를 이용하여 컬럼들의 이름을 살펴볼 수 있음. . dct.keys(), df.keys() . (dict_keys([&#39;att&#39;, &#39;rep&#39;, &#39;mid&#39;, &#39;fin&#39;]), Index([&#39;att&#39;, &#39;rep&#39;, &#39;mid&#39;, &#39;fin&#39;], dtype=&#39;object&#39;)) . # col indexing . - 예시1: dct가 가능하면 df도 가능하다. . df[&#39;att&#39;] #dct[&#39;att&#39;] . 0 65 1 95 2 65 3 55 4 80 .. 195 55 196 65 197 85 198 80 199 50 Name: att, Length: 200, dtype: int64 . - 예시2: dct가 가능하면 df도 가능하다. (2) . df.get(&#39;att&#39;) #dct.get(&#39;att&#39;) . 0 65 1 95 2 65 3 55 4 80 .. 195 55 196 65 197 85 198 80 199 50 Name: att, Length: 200, dtype: int64 . - 예시3: dct에서 불가능하지만 df에서 가능한것도 있다. . dct.get([&#39;att&#39;,&#39;rep&#39;]) . TypeError Traceback (most recent call last) /tmp/ipykernel_1457577/2570151095.py in &lt;module&gt; -&gt; 1 dct.get([&#39;att&#39;,&#39;rep&#39;]) TypeError: unhashable type: &#39;list&#39; . df.get([&#39;att&#39;,&#39;rep&#39;]) . att rep . 0 65 | 45 | . 1 95 | 30 | . 2 65 | 85 | . 3 55 | 35 | . 4 80 | 60 | . ... ... | ... | . 195 55 | 70 | . 196 65 | 85 | . 197 85 | 85 | . 198 80 | 65 | . 199 50 | 95 | . 200 rows × 2 columns . - 예시4: dct에서 불가능하지만 df에서 가능한것도 있다. (2) . dct[[&#39;att&#39;,&#39;rep&#39;]] . TypeError Traceback (most recent call last) /tmp/ipykernel_1457577/2053155993.py in &lt;module&gt; -&gt; 1 dct[[&#39;att&#39;,&#39;rep&#39;]] TypeError: unhashable type: &#39;list&#39; . df[[&#39;att&#39;,&#39;rep&#39;]] . att rep . 0 65 | 45 | . 1 95 | 30 | . 2 65 | 85 | . 3 55 | 35 | . 4 80 | 60 | . ... ... | ... | . 195 55 | 70 | . 196 65 | 85 | . 197 85 | 85 | . 198 80 | 65 | . 199 50 | 95 | . 200 rows × 2 columns . # row indexing . - 예시5: dct에서 불가능하지만 df에서 가능한것도 있다. (3) . dct[:5] . TypeError Traceback (most recent call last) /tmp/ipykernel_1457577/3946458840.py in &lt;module&gt; -&gt; 1 dct[:5] TypeError: unhashable type: &#39;slice&#39; . df[:5] . att rep mid fin . 0 65 | 45 | 0 | 10 | . 1 95 | 30 | 60 | 10 | . 2 65 | 85 | 15 | 20 | . 3 55 | 35 | 35 | 5 | . 4 80 | 60 | 55 | 70 | . &#52968;&#49481;3: &#45336;&#54028;&#51060;&#45712;&#45196; . - 컨셉3: df.iloc은 넘파이에러이처럼 생각가능하다. 즉 아래의 arr와 같은 넘파이어레이로 생각가능하다. . arr = np.array(df) #arr . # row indexing . - 예시1: 단일레이블 . arr[0,:] # first row arr[0,] arr[0] . array([65, 45, 0, 10]) . df.iloc[0,:] # first row df.iloc[0,] df.iloc[0] . att 65 rep 45 mid 0 fin 10 Name: 0, dtype: int64 . - 예시2: 레이블의 리스트 . arr[[0,1,2],:] # 처음 3개의 row 선택 arr[[0,1,2],] arr[[0,1,2]] . array([[65, 45, 0, 10], [95, 30, 60, 10], [65, 85, 15, 20]]) . df.iloc[[0,1,2],:] # 처음 3개의 row 선택 df.iloc[[0,1,2],] df.iloc[[0,1,2]] . att rep mid fin . 0 65 | 45 | 0 | 10 | . 1 95 | 30 | 60 | 10 | . 2 65 | 85 | 15 | 20 | . - 예시3: 슬랑이싱 . arr[0:3,:] # 처음 3개의 row선택, 끝점포함X arr[0:3,] arr[0:3] . array([[65, 45, 0, 10], [95, 30, 60, 10], [65, 85, 15, 20]]) . df.iloc[0:3,:] # 처음 3개의 row선택, 끝점포함X df.iloc[0:3,] df.iloc[0:3] . att rep mid fin . 0 65 | 45 | 0 | 10 | . 1 95 | 30 | 60 | 10 | . 2 65 | 85 | 15 | 20 | . # col indexing . - 예시1: 단일레이블 . df.iloc[:,0] # first column # arr[:,0] # first column . 0 65 1 95 2 65 3 55 4 80 .. 195 55 196 65 197 85 198 80 199 50 Name: att, Length: 200, dtype: int64 . - 예시2: 레이블의 리스트 . df.iloc[:,[0,2]] # col1, col3 을 선택 # arr[:,[0,2]] # col1, col3 을 선택 . att mid . 0 65 | 0 | . 1 95 | 60 | . 2 65 | 15 | . 3 55 | 35 | . 4 80 | 55 | . ... ... | ... | . 195 55 | 40 | . 196 65 | 25 | . 197 85 | 100 | . 198 80 | 35 | . 199 50 | 45 | . 200 rows × 2 columns . - 예시3: 슬랑이싱 . df.iloc[:,0:3] # 처음 3개의 col선택, 끝점포함X #arr[:,0:3] . att rep mid . 0 65 | 45 | 0 | . 1 95 | 30 | 60 | . 2 65 | 85 | 15 | . 3 55 | 35 | 35 | . 4 80 | 60 | 55 | . ... ... | ... | ... | . 195 55 | 70 | 40 | . 196 65 | 85 | 25 | . 197 85 | 85 | 100 | . 198 80 | 65 | 35 | . 199 50 | 95 | 45 | . 200 rows × 3 columns . # row + col indexing . df.iloc[::2,0:3] . att rep mid . 0 65 | 45 | 0 | . 2 65 | 85 | 15 | . 4 80 | 60 | 55 | . 6 65 | 70 | 60 | . 8 95 | 55 | 65 | . ... ... | ... | ... | . 190 95 | 35 | 40 | . 192 100 | 40 | 80 | . 194 65 | 40 | 65 | . 196 65 | 85 | 25 | . 198 80 | 65 | 35 | . 100 rows × 3 columns . &#52968;&#49481;4: &#45936;&#51060;&#53552;&#54532;&#47112;&#51076; &#45712;&#45196; . - 컨셉4: df.loc은 새로운 느낌.. (R에 익숙하면 df.loc이 dataframe 혹은 티블느낌이라고 보시면 됩니다) . import rpy2 %load_ext rpy2.ipython . %%R library(tidyverse) mpg[1:5,c(&#39;model&#39;,&#39;year&#39;)] . # A tibble: 5 × 2 model year &lt;chr&gt; &lt;int&gt; 1 a4 1999 2 a4 1999 3 a4 2008 4 a4 2008 5 a4 1999 . # row indexing . - 예시1: 단일레이블 . df.loc[0,:] # 첫번째 row를 선택 df.loc[0,] df.loc[0] . att 65 rep 45 mid 0 fin 10 Name: 0, dtype: int64 . - 예시2: 레이블의 리스트 . df.loc[[0,1,2],:] # 처음 3개의 row를 선택 df.loc[[0,1,2],] df.loc[[0,1,2]] . att rep mid fin . 0 65 | 45 | 0 | 10 | . 1 95 | 30 | 60 | 10 | . 2 65 | 85 | 15 | 20 | . - 예시3: 슬라이싱 (끝점포함 O) . df.loc[0:3,:] # 처음 4개의 row를 선택, 끝점포함 df.loc[0:3,] df.loc[0:3] . att rep mid fin . 0 65 | 45 | 0 | 10 | . 1 95 | 30 | 60 | 10 | . 2 65 | 85 | 15 | 20 | . 3 55 | 35 | 35 | 5 | . # col indexing . - 예시1: 단일레이블 . df.loc[:,&#39;att&#39;] . 0 65 1 95 2 65 3 55 4 80 .. 195 55 196 65 197 85 198 80 199 50 Name: att, Length: 200, dtype: int64 . - 예시2: 레이블의 리스트 . df.loc[:,[&#39;att&#39;,&#39;mid&#39;]] . att mid . 0 65 | 0 | . 1 95 | 60 | . 2 65 | 15 | . 3 55 | 35 | . 4 80 | 55 | . ... ... | ... | . 195 55 | 40 | . 196 65 | 25 | . 197 85 | 100 | . 198 80 | 35 | . 199 50 | 45 | . 200 rows × 2 columns . - 예시3: 슬라이싱 (끝점포함 O) . df.loc[:,&#39;att&#39;:&#39;mid&#39;] # 끝점포함 . att rep mid . 0 65 | 45 | 0 | . 1 95 | 30 | 60 | . 2 65 | 85 | 15 | . 3 55 | 35 | 35 | . 4 80 | 60 | 55 | . ... ... | ... | ... | . 195 55 | 70 | 40 | . 196 65 | 85 | 25 | . 197 85 | 85 | 100 | . 198 80 | 65 | 35 | . 199 50 | 95 | 45 | . 200 rows × 3 columns . # row + col indexing . df.loc[::-1,&#39;att&#39;:&#39;mid&#39;] # 끝점포함 . att rep mid . 199 50 | 95 | 45 | . 198 80 | 65 | 35 | . 197 85 | 85 | 100 | . 196 65 | 85 | 25 | . 195 55 | 70 | 40 | . ... ... | ... | ... | . 4 80 | 60 | 55 | . 3 55 | 35 | 35 | . 2 65 | 85 | 15 | . 1 95 | 30 | 60 | . 0 65 | 45 | 0 | . 200 rows × 3 columns . &#52968;&#49481;1~4 &#51221;&#47532; . . [] .iloc .loc . row/단일레이블 | X | X | O | O | . col/단일레이블 | O | O | O | O | . row/레이블리스트 | X | X | O | O | . col/레이블리스트 | X | O | O | O | . row/슬라이싱 | X | O | O | O | . col/슬라이싱 | X | X | O | O | . - col 이름을 알아야하는 부담감 . . : 앞글자만 대충 알아도 자동완성 가능 | []: 정확한 col 이름을 알아야 함 | .loc: 보통 정확한 col 이름을 알아야 하지만 슬라이싱 이용시 양 끝의 컬럼이름만 알면 무방 | .iloc: 정확한 col 이름을 몰라도 번호로 인덱싱 가능 | . - 자주하는 실수 . df[&#39;att&#39;] # 가능 # df.loc[&#39;att&#39;] # 불가능 df.loc[:,&#39;att&#39;] # 가능 . 0 65 1 95 2 65 3 55 4 80 .. 195 55 196 65 197 85 198 80 199 50 Name: att, Length: 200, dtype: int64 . df: &#51064;&#45937;&#49905; 2&#45800;&#44228;-- &#54596;&#53552;&#47553;(&#53945;&#51221;&#51312;&#44148;&#50640; &#47582;&#45716; row&#47484; &#49440;&#53469;) . att &gt; 90 and rep &lt; 50 . - 방법1: .query()를 이용 . df.query(&#39;att&gt;90 and rep&lt;50&#39;) . att rep mid fin . 1 95 | 30 | 60 | 10 | . 12 95 | 35 | 0 | 25 | . 48 95 | 45 | 35 | 80 | . 56 95 | 25 | 95 | 90 | . 78 95 | 45 | 90 | 35 | . 107 100 | 30 | 60 | 65 | . 112 100 | 35 | 70 | 0 | . 113 95 | 45 | 55 | 65 | . 163 100 | 25 | 10 | 20 | . 174 100 | 40 | 40 | 15 | . 176 100 | 30 | 70 | 70 | . 184 100 | 30 | 30 | 85 | . 190 95 | 35 | 40 | 95 | . 192 100 | 40 | 80 | 80 | . df.query(&#39;(att&gt;90)&amp;(rep&lt;50)&#39;) . att rep mid fin . 1 95 | 30 | 60 | 10 | . 12 95 | 35 | 0 | 25 | . 48 95 | 45 | 35 | 80 | . 56 95 | 25 | 95 | 90 | . 78 95 | 45 | 90 | 35 | . 107 100 | 30 | 60 | 65 | . 112 100 | 35 | 70 | 0 | . 113 95 | 45 | 55 | 65 | . 163 100 | 25 | 10 | 20 | . 174 100 | 40 | 40 | 15 | . 176 100 | 30 | 70 | 70 | . 184 100 | 30 | 30 | 85 | . 190 95 | 35 | 40 | 95 | . 192 100 | 40 | 80 | 80 | . df.query(&#39;att&gt;90 &amp; rep&lt;50&#39;) . att rep mid fin . 1 95 | 30 | 60 | 10 | . 12 95 | 35 | 0 | 25 | . 48 95 | 45 | 35 | 80 | . 56 95 | 25 | 95 | 90 | . 78 95 | 45 | 90 | 35 | . 107 100 | 30 | 60 | 65 | . 112 100 | 35 | 70 | 0 | . 113 95 | 45 | 55 | 65 | . 163 100 | 25 | 10 | 20 | . 174 100 | 40 | 40 | 15 | . 176 100 | 30 | 70 | 70 | . 184 100 | 30 | 30 | 85 | . 190 95 | 35 | 40 | 95 | . 192 100 | 40 | 80 | 80 | . - 방법2: [], .iloc, .loc . df[(df.att &gt; 90)&amp;(df.rep &lt; 50)] df.loc[(df.att &gt; 90)&amp;(df.rep &lt; 50)] df.iloc[list((df.att &gt; 90)&amp;(df.rep &lt; 50))] . att rep mid fin . 1 95 | 30 | 60 | 10 | . 12 95 | 35 | 0 | 25 | . 48 95 | 45 | 35 | 80 | . 56 95 | 25 | 95 | 90 | . 78 95 | 45 | 90 | 35 | . 107 100 | 30 | 60 | 65 | . 112 100 | 35 | 70 | 0 | . 113 95 | 45 | 55 | 65 | . 163 100 | 25 | 10 | 20 | . 174 100 | 40 | 40 | 15 | . 176 100 | 30 | 70 | 70 | . 184 100 | 30 | 30 | 85 | . 190 95 | 35 | 40 | 95 | . 192 100 | 40 | 80 | 80 | . - 방법3: [], .iloc, .loc // map, lambda . df[list(map(lambda x,y: (x&gt;90)&amp;(y&lt;50), df.att, df.rep))] # df[map(lambda x,y: (x&gt;90)&amp;(y&lt;50), df.att, df.rep)] # 이것은 불가능 . att rep mid fin . 1 95 | 30 | 60 | 10 | . 12 95 | 35 | 0 | 25 | . 48 95 | 45 | 35 | 80 | . 56 95 | 25 | 95 | 90 | . 78 95 | 45 | 90 | 35 | . 107 100 | 30 | 60 | 65 | . 112 100 | 35 | 70 | 0 | . 113 95 | 45 | 55 | 65 | . 163 100 | 25 | 10 | 20 | . 174 100 | 40 | 40 | 15 | . 176 100 | 30 | 70 | 70 | . 184 100 | 30 | 30 | 85 | . 190 95 | 35 | 40 | 95 | . 192 100 | 40 | 80 | 80 | . df.iloc[list(map(lambda x,y: (x&gt;90)&amp;(y&lt;50), df.att, df.rep))] df.iloc[map(lambda x,y: (x&gt;90)&amp;(y&lt;50), df.att, df.rep)] . att rep mid fin . 1 95 | 30 | 60 | 10 | . 12 95 | 35 | 0 | 25 | . 48 95 | 45 | 35 | 80 | . 56 95 | 25 | 95 | 90 | . 78 95 | 45 | 90 | 35 | . 107 100 | 30 | 60 | 65 | . 112 100 | 35 | 70 | 0 | . 113 95 | 45 | 55 | 65 | . 163 100 | 25 | 10 | 20 | . 174 100 | 40 | 40 | 15 | . 176 100 | 30 | 70 | 70 | . 184 100 | 30 | 30 | 85 | . 190 95 | 35 | 40 | 95 | . 192 100 | 40 | 80 | 80 | . df.loc[list(map(lambda x,y: (x&gt;90)&amp;(y&lt;50), df.att, df.rep))] df.loc[map(lambda x,y: (x&gt;90)&amp;(y&lt;50), df.att, df.rep)] . att rep mid fin . 1 95 | 30 | 60 | 10 | . 12 95 | 35 | 0 | 25 | . 48 95 | 45 | 35 | 80 | . 56 95 | 25 | 95 | 90 | . 78 95 | 45 | 90 | 35 | . 107 100 | 30 | 60 | 65 | . 112 100 | 35 | 70 | 0 | . 113 95 | 45 | 55 | 65 | . 163 100 | 25 | 10 | 20 | . 174 100 | 40 | 40 | 15 | . 176 100 | 30 | 70 | 70 | . 184 100 | 30 | 30 | 85 | . 190 95 | 35 | 40 | 95 | . 192 100 | 40 | 80 | 80 | . att &gt; mean(att) . - 방법1: .query()를 이용 . df.query(&#39;att&gt; att.mean()&#39;) . att rep mid fin . 1 95 | 30 | 60 | 10 | . 4 80 | 60 | 55 | 70 | . 8 95 | 55 | 65 | 90 | . 9 90 | 25 | 95 | 50 | . 11 95 | 60 | 25 | 55 | . ... ... | ... | ... | ... | . 184 100 | 30 | 30 | 85 | . 190 95 | 35 | 40 | 95 | . 192 100 | 40 | 80 | 80 | . 197 85 | 85 | 100 | 10 | . 198 80 | 65 | 35 | 60 | . 95 rows × 4 columns . - 방법2: [], .iloc, .loc . df[df.att &gt; df.att.mean()] df.loc[df.att &gt; df.att.mean()] df.iloc[list(df.att &gt; df.att.mean())] . att rep mid fin . 1 95 | 30 | 60 | 10 | . 4 80 | 60 | 55 | 70 | . 8 95 | 55 | 65 | 90 | . 9 90 | 25 | 95 | 50 | . 11 95 | 60 | 25 | 55 | . ... ... | ... | ... | ... | . 184 100 | 30 | 30 | 85 | . 190 95 | 35 | 40 | 95 | . 192 100 | 40 | 80 | 80 | . 197 85 | 85 | 100 | 10 | . 198 80 | 65 | 35 | 60 | . 95 rows × 4 columns . - 방법3: [], .iloc, .loc // map, lambda . df[list(map(lambda x: x&gt;df.att.mean() , df.att))] # df[map(lambda x: x&gt;df.att.mean() , df.att)] # 이것은 불가능 . att rep mid fin . 1 95 | 30 | 60 | 10 | . 4 80 | 60 | 55 | 70 | . 8 95 | 55 | 65 | 90 | . 9 90 | 25 | 95 | 50 | . 11 95 | 60 | 25 | 55 | . ... ... | ... | ... | ... | . 184 100 | 30 | 30 | 85 | . 190 95 | 35 | 40 | 95 | . 192 100 | 40 | 80 | 80 | . 197 85 | 85 | 100 | 10 | . 198 80 | 65 | 35 | 60 | . 95 rows × 4 columns . df.iloc[list(map(lambda x: x&gt;df.att.mean() , df.att))] df.iloc[map(lambda x: x&gt;df.att.mean() , df.att)] . att rep mid fin . 1 95 | 30 | 60 | 10 | . 4 80 | 60 | 55 | 70 | . 8 95 | 55 | 65 | 90 | . 9 90 | 25 | 95 | 50 | . 11 95 | 60 | 25 | 55 | . ... ... | ... | ... | ... | . 184 100 | 30 | 30 | 85 | . 190 95 | 35 | 40 | 95 | . 192 100 | 40 | 80 | 80 | . 197 85 | 85 | 100 | 10 | . 198 80 | 65 | 35 | 60 | . 95 rows × 4 columns . df.loc[list(map(lambda x: x&gt;df.att.mean() , df.att))] df.loc[map(lambda x: x&gt;df.att.mean() , df.att)] . att rep mid fin . 1 95 | 30 | 60 | 10 | . 4 80 | 60 | 55 | 70 | . 8 95 | 55 | 65 | 90 | . 9 90 | 25 | 95 | 50 | . 11 95 | 60 | 25 | 55 | . ... ... | ... | ... | ... | . 184 100 | 30 | 30 | 85 | . 190 95 | 35 | 40 | 95 | . 192 100 | 40 | 80 | 80 | . 197 85 | 85 | 100 | 10 | . 198 80 | 65 | 35 | 60 | . 95 rows × 4 columns . . [] .iloc .loc . row/단일레이블 | X | X | O | O | . col/단일레이블 | O | O | O | O | . row/레이블리스트 | X | X | O | O | . col/레이블리스트 | X | O | O | O | . row/슬라이싱 | X | O | O | O | . col/슬라이싱 | X | X | O | O | . row/bool,list | X | O | O | O | . row/bool,ser | X | O | X | O | . row/bool,map | X | X | O | O | . &#49689;&#51228; . 1. 10&#50900;12&#51068; &#49689;&#51228; . 아래와 같이 0~9까지 포함된 리스트를 만들어라 . x=list(range(10)) x . [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] . 아래와 동일한 기능을 수행하는 함수를 lambda expression으로 정의하라. . def f(xi): return &#39;짝&#39; if (xi % 2)==0 else &#39;홀&#39; . map과 lambda expression 을 이용하여 아래와 같은 결과를 만들어라. (리스트컴프리헨션, for문 사용금지) . # 구현예시 . [&#39;짝&#39;, &#39;홀&#39;, &#39;짝&#39;, &#39;홀&#39;, &#39;짝&#39;, &#39;홀&#39;, &#39;짝&#39;, &#39;홀&#39;, &#39;짝&#39;, &#39;홀&#39;] . 2. 10&#50900;14&#51068; &#49689;&#51228; . 다음과 같은 데이터프레임을 불러온 뒤 물음에 답하라 . df=pd.read_csv(&#39;https://raw.githubusercontent.com/guebin/DV2022/master/_notebooks/dv2022.csv&#39;) df . att rep mid fin . 0 65 | 45 | 0 | 10 | . 1 95 | 30 | 60 | 10 | . 2 65 | 85 | 15 | 20 | . 3 55 | 35 | 35 | 5 | . 4 80 | 60 | 55 | 70 | . ... ... | ... | ... | ... | . 195 55 | 70 | 40 | 95 | . 196 65 | 85 | 25 | 85 | . 197 85 | 85 | 100 | 10 | . 198 80 | 65 | 35 | 60 | . 199 50 | 95 | 45 | 85 | . 200 rows × 4 columns . (1) 기말고사 성적이 중간고사 성적보다 향상된 학생들을 출력하라. 즉 mid &lt; fin 인 학생들을 출력하라. (다양한 방법으로 연습할 것, 제출은 한 가지 방법으로 구현해도 감점없음) . # 구현결과가 아래와 같아야 한다. . att rep mid fin . 0 65 | 45 | 0 | 10 | . 2 65 | 85 | 15 | 20 | . 4 80 | 60 | 55 | 70 | . 5 75 | 40 | 75 | 85 | . 6 65 | 70 | 60 | 75 | . ... ... | ... | ... | ... | . 194 65 | 40 | 65 | 70 | . 195 55 | 70 | 40 | 95 | . 196 65 | 85 | 25 | 85 | . 198 80 | 65 | 35 | 60 | . 199 50 | 95 | 45 | 85 | . 93 rows × 4 columns . (2) 기말고사 성적이 중간고사 성적보다 향상된 학생들의 출석과 레포트 점수를 출력하라. . # 구현결과가 아래와 같아야 한다. . att rep . 0 65 | 45 | . 2 65 | 85 | . 4 80 | 60 | . 5 75 | 40 | . 6 65 | 70 | . ... ... | ... | . 194 65 | 40 | . 195 55 | 70 | . 196 65 | 85 | . 198 80 | 65 | . 199 50 | 95 | . 93 rows × 2 columns .",
            "url": "https://guebin.github.io/DV2022/2022/10/12/(6%EC%A3%BC%EC%B0%A8)-10%EC%9B%9412%EC%9D%BC.html",
            "relUrl": "/2022/10/12/(6%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1)-10%E1%84%8B%E1%85%AF%E1%86%AF12%E1%84%8B%E1%85%B5%E1%86%AF.html",
            "date": " • Oct 12, 2022"
        }
        
    
  
    
        ,"post5": {
            "title": "(5주차) 10월6일 -- 10월3일 강의에 대한 보충",
            "content": "&#44053;&#51032;&#50689;&#49345; . . imports . import numpy as np import pandas as pd import matplotlib.pyplot as plt import seaborn as sns from plotnine import * . &#54988;&#47469;&#54620; &#49884;&#44033;&#54868;&#46976;? . &#50528;&#46300;&#50892;&#46300; &#53552;&#54532;&#54000; . - 데이터 시각화계의 거장 . - 터프티의 이론중 백미: 엄격한 미니멀리즘 . 최소한의 잉크로 많은 정보를 전달할 수 있다면 그것이 바로 좋은 그래프이다. | 작은 지면 내에서 잉크를 최대한 적게 써서 짧은 시간 안에 많은 영감을 주어야 한다. | . - 데이터-잉크비: 데이터를 표현하는데 들아가는 잉크의 양 / 그래픽을 인쇄하는데 들어가는 잉크의 총량 . - 차트정크 (나이젤홈즈의 그래프) . . “Lurking behind chartjunk is contempt both for information and for the audience. Chartjunk promoters imagine that numbers and details are boring, dull, and tedious, requiring ornament to enliven. Cosmetic decoration, which frequently distorts the data, will never salvage an underlying lack of content. If the numbers are boring, then you’ve got the wrong numbers (...) Worse is contempt for our audience, designing as if readers were obtuse and uncaring. In fact, consumers of graphics are often more intelligent about the information at hand than those who fabricate the data decoration (...) The operating moral premise of information design should be that our readers are alert and caring; they may be busy, eager to get on with it, but they are not stupid.” . 차트정크 = 대중을 멸시 + 데이터에 대한 모독 | 차트정크 옹호가는 숫자와 데이터가 지루하여 활기가 필요하다고 생각하는 모양이다.. | . - 별로인 그래프 (왼쪽) / 우수한 그래프 오른쪽 . . - 별로인 그래프 (왼쪽) / 우수한 그래프 오른쪽 . . - 별로인 그래프 (왼쪽) / 우수한 그래프 오른쪽 . . - 제 생각: 글쎄... . &#52272;&#49828;&#48120;&#45208;&#46300;&#51032; &#46020;&#54364; . 인류역사상 가장 훌륭한 시각화 | . . - 터프티의 평 . 지금까지 그려진 최고의 통계 그래픽일지도 모른다. | 여기에서는 군대의 크기, 2차원 평면상의 위치, 군대의 이동방향, 모스코바에서 퇴각하는 동안의 여러날짜, 온도 $ to$ 6차원의 변수 | 백만번에 한번 이런 그림을 그릴수는 있겠지만 이러한 멋진 그래픽을 만드는 방법에 대한 원칙은 없다. $ to$ 미니멀리즘.. | . - 왜 우수한 그래프일까? . 자료를 파악하는 기법은 최근까지도 산점도, 막대그래프, 라인플랏에 의존 | 이러한 플랏의 단점은 고차원의 자료를 분석하기 어렵다는 것임 | 미나드는 여러그램을 그리는 방법 대신에 한 그림에서 패널을 늘리는 방법을 선택함. | . &#48120;&#45208;&#46300;&#52376;&#47100; &#44536;&#47532;&#45716;&#44172; &#50780; &#50612;&#47140;&#50868;&#44032;? . - 몸무게, 키, 성별, 국적 . df1=pd.read_csv(&#39;https://raw.githubusercontent.com/guebin/DV2022/master/_notebooks/male1.csv&#39;) df2=pd.read_csv(&#39;https://raw.githubusercontent.com/guebin/DV2022/master/_notebooks/male2.csv&#39;) df3=pd.read_csv(&#39;https://raw.githubusercontent.com/guebin/DV2022/master/_notebooks/female.csv&#39;) df4=pd.read_csv(&#39;https://raw.githubusercontent.com/guebin/DV2022/master/_notebooks/foreign.csv&#39;) . - 미나드의 접근방법 . _df = pd.concat([pd.concat([df1,df2],axis=1).assign(g=&#39;m&#39;),df3.assign(g=&#39;f&#39;)]) df = pd.concat([_df.assign(g2=&#39;korea&#39;),df4.assign(g2=&#39;foreign&#39;)]).reset_index(drop=True) df . w h g g2 . 0 72.788217 | 183.486773 | m | korea | . 1 66.606430 | 173.599877 | m | korea | . 2 69.806324 | 173.237903 | m | korea | . 3 67.449439 | 173.223805 | m | korea | . 4 70.463183 | 174.931946 | m | korea | . ... ... | ... | ... | ... | . 1525 78.154632 | 188.324350 | m | foreign | . 1526 74.754308 | 183.017979 | f | foreign | . 1527 91.196208 | 190.100456 | m | foreign | . 1528 87.770394 | 187.987255 | m | foreign | . 1529 88.021995 | 193.456798 | m | foreign | . 1530 rows × 4 columns . sns.scatterplot(data=df,x=&#39;w&#39;,y=&#39;h&#39;,hue=&#39;g&#39;,style=&#39;g2&#39;) . &lt;AxesSubplot:xlabel=&#39;w&#39;, ylabel=&#39;h&#39;&gt; . - 어려운점: (1) 센스가 없어서 hue/style을 이용하여 그룹을 구분할 생각을 못함 (2) long df (=tidy data) 형태로 데이터를 정리할 생각을 못함 (3) long df 형태로 데이터를 변형하는 코드를 모름 . (1) 기획력부족 -&gt; 훌륭한 시각화를 많이 볼 것 | (2) 데이터프레임에 대한 이해부족 -&gt; tidydata에 대한 개념 | (3) 프로그래밍 능력 -&gt; 코딩공부열심히 (pandas를 엄청 잘해야함) | . read mpg data . - ref: https://r4ds.had.co.nz/index.html . &#48169;&#48277;1: rpy2 (&#53076;&#47017; &#50500;&#45772;&#44221;&#50864; &#49892;&#49845;&#44552;&#51648;) . import rpy2 %load_ext rpy2.ipython . %%R ### 여기는 R처럼 쓸 수 있다. a &lt;- c(1,2,3) a+1 . [1] 2 3 4 . a . NameError Traceback (most recent call last) /tmp/ipykernel_1214567/2167009006.py in &lt;module&gt; -&gt; 1 a NameError: name &#39;a&#39; is not defined . %%R library(tidyverse) mpg . # A tibble: 234 × 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 audi a4 1.8 1999 4 auto… f 18 29 p comp… 2 audi a4 1.8 1999 4 manu… f 21 29 p comp… 3 audi a4 2 2008 4 manu… f 20 31 p comp… 4 audi a4 2 2008 4 auto… f 21 30 p comp… 5 audi a4 2.8 1999 6 auto… f 16 26 p comp… 6 audi a4 2.8 1999 6 manu… f 18 26 p comp… 7 audi a4 3.1 2008 6 auto… f 18 27 p comp… 8 audi a4 quattro 1.8 1999 4 manu… 4 18 26 p comp… 9 audi a4 quattro 1.8 1999 4 auto… 4 16 25 p comp… 10 audi a4 quattro 2 2008 4 manu… 4 20 28 p comp… # … with 224 more rows # ℹ Use `print(n = ...)` to see more rows . mpg . NameError Traceback (most recent call last) /tmp/ipykernel_1214567/602803287.py in &lt;module&gt; -&gt; 1 mpg NameError: name &#39;mpg&#39; is not defined . %R -o mpg # R에 있는 자료가 파이썬으로 넘어옴 . mpg . manufacturer model displ year cyl trans drv cty hwy fl class . 1 audi | a4 | 1.8 | 1999 | 4 | auto(l5) | f | 18 | 29 | p | compact | . 2 audi | a4 | 1.8 | 1999 | 4 | manual(m5) | f | 21 | 29 | p | compact | . 3 audi | a4 | 2.0 | 2008 | 4 | manual(m6) | f | 20 | 31 | p | compact | . 4 audi | a4 | 2.0 | 2008 | 4 | auto(av) | f | 21 | 30 | p | compact | . 5 audi | a4 | 2.8 | 1999 | 6 | auto(l5) | f | 16 | 26 | p | compact | . ... ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | . 230 volkswagen | passat | 2.0 | 2008 | 4 | auto(s6) | f | 19 | 28 | p | midsize | . 231 volkswagen | passat | 2.0 | 2008 | 4 | manual(m6) | f | 21 | 29 | p | midsize | . 232 volkswagen | passat | 2.8 | 1999 | 6 | auto(l5) | f | 16 | 26 | p | midsize | . 233 volkswagen | passat | 2.8 | 1999 | 6 | manual(m5) | f | 18 | 26 | p | midsize | . 234 volkswagen | passat | 3.6 | 2008 | 6 | auto(s6) | f | 17 | 26 | p | midsize | . 234 rows × 11 columns . &#48169;&#48277;2: &#51200;&#51109;&#46108; csv&#54028;&#51068;&#51012; &#53685;&#54616;&#50668; &#45936;&#51060;&#53552;&#47484; &#54869;&#48372; . mpg.to_csv(&quot;mpg.csv&quot;,index=False) . pd.read_csv(&quot;mpg.csv&quot;) . manufacturer model displ year cyl trans drv cty hwy fl class . 0 audi | a4 | 1.8 | 1999 | 4 | auto(l5) | f | 18 | 29 | p | compact | . 1 audi | a4 | 1.8 | 1999 | 4 | manual(m5) | f | 21 | 29 | p | compact | . 2 audi | a4 | 2.0 | 2008 | 4 | manual(m6) | f | 20 | 31 | p | compact | . 3 audi | a4 | 2.0 | 2008 | 4 | auto(av) | f | 21 | 30 | p | compact | . 4 audi | a4 | 2.8 | 1999 | 6 | auto(l5) | f | 16 | 26 | p | compact | . ... ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | . 229 volkswagen | passat | 2.0 | 2008 | 4 | auto(s6) | f | 19 | 28 | p | midsize | . 230 volkswagen | passat | 2.0 | 2008 | 4 | manual(m6) | f | 21 | 29 | p | midsize | . 231 volkswagen | passat | 2.8 | 1999 | 6 | auto(l5) | f | 16 | 26 | p | midsize | . 232 volkswagen | passat | 2.8 | 1999 | 6 | manual(m5) | f | 18 | 26 | p | midsize | . 233 volkswagen | passat | 3.6 | 2008 | 6 | auto(s6) | f | 17 | 26 | p | midsize | . 234 rows × 11 columns . &#48169;&#48277;3: github&#46321;&#50640; &#44277;&#44060;&#46108; csv&#47484; &#51069;&#50612;&#50724;&#44592; . pd.read_csv(&#39;https://raw.githubusercontent.com/guebin/DV2022/master/_notebooks/mpg.csv&#39;) . manufacturer model displ year cyl trans drv cty hwy fl class . 0 audi | a4 | 1.8 | 1999 | 4 | auto(l5) | f | 18 | 29 | p | compact | . 1 audi | a4 | 1.8 | 1999 | 4 | manual(m5) | f | 21 | 29 | p | compact | . 2 audi | a4 | 2.0 | 2008 | 4 | manual(m6) | f | 20 | 31 | p | compact | . 3 audi | a4 | 2.0 | 2008 | 4 | auto(av) | f | 21 | 30 | p | compact | . 4 audi | a4 | 2.8 | 1999 | 6 | auto(l5) | f | 16 | 26 | p | compact | . ... ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | . 229 volkswagen | passat | 2.0 | 2008 | 4 | auto(s6) | f | 19 | 28 | p | midsize | . 230 volkswagen | passat | 2.0 | 2008 | 4 | manual(m6) | f | 21 | 29 | p | midsize | . 231 volkswagen | passat | 2.8 | 1999 | 6 | auto(l5) | f | 16 | 26 | p | midsize | . 232 volkswagen | passat | 2.8 | 1999 | 6 | manual(m5) | f | 18 | 26 | p | midsize | . 233 volkswagen | passat | 3.6 | 2008 | 6 | auto(s6) | f | 17 | 26 | p | midsize | . 234 rows × 11 columns . - 깃허브 저장소에 아예 데이터만 따로 모아서 관리하는 것도 좋은 방법입니다. . data &#49444;&#47749; . - displ: 자동차의 엔진크기 . - hwy: 연료의 효율, 동일한 연료로 얼마나 멀리 가느냐? . - 자세한 설명은 R에서 ?mpg를 이용해 스스로 찾아볼 것 . p9&#47484; &#51060;&#50857;&#54620; &#49328;&#51216;&#46020; (2&#52264;&#50896;) . python&#50640;&#49436;: plotnine&#51012; &#51060;&#50857;&#54620; &#49328;&#51216;&#46020; . ggplot(data=mpg) + geom_point(mapping=aes(x=&#39;displ&#39;,y=&#39;hwy&#39;)) ## plotnine . &lt;ggplot: (8726736046009)&gt; . 산점도 해석: 엔진크기가 클수록 효율이 낮음. | . - 빠르게 그리기: data=와 mapping=은 생략가능함 . ggplot(mpg) + geom_point(aes(x=&#39;displ&#39;,y=&#39;hwy&#39;)) ## plotnine . &lt;ggplot: (8726735544581)&gt; . R&#50640;&#49436;: ggplot2&#47484; &#51060;&#50857;&#54620; &#49328;&#51216;&#46020; . - R에서도 거의 똑같은 문법으로 그릴 수 있음 (데이터프레임 혹은 티블에 저장된 column 이름을 사용할때 따옴표만 제거하면 된다!) . %%R -w 800 ggplot(mpg) + geom_point(aes(x=displ,y=hwy)) ## plotnine . python&#50640;&#49436;: &#44061;&#52404;&#51648;&#54693;&#51201;&#51064; &#45712;&#45196;&#51004;&#47196; &#49328;&#51216;&#46020; &#44536;&#47532;&#44592; . step1: 도화지를 준비한다. . fig = ggplot(data=mpg) fig . &lt;ggplot: (8726735085529)&gt; . step2 변수와 에스테틱사이의 맵핑을 설정한다. . a1= aes(x=&#39;displ&#39;,y=&#39;hwy&#39;) a1 . {&#39;x&#39;: &#39;displ&#39;, &#39;y&#39;: &#39;hwy&#39;} . step3 점들의 집합을 만든다. 즉 포인트 지옴을 만든다. . point1=geom_point(mapping=a1) . geom_point(): 점들을 그려! 어떻게? | a1에서 설정된 표를 보고 | . step4 도화지와 지옴을 합친다. . fig+point1 . &lt;ggplot: (8726775447877)&gt; . p9&#47484; &#51060;&#50857;&#54620; &#49328;&#51216;&#46020; (3&#52264;&#50896;) . - 데이터를 다시 관찰 . mpg.head() . manufacturer model displ year cyl trans drv cty hwy fl class . 1 audi | a4 | 1.8 | 1999 | 4 | auto(l5) | f | 18 | 29 | p | compact | . 2 audi | a4 | 1.8 | 1999 | 4 | manual(m5) | f | 21 | 29 | p | compact | . 3 audi | a4 | 2.0 | 2008 | 4 | manual(m6) | f | 20 | 31 | p | compact | . 4 audi | a4 | 2.0 | 2008 | 4 | auto(av) | f | 21 | 30 | p | compact | . 5 audi | a4 | 2.8 | 1999 | 6 | auto(l5) | f | 16 | 26 | p | compact | . - class도 함께 plot에 표시하면 데이터를 탐색할때 좀 더 좋을 것 같다. . &#49328;&#51216;&#46020; + &#51216;&#53356;&#44592;&#48320;&#44221; . ggplot(data=mpg) + geom_point(mapping = aes(x=&#39;displ&#39;,y=&#39;hwy&#39;,size=&#39;class&#39;)) . /home/cgb4/anaconda3/envs/py37/lib/python3.7/site-packages/plotnine/scales/scale_size.py:50: PlotnineWarning: Using size for a discrete variable is not advised. . &lt;ggplot: (8726734563561)&gt; . &#49328;&#51216;&#46020; + &#53804;&#47749;&#46020;&#48320;&#44221; . ggplot(data=mpg) + geom_point(mapping = aes(x=&#39;displ&#39;,y=&#39;hwy&#39;,alpha=&#39;class&#39;)) . /home/cgb4/anaconda3/envs/py37/lib/python3.7/site-packages/plotnine/scales/scale_alpha.py:70: PlotnineWarning: Using alpha for a discrete variable is not advised. . &lt;ggplot: (8726734989121)&gt; . &#49328;&#51216;&#46020; + &#53804;&#47749;&#46020;/&#51216;&#53356;&#44592;&#47484; &#46041;&#49884;&#50640; &#51201;&#50857; . ggplot(data=mpg) + geom_point(mapping = aes(x=&#39;displ&#39;,y=&#39;hwy&#39;,alpha=&#39;class&#39;,size=&#39;class&#39;)) . /home/cgb4/anaconda3/envs/py37/lib/python3.7/site-packages/plotnine/scales/scale_alpha.py:70: PlotnineWarning: Using alpha for a discrete variable is not advised. /home/cgb4/anaconda3/envs/py37/lib/python3.7/site-packages/plotnine/scales/scale_size.py:50: PlotnineWarning: Using size for a discrete variable is not advised. . &lt;ggplot: (8726734522405)&gt; . &#49328;&#51216;&#46020; + &#54805;&#53468; . ggplot(data=mpg) + geom_point(mapping = aes(x=&#39;displ&#39;,y=&#39;hwy&#39;,shape=&#39;class&#39;)) . &lt;ggplot: (8726734265229)&gt; . &#49328;&#51216;&#46020; + &#49353;&#44628; . ggplot(data=mpg) + geom_point(mapping = aes(x=&#39;displ&#39;,y=&#39;hwy&#39;,color=&#39;class&#39;)) . &lt;ggplot: (8726734017473)&gt; . &#44061;&#52404;&#51648;&#54693;&#51201; &#45712;&#45196;&#51004;&#47196;? . a2 = aes(x=&#39;displ&#39;, y=&#39;hwy&#39;, color=&#39;class&#39;) . a1,a2 . ({&#39;x&#39;: &#39;displ&#39;, &#39;y&#39;: &#39;hwy&#39;}, {&#39;x&#39;: &#39;displ&#39;, &#39;y&#39;: &#39;hwy&#39;, &#39;color&#39;: &#39;class&#39;}) . point2=geom_point(a2) . fig+point2 . &lt;ggplot: (8726733712885)&gt; . &#49328;&#51216;&#46020; + &#49353;&#44628; + &#51201;&#54633;&#49440; . - 일단 색깔이 없는 포인트 지옴부터 연습 . fig+point1 . &lt;ggplot: (8726733452617)&gt; . line1 = geom_smooth(a1) . fig+point1+line1 . /home/cgb4/anaconda3/envs/py37/lib/python3.7/site-packages/plotnine/stats/smoothers.py:311: PlotnineWarning: Confidence intervals are not yet implementedfor lowess smoothings. . &lt;ggplot: (8726732994973)&gt; . - point1(색깔없는 포인트 지옴)을 point2(색깔있는 포인트 지옴)으로 언제든지 바꿔치기 가능! . fig+point2+line1 . /home/cgb4/anaconda3/envs/py37/lib/python3.7/site-packages/plotnine/stats/smoothers.py:311: PlotnineWarning: Confidence intervals are not yet implementedfor lowess smoothings. . &lt;ggplot: (8726732661565)&gt; . - 명령어로 한번에 그리기 . ggplot(data=mpg) + geom_point(mapping=aes(x=&#39;displ&#39;,y=&#39;hwy&#39;,color=&#39;class&#39;)) + geom_smooth(mapping=aes(x=&#39;displ&#39;,y=&#39;hwy&#39;)) . /home/cgb4/anaconda3/envs/py37/lib/python3.7/site-packages/plotnine/stats/smoothers.py:311: PlotnineWarning: Confidence intervals are not yet implementedfor lowess smoothings. . &lt;ggplot: (8726732727485)&gt; . - 공통적인 맵핑규칙은 ggplot()쪽으로 빼기도 한다. (figure를 선언하는 곳에서 공통으로 선언함) . ggplot(data=mpg,mapping=aes(x=&#39;displ&#39;,y=&#39;hwy&#39;)) + geom_point(mapping=aes(color=&#39;class&#39;)) + geom_smooth() . /home/cgb4/anaconda3/envs/py37/lib/python3.7/site-packages/plotnine/stats/smoothers.py:311: PlotnineWarning: Confidence intervals are not yet implementedfor lowess smoothings. . &lt;ggplot: (8726733489953)&gt; . - R에서는 confidence interval도 geom_smooth()를 이용하여 확인할 수 있다. . %%R -w 800 ggplot(data=mpg,mapping=aes(x=displ,y=hwy)) + geom_point(mapping=aes(color=class)) + geom_smooth() . R[write to console]: `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; . p9&#47484; &#51060;&#50857;&#54620; &#49328;&#51216;&#46020; (4&#52264;&#50896;) . - 데이터를 살펴보자. . mpg.head() . manufacturer model displ year cyl trans drv cty hwy fl class . 1 audi | a4 | 1.8 | 1999 | 4 | auto(l5) | f | 18 | 29 | p | compact | . 2 audi | a4 | 1.8 | 1999 | 4 | manual(m5) | f | 21 | 29 | p | compact | . 3 audi | a4 | 2.0 | 2008 | 4 | manual(m6) | f | 20 | 31 | p | compact | . 4 audi | a4 | 2.0 | 2008 | 4 | auto(av) | f | 21 | 30 | p | compact | . 5 audi | a4 | 2.8 | 1999 | 6 | auto(l5) | f | 16 | 26 | p | compact | . &#49328;&#51216;&#46020; + &#51216;&#53356;&#44592;&#48320;&#44221; + &#49353;&#44628; . - drv (전륜, 후륜, 4륜 구동)에 따라서 데이터를 시각화 하고 싶다. . ggplot(data=mpg, mapping=aes(x=&#39;displ&#39;,y=&#39;hwy&#39;)) + geom_point(mapping=aes(size=&#39;class&#39;,color=&#39;drv&#39;),alpha=0.3) . /home/cgb4/anaconda3/envs/py37/lib/python3.7/site-packages/plotnine/scales/scale_size.py:50: PlotnineWarning: Using size for a discrete variable is not advised. . &lt;ggplot: (8726731152845)&gt; . 모든 $x$에 대하여 붉은색 점들이 대부분 초록색과 보라색 점들에 비하여 아래쪽에 있음 $ to$ 4륜구동방식이 연비가 좋지 않음 | . &#49328;&#51216;&#46020; + &#51216;&#53356;&#44592;&#48320;&#44221; + &#49353;&#44628; (&#44061;&#52404;&#51648;&#54693;&#48260;&#51204;) . - 맵핑규칙 . a1,a2 . ({&#39;x&#39;: &#39;displ&#39;, &#39;y&#39;: &#39;hwy&#39;}, {&#39;x&#39;: &#39;displ&#39;, &#39;y&#39;: &#39;hwy&#39;, &#39;color&#39;: &#39;class&#39;}) . a3 = a2.copy() . a3[&#39;color&#39;] = &#39;drv&#39; a3[&#39;size&#39;] = &#39;class&#39; a3 . {&#39;x&#39;: &#39;displ&#39;, &#39;y&#39;: &#39;hwy&#39;, &#39;color&#39;: &#39;drv&#39;, &#39;size&#39;: &#39;class&#39;} . 아래와 같이 선언해도 괜찮음 a3= aes(x=&#39;displ&#39;,y=&#39;hwy&#39;,color=&#39;drv&#39;,size=&#39;class&#39;) . | . point3=geom_point(a3) . fig+point3 . /home/cgb4/anaconda3/envs/py37/lib/python3.7/site-packages/plotnine/scales/scale_size.py:50: PlotnineWarning: Using size for a discrete variable is not advised. . &lt;ggplot: (8726731065581)&gt; . 그림의 전체적인 투명도를 조절하면 좋겠음 | . point3=geom_point(a3,alpha=0.2) fig+point3 . /home/cgb4/anaconda3/envs/py37/lib/python3.7/site-packages/plotnine/scales/scale_size.py:50: PlotnineWarning: Using size for a discrete variable is not advised. . &lt;ggplot: (8726730819657)&gt; . &#49328;&#51216;&#46020; + &#51216;&#53356;&#44592;&#48320;&#44221; + &#49353;&#44628; + &#49440;&#52628;&#44032; . fig+point3+line1 . /home/cgb4/anaconda3/envs/py37/lib/python3.7/site-packages/plotnine/scales/scale_size.py:50: PlotnineWarning: Using size for a discrete variable is not advised. /home/cgb4/anaconda3/envs/py37/lib/python3.7/site-packages/plotnine/stats/smoothers.py:311: PlotnineWarning: Confidence intervals are not yet implementedfor lowess smoothings. . &lt;ggplot: (8726730575253)&gt; . &#49328;&#51216;&#46020; + &#51216;&#53356;&#44592;&#48320;&#44221; + &#49353;&#44628; + drv&#48324;&#47196; &#49440;&#52628;&#44032; . - 맵핑규칙 . a1,a2,a3 . ({&#39;x&#39;: &#39;displ&#39;, &#39;y&#39;: &#39;hwy&#39;}, {&#39;x&#39;: &#39;displ&#39;, &#39;y&#39;: &#39;hwy&#39;, &#39;color&#39;: &#39;class&#39;}, {&#39;x&#39;: &#39;displ&#39;, &#39;y&#39;: &#39;hwy&#39;, &#39;color&#39;: &#39;drv&#39;, &#39;size&#39;: &#39;class&#39;}) . a4 = a2.copy() a4[&#39;color&#39;]=&#39;drv&#39; a4 . {&#39;x&#39;: &#39;displ&#39;, &#39;y&#39;: &#39;hwy&#39;, &#39;color&#39;: &#39;drv&#39;} . line2 = geom_smooth(a4) . fig + point3 +line2 . /home/cgb4/anaconda3/envs/py37/lib/python3.7/site-packages/plotnine/scales/scale_size.py:50: PlotnineWarning: Using size for a discrete variable is not advised. /home/cgb4/anaconda3/envs/py37/lib/python3.7/site-packages/plotnine/stats/smoothers.py:311: PlotnineWarning: Confidence intervals are not yet implementedfor lowess smoothings. . &lt;ggplot: (8726729919385)&gt; . - 선의 색깔을 동일하게 하고 선의 타입을 변경하여 drv를 표시하고 싶다면? . a1,a2,a3,a4 . ({&#39;x&#39;: &#39;displ&#39;, &#39;y&#39;: &#39;hwy&#39;}, {&#39;x&#39;: &#39;displ&#39;, &#39;y&#39;: &#39;hwy&#39;, &#39;color&#39;: &#39;class&#39;}, {&#39;x&#39;: &#39;displ&#39;, &#39;y&#39;: &#39;hwy&#39;, &#39;color&#39;: &#39;drv&#39;, &#39;size&#39;: &#39;class&#39;}, {&#39;x&#39;: &#39;displ&#39;, &#39;y&#39;: &#39;hwy&#39;, &#39;color&#39;: &#39;drv&#39;}) . a5=a1.copy() a5[&#39;linetype&#39;]=&#39;drv&#39; a5 . {&#39;x&#39;: &#39;displ&#39;, &#39;y&#39;: &#39;hwy&#39;, &#39;linetype&#39;: &#39;drv&#39;} . line3 = geom_smooth(a5,size=0.5,color=&#39;gray&#39;) . fig+point3+line3 . /home/cgb4/anaconda3/envs/py37/lib/python3.7/site-packages/plotnine/scales/scale_size.py:50: PlotnineWarning: Using size for a discrete variable is not advised. /home/cgb4/anaconda3/envs/py37/lib/python3.7/site-packages/plotnine/stats/smoothers.py:311: PlotnineWarning: Confidence intervals are not yet implementedfor lowess smoothings. . &lt;ggplot: (8726732637457)&gt; . - 전체적인 추세선도 추가하고 싶다면? . fig+point3+line3+line1 . /home/cgb4/anaconda3/envs/py37/lib/python3.7/site-packages/plotnine/scales/scale_size.py:50: PlotnineWarning: Using size for a discrete variable is not advised. /home/cgb4/anaconda3/envs/py37/lib/python3.7/site-packages/plotnine/stats/smoothers.py:311: PlotnineWarning: Confidence intervals are not yet implementedfor lowess smoothings. . &lt;ggplot: (8726732939513)&gt; . - 그려보니까 역시 drv별로 그려지는 추세선은 색깔별로 구분하는게 좋겠음. . line2 = geom_smooth(a4,size=0.5,linetype=&#39;dashed&#39;) fig+point3+line2+line1 . /home/cgb4/anaconda3/envs/py37/lib/python3.7/site-packages/plotnine/scales/scale_size.py:50: PlotnineWarning: Using size for a discrete variable is not advised. /home/cgb4/anaconda3/envs/py37/lib/python3.7/site-packages/plotnine/stats/smoothers.py:311: PlotnineWarning: Confidence intervals are not yet implementedfor lowess smoothings. . &lt;ggplot: (8726733678229)&gt; . - 고차원을 변수를 표현할 수 있는 무기는 다양하다. . 산점도(포인트지옴): 점의크기, 점의형태, 점의색깔, 점의투명도 | 라인플랏(스무스지옴,라인지옴): 선의형태, 선의색깔, 선의굵기 | . &#44208;&#47200; . - 잘 훈련한다면 여러가지 형태의 고차원 그래프를 우리도 그릴 수 있다. (마치 미나드처럼) . - 해들리위컴은 이러한 방법을 체계적으로 정리했다고 보여진다. . - 해들리위컴: 그래프는 데이터 + 지옴 + 맵핑(변수와 에스테틱간의 연결) + 스탯(통계) + 포지션 + 축 + 패싯그리드 7개의 조합으로 그릴 수 있다. . 내생각: 지옴과 맵핑만 잘 다루어도 아주 다양한 그래프를 그릴 수 있음. | .",
            "url": "https://guebin.github.io/DV2022/2022/10/06/(5%EC%A3%BC%EC%B0%A8)-10%EC%9B%946%EC%9D%BC-10%EC%9B%943%EC%9D%BC%EA%B0%95%EC%9D%98%EC%97%90-%EB%8C%80%ED%95%9C%EB%B3%B4%EC%B6%A9.html",
            "relUrl": "/2022/10/06/(5%EC%A3%BC%EC%B0%A8)-10%EC%9B%946%EC%9D%BC-10%EC%9B%943%EC%9D%BC%EA%B0%95%EC%9D%98%EC%97%90-%EB%8C%80%ED%95%9C%EB%B3%B4%EC%B6%A9.html",
            "date": " • Oct 6, 2022"
        }
        
    
  
    
        ,"post6": {
            "title": "(5주차) 10월6일 -- 10월3일 강의에 대한 보충",
            "content": "&#44053;&#51032;&#50689;&#49345; . . imports . import numpy as np import pandas as pd import matplotlib.pyplot as plt import seaborn as sns from plotnine import * . &#54988;&#47469;&#54620; &#49884;&#44033;&#54868;&#46976;? . &#50528;&#46300;&#50892;&#46300; &#53552;&#54532;&#54000; . - 데이터 시각화계의 거장 . - 터프티의 이론중 백미: 엄격한 미니멀리즘 . 최소한의 잉크로 많은 정보를 전달할 수 있다면 그것이 바로 좋은 그래프이다. | 작은 지면 내에서 잉크를 최대한 적게 써서 짧은 시간 안에 많은 영감을 주어야 한다. | . - 데이터-잉크비: 데이터를 표현하는데 들아가는 잉크의 양 / 그래픽을 인쇄하는데 들어가는 잉크의 총량 . - 차트정크 (나이젤홈즈의 그래프) . . “Lurking behind chartjunk is contempt both for information and for the audience. Chartjunk promoters imagine that numbers and details are boring, dull, and tedious, requiring ornament to enliven. Cosmetic decoration, which frequently distorts the data, will never salvage an underlying lack of content. If the numbers are boring, then you’ve got the wrong numbers (...) Worse is contempt for our audience, designing as if readers were obtuse and uncaring. In fact, consumers of graphics are often more intelligent about the information at hand than those who fabricate the data decoration (...) The operating moral premise of information design should be that our readers are alert and caring; they may be busy, eager to get on with it, but they are not stupid.” . 차트정크 = 대중을 멸시 + 데이터에 대한 모독 | 차트정크 옹호가는 숫자와 데이터가 지루하여 활기가 필요하다고 생각하는 모양이다.. | . - 별로인 그래프 (왼쪽) / 우수한 그래프 오른쪽 . . - 별로인 그래프 (왼쪽) / 우수한 그래프 오른쪽 . . - 별로인 그래프 (왼쪽) / 우수한 그래프 오른쪽 . . - 제 생각: 글쎄... . &#52272;&#49828;&#48120;&#45208;&#46300;&#51032; &#46020;&#54364; . 인류역사상 가장 훌륭한 시각화 | . . - 터프티의 평 . 지금까지 그려진 최고의 통계 그래픽일지도 모른다. | 여기에서는 군대의 크기, 2차원 평면상의 위치, 군대의 이동방향, 모스코바에서 퇴각하는 동안의 여러날짜, 온도 $ to$ 6차원의 변수 | 백만번에 한번 이런 그림을 그릴수는 있겠지만 이러한 멋진 그래픽을 만드는 방법에 대한 원칙은 없다. $ to$ 미니멀리즘.. | . - 왜 우수한 그래프일까? . 자료를 파악하는 기법은 최근까지도 산점도, 막대그래프, 라인플랏에 의존 | 이러한 플랏의 단점은 고차원의 자료를 분석하기 어렵다는 것임 | 미나드는 여러그램을 그리는 방법 대신에 한 그림에서 패널을 늘리는 방법을 선택함. | . &#48120;&#45208;&#46300;&#52376;&#47100; &#44536;&#47532;&#45716;&#44172; &#50780; &#50612;&#47140;&#50868;&#44032;? . - 몸무게, 키, 성별, 국적 . df1=pd.read_csv(&#39;https://raw.githubusercontent.com/guebin/DV2022/master/_notebooks/male1.csv&#39;) df2=pd.read_csv(&#39;https://raw.githubusercontent.com/guebin/DV2022/master/_notebooks/male2.csv&#39;) df3=pd.read_csv(&#39;https://raw.githubusercontent.com/guebin/DV2022/master/_notebooks/female.csv&#39;) df4=pd.read_csv(&#39;https://raw.githubusercontent.com/guebin/DV2022/master/_notebooks/foreign.csv&#39;) . - 미나드의 접근방법 . _df = pd.concat([pd.concat([df1,df2],axis=1).assign(g=&#39;m&#39;),df3.assign(g=&#39;f&#39;)]) df = pd.concat([_df.assign(g2=&#39;korea&#39;),df4.assign(g2=&#39;foreign&#39;)]).reset_index(drop=True) df . w h g g2 . 0 72.788217 | 183.486773 | m | korea | . 1 66.606430 | 173.599877 | m | korea | . 2 69.806324 | 173.237903 | m | korea | . 3 67.449439 | 173.223805 | m | korea | . 4 70.463183 | 174.931946 | m | korea | . ... ... | ... | ... | ... | . 1525 78.154632 | 188.324350 | m | foreign | . 1526 74.754308 | 183.017979 | f | foreign | . 1527 91.196208 | 190.100456 | m | foreign | . 1528 87.770394 | 187.987255 | m | foreign | . 1529 88.021995 | 193.456798 | m | foreign | . 1530 rows × 4 columns . sns.scatterplot(data=df,x=&#39;w&#39;,y=&#39;h&#39;,hue=&#39;g&#39;,style=&#39;g2&#39;) . &lt;AxesSubplot:xlabel=&#39;w&#39;, ylabel=&#39;h&#39;&gt; . - 어려운점: (1) 센스가 없어서 hue/style을 이용하여 그룹을 구분할 생각을 못함 (2) long df (=tidy data) 형태로 데이터를 정리할 생각을 못함 (3) long df 형태로 데이터를 변형하는 코드를 모름 . (1) 기획력부족 -&gt; 훌륭한 시각화를 많이 볼 것 | (2) 데이터프레임에 대한 이해부족 -&gt; tidydata에 대한 개념 | (3) 프로그래밍 능력 -&gt; 코딩공부열심히 (pandas를 엄청 잘해야함) | . read mpg data . - ref: https://r4ds.had.co.nz/index.html . &#48169;&#48277;1: rpy2 (&#53076;&#47017; &#50500;&#45772;&#44221;&#50864; &#49892;&#49845;&#44552;&#51648;) . import rpy2 %load_ext rpy2.ipython . %%R ### 여기는 R처럼 쓸 수 있다. a &lt;- c(1,2,3) a+1 . [1] 2 3 4 . a . NameError Traceback (most recent call last) /tmp/ipykernel_1214567/2167009006.py in &lt;module&gt; -&gt; 1 a NameError: name &#39;a&#39; is not defined . %%R library(tidyverse) mpg . # A tibble: 234 × 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 audi a4 1.8 1999 4 auto… f 18 29 p comp… 2 audi a4 1.8 1999 4 manu… f 21 29 p comp… 3 audi a4 2 2008 4 manu… f 20 31 p comp… 4 audi a4 2 2008 4 auto… f 21 30 p comp… 5 audi a4 2.8 1999 6 auto… f 16 26 p comp… 6 audi a4 2.8 1999 6 manu… f 18 26 p comp… 7 audi a4 3.1 2008 6 auto… f 18 27 p comp… 8 audi a4 quattro 1.8 1999 4 manu… 4 18 26 p comp… 9 audi a4 quattro 1.8 1999 4 auto… 4 16 25 p comp… 10 audi a4 quattro 2 2008 4 manu… 4 20 28 p comp… # … with 224 more rows # ℹ Use `print(n = ...)` to see more rows . mpg . NameError Traceback (most recent call last) /tmp/ipykernel_1214567/602803287.py in &lt;module&gt; -&gt; 1 mpg NameError: name &#39;mpg&#39; is not defined . %R -o mpg # R에 있는 자료가 파이썬으로 넘어옴 . mpg . manufacturer model displ year cyl trans drv cty hwy fl class . 1 audi | a4 | 1.8 | 1999 | 4 | auto(l5) | f | 18 | 29 | p | compact | . 2 audi | a4 | 1.8 | 1999 | 4 | manual(m5) | f | 21 | 29 | p | compact | . 3 audi | a4 | 2.0 | 2008 | 4 | manual(m6) | f | 20 | 31 | p | compact | . 4 audi | a4 | 2.0 | 2008 | 4 | auto(av) | f | 21 | 30 | p | compact | . 5 audi | a4 | 2.8 | 1999 | 6 | auto(l5) | f | 16 | 26 | p | compact | . ... ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | . 230 volkswagen | passat | 2.0 | 2008 | 4 | auto(s6) | f | 19 | 28 | p | midsize | . 231 volkswagen | passat | 2.0 | 2008 | 4 | manual(m6) | f | 21 | 29 | p | midsize | . 232 volkswagen | passat | 2.8 | 1999 | 6 | auto(l5) | f | 16 | 26 | p | midsize | . 233 volkswagen | passat | 2.8 | 1999 | 6 | manual(m5) | f | 18 | 26 | p | midsize | . 234 volkswagen | passat | 3.6 | 2008 | 6 | auto(s6) | f | 17 | 26 | p | midsize | . 234 rows × 11 columns . &#48169;&#48277;2: &#51200;&#51109;&#46108; csv&#54028;&#51068;&#51012; &#53685;&#54616;&#50668; &#45936;&#51060;&#53552;&#47484; &#54869;&#48372; . mpg.to_csv(&quot;mpg.csv&quot;,index=False) . pd.read_csv(&quot;mpg.csv&quot;) . manufacturer model displ year cyl trans drv cty hwy fl class . 0 audi | a4 | 1.8 | 1999 | 4 | auto(l5) | f | 18 | 29 | p | compact | . 1 audi | a4 | 1.8 | 1999 | 4 | manual(m5) | f | 21 | 29 | p | compact | . 2 audi | a4 | 2.0 | 2008 | 4 | manual(m6) | f | 20 | 31 | p | compact | . 3 audi | a4 | 2.0 | 2008 | 4 | auto(av) | f | 21 | 30 | p | compact | . 4 audi | a4 | 2.8 | 1999 | 6 | auto(l5) | f | 16 | 26 | p | compact | . ... ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | . 229 volkswagen | passat | 2.0 | 2008 | 4 | auto(s6) | f | 19 | 28 | p | midsize | . 230 volkswagen | passat | 2.0 | 2008 | 4 | manual(m6) | f | 21 | 29 | p | midsize | . 231 volkswagen | passat | 2.8 | 1999 | 6 | auto(l5) | f | 16 | 26 | p | midsize | . 232 volkswagen | passat | 2.8 | 1999 | 6 | manual(m5) | f | 18 | 26 | p | midsize | . 233 volkswagen | passat | 3.6 | 2008 | 6 | auto(s6) | f | 17 | 26 | p | midsize | . 234 rows × 11 columns . &#48169;&#48277;3: github&#46321;&#50640; &#44277;&#44060;&#46108; csv&#47484; &#51069;&#50612;&#50724;&#44592; . pd.read_csv(&#39;https://raw.githubusercontent.com/guebin/DV2022/master/_notebooks/mpg.csv&#39;) . manufacturer model displ year cyl trans drv cty hwy fl class . 0 audi | a4 | 1.8 | 1999 | 4 | auto(l5) | f | 18 | 29 | p | compact | . 1 audi | a4 | 1.8 | 1999 | 4 | manual(m5) | f | 21 | 29 | p | compact | . 2 audi | a4 | 2.0 | 2008 | 4 | manual(m6) | f | 20 | 31 | p | compact | . 3 audi | a4 | 2.0 | 2008 | 4 | auto(av) | f | 21 | 30 | p | compact | . 4 audi | a4 | 2.8 | 1999 | 6 | auto(l5) | f | 16 | 26 | p | compact | . ... ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | . 229 volkswagen | passat | 2.0 | 2008 | 4 | auto(s6) | f | 19 | 28 | p | midsize | . 230 volkswagen | passat | 2.0 | 2008 | 4 | manual(m6) | f | 21 | 29 | p | midsize | . 231 volkswagen | passat | 2.8 | 1999 | 6 | auto(l5) | f | 16 | 26 | p | midsize | . 232 volkswagen | passat | 2.8 | 1999 | 6 | manual(m5) | f | 18 | 26 | p | midsize | . 233 volkswagen | passat | 3.6 | 2008 | 6 | auto(s6) | f | 17 | 26 | p | midsize | . 234 rows × 11 columns . - 깃허브 저장소에 아예 데이터만 따로 모아서 관리하는 것도 좋은 방법입니다. . data &#49444;&#47749; . - displ: 자동차의 엔진크기 . - hwy: 연료의 효율, 동일한 연료로 얼마나 멀리 가느냐? . - 자세한 설명은 R에서 ?mpg를 이용해 스스로 찾아볼 것 . p9&#47484; &#51060;&#50857;&#54620; &#49328;&#51216;&#46020; (2&#52264;&#50896;) . python&#50640;&#49436;: plotnine&#51012; &#51060;&#50857;&#54620; &#49328;&#51216;&#46020; . ggplot(data=mpg) + geom_point(mapping=aes(x=&#39;displ&#39;,y=&#39;hwy&#39;)) ## plotnine . &lt;ggplot: (8726736046009)&gt; . 산점도 해석: 엔진크기가 클수록 효율이 낮음. | . - 빠르게 그리기: data=와 mapping=은 생략가능함 . ggplot(mpg) + geom_point(aes(x=&#39;displ&#39;,y=&#39;hwy&#39;)) ## plotnine . &lt;ggplot: (8726735544581)&gt; . R&#50640;&#49436;: ggplot2&#47484; &#51060;&#50857;&#54620; &#49328;&#51216;&#46020; . - R에서도 거의 똑같은 문법으로 그릴 수 있음 (데이터프레임 혹은 티블에 저장된 column 이름을 사용할때 따옴표만 제거하면 된다!) . %%R -w 800 ggplot(mpg) + geom_point(aes(x=displ,y=hwy)) ## plotnine . python&#50640;&#49436;: &#44061;&#52404;&#51648;&#54693;&#51201;&#51064; &#45712;&#45196;&#51004;&#47196; &#49328;&#51216;&#46020; &#44536;&#47532;&#44592; . step1: 도화지를 준비한다. . fig = ggplot(data=mpg) fig . &lt;ggplot: (8726735085529)&gt; . step2 변수와 에스테틱사이의 맵핑을 설정한다. . a1= aes(x=&#39;displ&#39;,y=&#39;hwy&#39;) a1 . {&#39;x&#39;: &#39;displ&#39;, &#39;y&#39;: &#39;hwy&#39;} . step3 점들의 집합을 만든다. 즉 포인트 지옴을 만든다. . point1=geom_point(mapping=a1) . geom_point(): 점들을 그려! 어떻게? | a1에서 설정된 표를 보고 | . step4 도화지와 지옴을 합친다. . fig+point1 . &lt;ggplot: (8726775447877)&gt; . p9&#47484; &#51060;&#50857;&#54620; &#49328;&#51216;&#46020; (3&#52264;&#50896;) . - 데이터를 다시 관찰 . mpg.head() . manufacturer model displ year cyl trans drv cty hwy fl class . 1 audi | a4 | 1.8 | 1999 | 4 | auto(l5) | f | 18 | 29 | p | compact | . 2 audi | a4 | 1.8 | 1999 | 4 | manual(m5) | f | 21 | 29 | p | compact | . 3 audi | a4 | 2.0 | 2008 | 4 | manual(m6) | f | 20 | 31 | p | compact | . 4 audi | a4 | 2.0 | 2008 | 4 | auto(av) | f | 21 | 30 | p | compact | . 5 audi | a4 | 2.8 | 1999 | 6 | auto(l5) | f | 16 | 26 | p | compact | . - class도 함께 plot에 표시하면 데이터를 탐색할때 좀 더 좋을 것 같다. . &#49328;&#51216;&#46020; + &#51216;&#53356;&#44592;&#48320;&#44221; . ggplot(data=mpg) + geom_point(mapping = aes(x=&#39;displ&#39;,y=&#39;hwy&#39;,size=&#39;class&#39;)) . /home/cgb4/anaconda3/envs/py37/lib/python3.7/site-packages/plotnine/scales/scale_size.py:50: PlotnineWarning: Using size for a discrete variable is not advised. . &lt;ggplot: (8726734563561)&gt; . &#49328;&#51216;&#46020; + &#53804;&#47749;&#46020;&#48320;&#44221; . ggplot(data=mpg) + geom_point(mapping = aes(x=&#39;displ&#39;,y=&#39;hwy&#39;,alpha=&#39;class&#39;)) . /home/cgb4/anaconda3/envs/py37/lib/python3.7/site-packages/plotnine/scales/scale_alpha.py:70: PlotnineWarning: Using alpha for a discrete variable is not advised. . &lt;ggplot: (8726734989121)&gt; . &#49328;&#51216;&#46020; + &#53804;&#47749;&#46020;/&#51216;&#53356;&#44592;&#47484; &#46041;&#49884;&#50640; &#51201;&#50857; . ggplot(data=mpg) + geom_point(mapping = aes(x=&#39;displ&#39;,y=&#39;hwy&#39;,alpha=&#39;class&#39;,size=&#39;class&#39;)) . /home/cgb4/anaconda3/envs/py37/lib/python3.7/site-packages/plotnine/scales/scale_alpha.py:70: PlotnineWarning: Using alpha for a discrete variable is not advised. /home/cgb4/anaconda3/envs/py37/lib/python3.7/site-packages/plotnine/scales/scale_size.py:50: PlotnineWarning: Using size for a discrete variable is not advised. . &lt;ggplot: (8726734522405)&gt; . &#49328;&#51216;&#46020; + &#54805;&#53468; . ggplot(data=mpg) + geom_point(mapping = aes(x=&#39;displ&#39;,y=&#39;hwy&#39;,shape=&#39;class&#39;)) . &lt;ggplot: (8726734265229)&gt; . &#49328;&#51216;&#46020; + &#49353;&#44628; . ggplot(data=mpg) + geom_point(mapping = aes(x=&#39;displ&#39;,y=&#39;hwy&#39;,color=&#39;class&#39;)) . &lt;ggplot: (8726734017473)&gt; . &#44061;&#52404;&#51648;&#54693;&#51201; &#45712;&#45196;&#51004;&#47196;? . a2 = aes(x=&#39;displ&#39;, y=&#39;hwy&#39;, color=&#39;class&#39;) . a1,a2 . ({&#39;x&#39;: &#39;displ&#39;, &#39;y&#39;: &#39;hwy&#39;}, {&#39;x&#39;: &#39;displ&#39;, &#39;y&#39;: &#39;hwy&#39;, &#39;color&#39;: &#39;class&#39;}) . point2=geom_point(a2) . fig+point2 . &lt;ggplot: (8726733712885)&gt; . &#49328;&#51216;&#46020; + &#49353;&#44628; + &#51201;&#54633;&#49440; . - 일단 색깔이 없는 포인트 지옴부터 연습 . fig+point1 . &lt;ggplot: (8726733452617)&gt; . line1 = geom_smooth(a1) . fig+point1+line1 . /home/cgb4/anaconda3/envs/py37/lib/python3.7/site-packages/plotnine/stats/smoothers.py:311: PlotnineWarning: Confidence intervals are not yet implementedfor lowess smoothings. . &lt;ggplot: (8726732994973)&gt; . - point1(색깔없는 포인트 지옴)을 point2(색깔있는 포인트 지옴)으로 언제든지 바꿔치기 가능! . fig+point2+line1 . /home/cgb4/anaconda3/envs/py37/lib/python3.7/site-packages/plotnine/stats/smoothers.py:311: PlotnineWarning: Confidence intervals are not yet implementedfor lowess smoothings. . &lt;ggplot: (8726732661565)&gt; . - 명령어로 한번에 그리기 . ggplot(data=mpg) + geom_point(mapping=aes(x=&#39;displ&#39;,y=&#39;hwy&#39;,color=&#39;class&#39;)) + geom_smooth(mapping=aes(x=&#39;displ&#39;,y=&#39;hwy&#39;)) . /home/cgb4/anaconda3/envs/py37/lib/python3.7/site-packages/plotnine/stats/smoothers.py:311: PlotnineWarning: Confidence intervals are not yet implementedfor lowess smoothings. . &lt;ggplot: (8726732727485)&gt; . - 공통적인 맵핑규칙은 ggplot()쪽으로 빼기도 한다. (figure를 선언하는 곳에서 공통으로 선언함) . ggplot(data=mpg,mapping=aes(x=&#39;displ&#39;,y=&#39;hwy&#39;)) + geom_point(mapping=aes(color=&#39;class&#39;)) + geom_smooth() . /home/cgb4/anaconda3/envs/py37/lib/python3.7/site-packages/plotnine/stats/smoothers.py:311: PlotnineWarning: Confidence intervals are not yet implementedfor lowess smoothings. . &lt;ggplot: (8726733489953)&gt; . - R에서는 confidence interval도 geom_smooth()를 이용하여 확인할 수 있다. . %%R -w 800 ggplot(data=mpg,mapping=aes(x=displ,y=hwy)) + geom_point(mapping=aes(color=class)) + geom_smooth() . R[write to console]: `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; . p9&#47484; &#51060;&#50857;&#54620; &#49328;&#51216;&#46020; (4&#52264;&#50896;) . - 데이터를 살펴보자. . mpg.head() . manufacturer model displ year cyl trans drv cty hwy fl class . 1 audi | a4 | 1.8 | 1999 | 4 | auto(l5) | f | 18 | 29 | p | compact | . 2 audi | a4 | 1.8 | 1999 | 4 | manual(m5) | f | 21 | 29 | p | compact | . 3 audi | a4 | 2.0 | 2008 | 4 | manual(m6) | f | 20 | 31 | p | compact | . 4 audi | a4 | 2.0 | 2008 | 4 | auto(av) | f | 21 | 30 | p | compact | . 5 audi | a4 | 2.8 | 1999 | 6 | auto(l5) | f | 16 | 26 | p | compact | . &#49328;&#51216;&#46020; + &#51216;&#53356;&#44592;&#48320;&#44221; + &#49353;&#44628; . - drv (전륜, 후륜, 4륜 구동)에 따라서 데이터를 시각화 하고 싶다. . ggplot(data=mpg, mapping=aes(x=&#39;displ&#39;,y=&#39;hwy&#39;)) + geom_point(mapping=aes(size=&#39;class&#39;,color=&#39;drv&#39;),alpha=0.3) . /home/cgb4/anaconda3/envs/py37/lib/python3.7/site-packages/plotnine/scales/scale_size.py:50: PlotnineWarning: Using size for a discrete variable is not advised. . &lt;ggplot: (8726731152845)&gt; . 모든 $x$에 대하여 붉은색 점들이 대부분 초록색과 보라색 점들에 비하여 아래쪽에 있음 $ to$ 4륜구동방식이 연비가 좋지 않음 | . &#49328;&#51216;&#46020; + &#51216;&#53356;&#44592;&#48320;&#44221; + &#49353;&#44628; (&#44061;&#52404;&#51648;&#54693;&#48260;&#51204;) . - 맵핑규칙 . a1,a2 . ({&#39;x&#39;: &#39;displ&#39;, &#39;y&#39;: &#39;hwy&#39;}, {&#39;x&#39;: &#39;displ&#39;, &#39;y&#39;: &#39;hwy&#39;, &#39;color&#39;: &#39;class&#39;}) . a3 = a2.copy() . a3[&#39;color&#39;] = &#39;drv&#39; a3[&#39;size&#39;] = &#39;class&#39; a3 . {&#39;x&#39;: &#39;displ&#39;, &#39;y&#39;: &#39;hwy&#39;, &#39;color&#39;: &#39;drv&#39;, &#39;size&#39;: &#39;class&#39;} . 아래와 같이 선언해도 괜찮음 a3= aes(x=&#39;displ&#39;,y=&#39;hwy&#39;,color=&#39;drv&#39;,size=&#39;class&#39;) . | . point3=geom_point(a3) . fig+point3 . /home/cgb4/anaconda3/envs/py37/lib/python3.7/site-packages/plotnine/scales/scale_size.py:50: PlotnineWarning: Using size for a discrete variable is not advised. . &lt;ggplot: (8726731065581)&gt; . 그림의 전체적인 투명도를 조절하면 좋겠음 | . point3=geom_point(a3,alpha=0.2) fig+point3 . /home/cgb4/anaconda3/envs/py37/lib/python3.7/site-packages/plotnine/scales/scale_size.py:50: PlotnineWarning: Using size for a discrete variable is not advised. . &lt;ggplot: (8726730819657)&gt; . &#49328;&#51216;&#46020; + &#51216;&#53356;&#44592;&#48320;&#44221; + &#49353;&#44628; + &#49440;&#52628;&#44032; . fig+point3+line1 . /home/cgb4/anaconda3/envs/py37/lib/python3.7/site-packages/plotnine/scales/scale_size.py:50: PlotnineWarning: Using size for a discrete variable is not advised. /home/cgb4/anaconda3/envs/py37/lib/python3.7/site-packages/plotnine/stats/smoothers.py:311: PlotnineWarning: Confidence intervals are not yet implementedfor lowess smoothings. . &lt;ggplot: (8726730575253)&gt; . &#49328;&#51216;&#46020; + &#51216;&#53356;&#44592;&#48320;&#44221; + &#49353;&#44628; + drv&#48324;&#47196; &#49440;&#52628;&#44032; . - 맵핑규칙 . a1,a2,a3 . ({&#39;x&#39;: &#39;displ&#39;, &#39;y&#39;: &#39;hwy&#39;}, {&#39;x&#39;: &#39;displ&#39;, &#39;y&#39;: &#39;hwy&#39;, &#39;color&#39;: &#39;class&#39;}, {&#39;x&#39;: &#39;displ&#39;, &#39;y&#39;: &#39;hwy&#39;, &#39;color&#39;: &#39;drv&#39;, &#39;size&#39;: &#39;class&#39;}) . a4 = a2.copy() a4[&#39;color&#39;]=&#39;drv&#39; a4 . {&#39;x&#39;: &#39;displ&#39;, &#39;y&#39;: &#39;hwy&#39;, &#39;color&#39;: &#39;drv&#39;} . line2 = geom_smooth(a4) . fig + point3 +line2 . /home/cgb4/anaconda3/envs/py37/lib/python3.7/site-packages/plotnine/scales/scale_size.py:50: PlotnineWarning: Using size for a discrete variable is not advised. /home/cgb4/anaconda3/envs/py37/lib/python3.7/site-packages/plotnine/stats/smoothers.py:311: PlotnineWarning: Confidence intervals are not yet implementedfor lowess smoothings. . &lt;ggplot: (8726729919385)&gt; . - 선의 색깔을 동일하게 하고 선의 타입을 변경하여 drv를 표시하고 싶다면? . a1,a2,a3,a4 . ({&#39;x&#39;: &#39;displ&#39;, &#39;y&#39;: &#39;hwy&#39;}, {&#39;x&#39;: &#39;displ&#39;, &#39;y&#39;: &#39;hwy&#39;, &#39;color&#39;: &#39;class&#39;}, {&#39;x&#39;: &#39;displ&#39;, &#39;y&#39;: &#39;hwy&#39;, &#39;color&#39;: &#39;drv&#39;, &#39;size&#39;: &#39;class&#39;}, {&#39;x&#39;: &#39;displ&#39;, &#39;y&#39;: &#39;hwy&#39;, &#39;color&#39;: &#39;drv&#39;}) . a5=a1.copy() a5[&#39;linetype&#39;]=&#39;drv&#39; a5 . {&#39;x&#39;: &#39;displ&#39;, &#39;y&#39;: &#39;hwy&#39;, &#39;linetype&#39;: &#39;drv&#39;} . line3 = geom_smooth(a5,size=0.5,color=&#39;gray&#39;) . fig+point3+line3 . /home/cgb4/anaconda3/envs/py37/lib/python3.7/site-packages/plotnine/scales/scale_size.py:50: PlotnineWarning: Using size for a discrete variable is not advised. /home/cgb4/anaconda3/envs/py37/lib/python3.7/site-packages/plotnine/stats/smoothers.py:311: PlotnineWarning: Confidence intervals are not yet implementedfor lowess smoothings. . &lt;ggplot: (8726732637457)&gt; . - 전체적인 추세선도 추가하고 싶다면? . fig+point3+line3+line1 . /home/cgb4/anaconda3/envs/py37/lib/python3.7/site-packages/plotnine/scales/scale_size.py:50: PlotnineWarning: Using size for a discrete variable is not advised. /home/cgb4/anaconda3/envs/py37/lib/python3.7/site-packages/plotnine/stats/smoothers.py:311: PlotnineWarning: Confidence intervals are not yet implementedfor lowess smoothings. . &lt;ggplot: (8726732939513)&gt; . - 그려보니까 역시 drv별로 그려지는 추세선은 색깔별로 구분하는게 좋겠음. . line2 = geom_smooth(a4,size=0.5,linetype=&#39;dashed&#39;) fig+point3+line2+line1 . /home/cgb4/anaconda3/envs/py37/lib/python3.7/site-packages/plotnine/scales/scale_size.py:50: PlotnineWarning: Using size for a discrete variable is not advised. /home/cgb4/anaconda3/envs/py37/lib/python3.7/site-packages/plotnine/stats/smoothers.py:311: PlotnineWarning: Confidence intervals are not yet implementedfor lowess smoothings. . &lt;ggplot: (8726733678229)&gt; . - 고차원을 변수를 표현할 수 있는 무기는 다양하다. . 산점도(포인트지옴): 점의크기, 점의형태, 점의색깔, 점의투명도 | 라인플랏(스무스지옴,라인지옴): 선의형태, 선의색깔, 선의굵기 | . &#44208;&#47200; . - 잘 훈련한다면 여러가지 형태의 고차원 그래프를 우리도 그릴 수 있다. (마치 미나드처럼) . - 해들리위컴은 이러한 방법을 체계적으로 정리했다고 보여진다. . - 해들리위컴: 그래프는 데이터 + 지옴 + 맵핑(변수와 에스테틱간의 연결) + 스탯(통계) + 포지션 + 축 + 패싯그리드 7개의 조합으로 그릴 수 있다. . 내생각: 지옴과 맵핑만 잘 다루어도 아주 다양한 그래프를 그릴 수 있음. | .",
            "url": "https://guebin.github.io/DV2022/2022/10/06/(5%EC%A3%BC%EC%B0%A8)-10%EC%9B%946%EC%9D%BC-10%EC%9B%943%EC%9D%BC%EA%B0%95%EC%9D%98%EC%97%90-%EB%8C%80%ED%95%9C%EB%B3%B4%EC%B6%A9.html",
            "relUrl": "/2022/10/06/(5%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1)-10%E1%84%8B%E1%85%AF%E1%86%AF6%E1%84%8B%E1%85%B5%E1%86%AF-10%E1%84%8B%E1%85%AF%E1%86%AF3%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%E1%84%8B%E1%85%A6-%E1%84%83%E1%85%A2%E1%84%92%E1%85%A1%E1%86%AB%E1%84%87%E1%85%A9%E1%84%8E%E1%85%AE%E1%86%BC.html",
            "date": " • Oct 6, 2022"
        }
        
    
  
    
        ,"post7": {
            "title": "(5주차) 10월5일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . import . import numpy as np import pandas as pd import matplotlib.pyplot as plt import seaborn as sns . sns scatterplot . - data . x1,y1 = np.random.multivariate_normal([0,0],[[1,0],[0,1]],size=1000).T x2,y2 = np.random.multivariate_normal([2,2],[[1,0.7],[0.7,1]],size=1000).T . 이변량정규분포에서 샘플추출 (추출코드를 기억할 필요는 없음) | 특징: x1,y1은 무상관으로 x2,y2는 선형관계를 가지도록 추출 | . plt &#48373;&#49845; . plt.plot(x1,y1,&#39;o&#39;) plt.plot(x2,y2,&#39;o&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f6071f8a2d0&gt;] . sns: array . sns.scatterplot(data=None,x=x1,y=y1) sns.scatterplot(data=None,x=x2,y=y2) . &lt;AxesSubplot:&gt; . sns: wide df . sns.scatterplot(data=pd.DataFrame({&#39;x&#39;:x1,&#39;y&#39;:y1}),x=&#39;x&#39;,y=&#39;y&#39;) sns.scatterplot(data=pd.DataFrame({&#39;x&#39;:x2,&#39;y&#39;:y2}),x=&#39;x&#39;,y=&#39;y&#39;) #sns.scatterplot(data=None,x=x2,y=y2) . &lt;AxesSubplot:xlabel=&#39;x&#39;, ylabel=&#39;y&#39;&gt; . 억지로 그리긴 했는데 이 경우는 wide하게 만든 df는 별로 경쟁력이 없음 | . sns: long df . x= np.concatenate([x1,x2]) y= np.concatenate([y1,y2]) cat = [&#39;x1&#39;]*len(x1) + [&#39;x2&#39;]*len(x2) df2 = pd.DataFrame({&#39;x&#39;:x,&#39;y&#39;:y,&#39;cat&#39;:cat}) df2 . x y cat . 0 2.023919 | -0.400176 | x1 | . 1 1.229622 | -1.763752 | x1 | . 2 -0.413211 | 2.293004 | x1 | . 3 -1.343073 | 0.404232 | x1 | . 4 1.062845 | 0.030775 | x1 | . ... ... | ... | ... | . 1995 2.226805 | 3.683857 | x2 | . 1996 2.768263 | 2.678292 | x2 | . 1997 2.525295 | 2.815478 | x2 | . 1998 1.750193 | 2.289812 | x2 | . 1999 1.153290 | 2.095922 | x2 | . 2000 rows × 3 columns . sns.scatterplot(data=df2,x=&#39;x&#39;,y=&#39;y&#39;,hue=&#39;cat&#39;) . &lt;AxesSubplot:xlabel=&#39;x&#39;, ylabel=&#39;y&#39;&gt; . sns&#51012; &#51060;&#50857;&#54616;&#50668; matplotlib &#50529;&#49884;&#51592;&#50640; &#44536;&#47548; &#44536;&#47532;&#44592; ($ star$) . &#50696;&#51228;1 . fig,ax = plt.subplots(1,3,figsize=(12,4)) ax[0].plot([1,2,4,3],&#39;--o&#39;) sns.scatterplot(x=x1,y=y1,ax=ax[1]) sns.scatterplot(x=x1,y=y1,ax=ax[2]) sns.scatterplot(x=x2,y=y2,ax=ax[2]) ax[2].plot([1,2,4,3],&#39;-r&#39;,lw=5) . [&lt;matplotlib.lines.Line2D at 0x7f6077de7c10&gt;] . &#50696;&#51228;2 . import cv2 . !wget https://upload.wikimedia.org/wikipedia/commons/0/08/Unequalized_Hawkes_Bay_NZ.jpg img = cv2.imread(&#39;Unequalized_Hawkes_Bay_NZ.jpg&#39;,0) !rm Unequalized_Hawkes_Bay_NZ.jpg . --2022-10-05 16:33:56-- https://upload.wikimedia.org/wikipedia/commons/0/08/Unequalized_Hawkes_Bay_NZ.jpg Resolving upload.wikimedia.org (upload.wikimedia.org)... 103.102.166.240, 2001:df2:e500:ed1a::2:b Connecting to upload.wikimedia.org (upload.wikimedia.org)|103.102.166.240|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 110895 (108K) [image/jpeg] Saving to: ‘Unequalized_Hawkes_Bay_NZ.jpg’ Unequalized_Hawkes_ 100%[===================&gt;] 108.30K 548KB/s in 0.2s 2022-10-05 16:33:57 (548 KB/s) - ‘Unequalized_Hawkes_Bay_NZ.jpg’ saved [110895/110895] . img2 = cv2.equalizeHist(img) . img.reshape(-1) . array([127, 145, 149, ..., 146, 145, 144], dtype=uint8) . fig,ax = plt.subplots(2,2,figsize=(10,5)) ax[0,0].imshow(img,vmin=0,vmax=255,cmap=&#39;gray&#39;) sns.histplot(img.reshape(-1),ax=ax[0,1],bins=15,lw=0,kde=True,color=&#39;C1&#39;) ax[0,1].set_xlim(0,255) ax[1,0].imshow(img2,vmin=0,vmax=255,cmap=&#39;gray&#39;) sns.histplot(img2.reshape(-1),ax=ax[1,1],bins=15,lw=0,kde=True,color=&#39;C1&#39;) . &lt;AxesSubplot:ylabel=&#39;Count&#39;&gt; . - seaborn: figure-level vs axes-level 의 개념 . ref: https://seaborn.pydata.org/tutorial/function_overview.html#figure-level-vs-axes-level-functions . mpl &#48120;&#49464;&#47676;&#51648;&#54017; (2) . &#52629; &#44036;&#44201;&#51312;&#51221; . import matplotlib as mpl . fig, ax = plt.subplots() ax.plot([(xi/30)**2 for xi in range(30)],&#39;--o&#39;) ax.xaxis.set_major_locator(mpl.ticker.MultipleLocator(3)) # 큰 눈금간격을 3으로 ax.xaxis.set_minor_locator(mpl.ticker.MultipleLocator(1)) # 작은 눈금간격을 1로 . &#52629; &#49325;&#51228; . fig, ax = plt.subplots() ax.plot([(xi/30)**2 for xi in range(30)],&#39;--o&#39;) ax.xaxis.set_major_locator(mpl.ticker.NullLocator()) # x축 눈금삭제 ax.yaxis.set_major_locator(mpl.ticker.NullLocator()) # y축 눈금삭제 . &#52629; &#48276;&#50948;&#51312;&#51221; . fig, ax = plt.subplots() ax.plot([(xi/30)**2 for xi in range(30)],&#39;--o&#39;) ax.set_ylim(-1,2) ax.set_xlim(-5,35) #plt.ylim(-1,2) #plt.xlim(-5,35) . (-5.0, 35.0) . gcf, gca . - gcf . plt.plot([1,2,3,2]) fig = plt.gcf() . fig.suptitle(&#39;suptitle&#39;) . Text(0.5, 0.98, &#39;suptitle&#39;) . fig . - gca . fig . ax = fig.gca() . ax.set_title(&#39;title&#39;) fig .",
            "url": "https://guebin.github.io/DV2022/2022/10/03/(5%EC%A3%BC%EC%B0%A8)-10%EC%9B%945%EC%9D%BC.html",
            "relUrl": "/2022/10/03/(5%EC%A3%BC%EC%B0%A8)-10%EC%9B%945%EC%9D%BC.html",
            "date": " • Oct 3, 2022"
        }
        
    
  
    
        ,"post8": {
            "title": "(5주차) 10월5일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . import . import numpy as np import pandas as pd import matplotlib.pyplot as plt import seaborn as sns . sns scatterplot . - data . x1,y1 = np.random.multivariate_normal([0,0],[[1,0],[0,1]],size=1000).T x2,y2 = np.random.multivariate_normal([2,2],[[1,0.7],[0.7,1]],size=1000).T . 이변량정규분포에서 샘플추출 (추출코드를 기억할 필요는 없음) | 특징: x1,y1은 무상관으로 x2,y2는 선형관계를 가지도록 추출 | . plt &#48373;&#49845; . plt.plot(x1,y1,&#39;o&#39;) plt.plot(x2,y2,&#39;o&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f6071f8a2d0&gt;] . sns: array . sns.scatterplot(data=None,x=x1,y=y1) sns.scatterplot(data=None,x=x2,y=y2) . &lt;AxesSubplot:&gt; . sns: wide df . sns.scatterplot(data=pd.DataFrame({&#39;x&#39;:x1,&#39;y&#39;:y1}),x=&#39;x&#39;,y=&#39;y&#39;) sns.scatterplot(data=pd.DataFrame({&#39;x&#39;:x2,&#39;y&#39;:y2}),x=&#39;x&#39;,y=&#39;y&#39;) #sns.scatterplot(data=None,x=x2,y=y2) . &lt;AxesSubplot:xlabel=&#39;x&#39;, ylabel=&#39;y&#39;&gt; . 억지로 그리긴 했는데 이 경우는 wide하게 만든 df는 별로 경쟁력이 없음 | . sns: long df . x= np.concatenate([x1,x2]) y= np.concatenate([y1,y2]) cat = [&#39;x1&#39;]*len(x1) + [&#39;x2&#39;]*len(x2) df2 = pd.DataFrame({&#39;x&#39;:x,&#39;y&#39;:y,&#39;cat&#39;:cat}) df2 . x y cat . 0 2.023919 | -0.400176 | x1 | . 1 1.229622 | -1.763752 | x1 | . 2 -0.413211 | 2.293004 | x1 | . 3 -1.343073 | 0.404232 | x1 | . 4 1.062845 | 0.030775 | x1 | . ... ... | ... | ... | . 1995 2.226805 | 3.683857 | x2 | . 1996 2.768263 | 2.678292 | x2 | . 1997 2.525295 | 2.815478 | x2 | . 1998 1.750193 | 2.289812 | x2 | . 1999 1.153290 | 2.095922 | x2 | . 2000 rows × 3 columns . sns.scatterplot(data=df2,x=&#39;x&#39;,y=&#39;y&#39;,hue=&#39;cat&#39;) . &lt;AxesSubplot:xlabel=&#39;x&#39;, ylabel=&#39;y&#39;&gt; . sns&#51012; &#51060;&#50857;&#54616;&#50668; matplotlib &#50529;&#49884;&#51592;&#50640; &#44536;&#47548; &#44536;&#47532;&#44592; ($ star$) . &#50696;&#51228;1 . fig,ax = plt.subplots(1,3,figsize=(12,4)) ax[0].plot([1,2,4,3],&#39;--o&#39;) sns.scatterplot(x=x1,y=y1,ax=ax[1]) sns.scatterplot(x=x1,y=y1,ax=ax[2]) sns.scatterplot(x=x2,y=y2,ax=ax[2]) ax[2].plot([1,2,4,3],&#39;-r&#39;,lw=5) . [&lt;matplotlib.lines.Line2D at 0x7f6077de7c10&gt;] . &#50696;&#51228;2 . import cv2 . !wget https://upload.wikimedia.org/wikipedia/commons/0/08/Unequalized_Hawkes_Bay_NZ.jpg img = cv2.imread(&#39;Unequalized_Hawkes_Bay_NZ.jpg&#39;,0) !rm Unequalized_Hawkes_Bay_NZ.jpg . --2022-10-05 16:33:56-- https://upload.wikimedia.org/wikipedia/commons/0/08/Unequalized_Hawkes_Bay_NZ.jpg Resolving upload.wikimedia.org (upload.wikimedia.org)... 103.102.166.240, 2001:df2:e500:ed1a::2:b Connecting to upload.wikimedia.org (upload.wikimedia.org)|103.102.166.240|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 110895 (108K) [image/jpeg] Saving to: ‘Unequalized_Hawkes_Bay_NZ.jpg’ Unequalized_Hawkes_ 100%[===================&gt;] 108.30K 548KB/s in 0.2s 2022-10-05 16:33:57 (548 KB/s) - ‘Unequalized_Hawkes_Bay_NZ.jpg’ saved [110895/110895] . img2 = cv2.equalizeHist(img) . img.reshape(-1) . array([127, 145, 149, ..., 146, 145, 144], dtype=uint8) . fig,ax = plt.subplots(2,2,figsize=(10,5)) ax[0,0].imshow(img,vmin=0,vmax=255,cmap=&#39;gray&#39;) sns.histplot(img.reshape(-1),ax=ax[0,1],bins=15,lw=0,kde=True,color=&#39;C1&#39;) ax[0,1].set_xlim(0,255) ax[1,0].imshow(img2,vmin=0,vmax=255,cmap=&#39;gray&#39;) sns.histplot(img2.reshape(-1),ax=ax[1,1],bins=15,lw=0,kde=True,color=&#39;C1&#39;) . &lt;AxesSubplot:ylabel=&#39;Count&#39;&gt; . - seaborn: figure-level vs axes-level 의 개념 . ref: https://seaborn.pydata.org/tutorial/function_overview.html#figure-level-vs-axes-level-functions . mpl &#48120;&#49464;&#47676;&#51648;&#54017; (2) . &#52629; &#44036;&#44201;&#51312;&#51221; . import matplotlib as mpl . fig, ax = plt.subplots() ax.plot([(xi/30)**2 for xi in range(30)],&#39;--o&#39;) ax.xaxis.set_major_locator(mpl.ticker.MultipleLocator(3)) # 큰 눈금간격을 3으로 ax.xaxis.set_minor_locator(mpl.ticker.MultipleLocator(1)) # 작은 눈금간격을 1로 . &#52629; &#49325;&#51228; . fig, ax = plt.subplots() ax.plot([(xi/30)**2 for xi in range(30)],&#39;--o&#39;) ax.xaxis.set_major_locator(mpl.ticker.NullLocator()) # x축 눈금삭제 ax.yaxis.set_major_locator(mpl.ticker.NullLocator()) # y축 눈금삭제 . &#52629; &#48276;&#50948;&#51312;&#51221; . fig, ax = plt.subplots() ax.plot([(xi/30)**2 for xi in range(30)],&#39;--o&#39;) ax.set_ylim(-1,2) ax.set_xlim(-5,35) #plt.ylim(-1,2) #plt.xlim(-5,35) . (-5.0, 35.0) . gcf, gca . - gcf . plt.plot([1,2,3,2]) fig = plt.gcf() . fig.suptitle(&#39;suptitle&#39;) . Text(0.5, 0.98, &#39;suptitle&#39;) . fig . - gca . fig . ax = fig.gca() . ax.set_title(&#39;title&#39;) fig .",
            "url": "https://guebin.github.io/DV2022/2022/10/03/(5%EC%A3%BC%EC%B0%A8)-10%EC%9B%945%EC%9D%BC.html",
            "relUrl": "/2022/10/03/(5%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1)-10%E1%84%8B%E1%85%AF%E1%86%AF5%E1%84%8B%E1%85%B5%E1%86%AF.html",
            "date": " • Oct 3, 2022"
        }
        
    
  
    
        ,"post9": {
            "title": "(4주차) 9월28일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . imports . import seaborn as sns import matplotlib.pyplot as plt import numpy as np import pandas as pd . seaborn &#53945;&#51669; . - 특1: 입력으로 데이터프레임을 선호한다. (matplotlib은 array를 선호) . 그렇다고 해서 데이터프레임이 아닌 경우 그림이 아예 안 그려지지는 않는다. | 데이터프레임 형태는 long form 과 wide form 이 있다. (ref) // 참고로 long form이 더 우수한 저장형태에요! | wide-df = [array1,array2,array3] | long-df = [array_val, array_cat] | . - 특2: matplotlib을 존경함. (ref) . sns boxplot . - 데이터: 전북고등학교 . y1=[75,75,76,76,77,77,79,79,79,98] # A선생님에게 통계학을 배운 학생의 점수들 y2=[76,76,77,77,78,78,80,80,80,81] # B선생님에게 통계학을 배운 학생의 점수들 . plt &#48373;&#49845; . plt.boxplot([y1,y2]); . sns wide df . df1=pd.DataFrame({1:y1,2:y2}) df1 . 1 2 . 0 75 | 76 | . 1 75 | 76 | . 2 76 | 77 | . 3 76 | 77 | . 4 77 | 78 | . 5 77 | 78 | . 6 79 | 80 | . 7 79 | 80 | . 8 79 | 80 | . 9 98 | 81 | . - 예시1 . sns.boxplot(data=df1) #sns.boxplot(data=np.stack([y1,y2],axis=1)) # &lt;- 잘 쓰진 않아요, 그냥 심심해서 해봤는데 되더라고요..? . &lt;AxesSubplot:&gt; . sns long df . df2=pd.DataFrame({&#39;score&#39;:y1+y2,&#39;class&#39;:[&#39;A&#39;]*len(y1)+[&#39;B&#39;]*len(y2)}) df2 . score class . 0 75 | A | . 1 75 | A | . 2 76 | A | . 3 76 | A | . 4 77 | A | . 5 77 | A | . 6 79 | A | . 7 79 | A | . 8 79 | A | . 9 98 | A | . 10 76 | B | . 11 76 | B | . 12 77 | B | . 13 77 | B | . 14 78 | B | . 15 78 | B | . 16 80 | B | . 17 80 | B | . 18 80 | B | . 19 81 | B | . - 예시1 . sns.boxplot(data=df2,x=&#39;class&#39;,y=&#39;score&#39;) . &lt;AxesSubplot:xlabel=&#39;class&#39;, ylabel=&#39;score&#39;&gt; . sns: array . - 예시1 . sns.boxplot(data=y1) . &lt;AxesSubplot:&gt; . - 예시2 . sns.boxplot(y=y1) . &lt;AxesSubplot:&gt; . - 예시3 . sns.boxplot(x=y1) . &lt;AxesSubplot:&gt; . sns histplot . - 데이터 . x= np.random.randn(10000) y= np.random.randn(10000) +1 . plt &#48373;&#49845; . - 예시1 . plt.hist(x,alpha=0.5) plt.hist(y,alpha=0.5); . - 예시2 . plt.hist([x,y]); . sns: wide df . df1=pd.DataFrame({&#39;x&#39;:x,&#39;y&#39;:y}) df1 . x y . 0 -2.110587 | 0.712687 | . 1 0.176404 | 1.587615 | . 2 0.592212 | 0.362025 | . 3 0.957655 | 0.485939 | . 4 1.689412 | 0.582304 | . ... ... | ... | . 9995 -0.935895 | 0.047778 | . 9996 1.521599 | 1.946658 | . 9997 -0.595255 | 0.671715 | . 9998 0.952991 | 2.263997 | . 9999 0.850642 | 1.578771 | . 10000 rows × 2 columns . - 예시1 . sns.histplot(data=df1) . &lt;AxesSubplot:ylabel=&#39;Count&#39;&gt; . - 예시2 . sns.histplot(data=df1,bins=20) . &lt;AxesSubplot:ylabel=&#39;Count&#39;&gt; . - 예시3 . sns.histplot(data=df1,bins=20,kde=True) . &lt;AxesSubplot:ylabel=&#39;Count&#39;&gt; . - 예시4 . sns.histplot(data=df1,bins=20,kde=True,element=&quot;step&quot;) . &lt;AxesSubplot:ylabel=&#39;Count&#39;&gt; . - 예시5 . sns.histplot(data=df1,bins=20,kde=True,element=&quot;step&quot;,lw=5) # mpl에 대한 존경심 확인 . &lt;AxesSubplot:ylabel=&#39;Count&#39;&gt; . sns: long df . df2=pd.DataFrame({&#39;val&#39;:np.concatenate([x,y]), &#39;var&#39;:[&#39;x&#39;]*len(x) + [&#39;y&#39;]*len(y)}) df2 . val var . 0 -2.110587 | x | . 1 0.176404 | x | . 2 0.592212 | x | . 3 0.957655 | x | . 4 1.689412 | x | . ... ... | ... | . 19995 0.047778 | y | . 19996 1.946658 | y | . 19997 0.671715 | y | . 19998 2.263997 | y | . 19999 1.578771 | y | . 20000 rows × 2 columns . - 예시1 . sns.histplot(data=df2,x=&#39;val&#39;,hue=&#39;var&#39;,bins=20,kde=True,lw=0) . &lt;AxesSubplot:xlabel=&#39;val&#39;, ylabel=&#39;Count&#39;&gt; . - 예시2 . sns.histplot(data=df2,y=&#39;val&#39;,hue=&#39;var&#39;,bins=20,lw=0,kde=True) . &lt;AxesSubplot:xlabel=&#39;Count&#39;, ylabel=&#39;val&#39;&gt; . sns: array . - 예시1 . sns.histplot(data=x) . &lt;AxesSubplot:ylabel=&#39;Count&#39;&gt; . - 예시2 . sns.histplot(x=x) . &lt;AxesSubplot:ylabel=&#39;Count&#39;&gt; . - 예시3 . sns.histplot(x=x,color=&#39;C0&#39;,bins=20,lw=0) sns.histplot(x=y,color=&#39;C1&#39;,bins=20,lw=0) . &lt;AxesSubplot:ylabel=&#39;Count&#39;&gt; . sns lineplot . - data . np.random.seed(43052) ϵ = np.random.randn(100) . y = np.cumsum(ϵ) . plt &#48373;&#49845; . plt.plot(ϵ,&#39;--o&#39;) . [&lt;matplotlib.lines.Line2D at 0x7fd4f71b9810&gt;] . plt.plot(y,&#39;--o&#39;) . [&lt;matplotlib.lines.Line2D at 0x7fd4f7131950&gt;] . sns: array . - 예시1 . sns.lineplot(data=ϵ) . &lt;AxesSubplot:&gt; . - 예시2 . sns.lineplot(data=y) . &lt;AxesSubplot:&gt; . sns: wide df . df1=pd.DataFrame({&#39;eps&#39;:ϵ, &#39;y&#39;:y}) df1 . eps y . 0 0.383420 | 0.383420 | . 1 1.084175 | 1.467595 | . 2 1.142778 | 2.610373 | . 3 0.307894 | 2.918267 | . 4 0.237787 | 3.156054 | . ... ... | ... | . 95 1.308688 | -10.598788 | . 96 0.405376 | -10.193412 | . 97 -0.185070 | -10.378481 | . 98 1.055388 | -9.323094 | . 99 1.187014 | -8.136079 | . 100 rows × 2 columns . - 예시1 . sns.lineplot(data=df1) . &lt;AxesSubplot:&gt; . - 예시2 . sns.lineplot(data=df1,dashes=False) . &lt;AxesSubplot:&gt; . - 예시3 . # sns.lineplot(data=df1,dashes=[(3,1),(3,1)]) # 이코드는 최신버전의 sns에서 동작하지 않으므로 삭제합니다. (collab 에서는 정상동작) . - 예시4 . # sns.lineplot(data=df1,dashes=[(3,1),(15,3)],markers=[&#39;o&#39;,&#39;o&#39;]) # 이코드는 최신버전의 sns에서 동작하지 않으므로 삭제합니다. (collab 에서는 정상동작) . sns: long df . df2= pd.DataFrame({&#39;idx&#39;:list(range(100))*2,&#39;val&#39;:np.concatenate([ϵ,y]),&#39;cat&#39;:[&#39;eps&#39;]*100 + [&#39;y&#39;]*100 }) df2 . idx val cat . 0 0 | 0.383420 | eps | . 1 1 | 1.084175 | eps | . 2 2 | 1.142778 | eps | . 3 3 | 0.307894 | eps | . 4 4 | 0.237787 | eps | . ... ... | ... | ... | . 195 95 | -10.598788 | y | . 196 96 | -10.193412 | y | . 197 97 | -10.378481 | y | . 198 98 | -9.323094 | y | . 199 99 | -8.136079 | y | . 200 rows × 3 columns . - 예시1 . sns.lineplot(data=df2, x=&#39;idx&#39;,y=&#39;val&#39;,hue=&#39;cat&#39;) . &lt;AxesSubplot:xlabel=&#39;idx&#39;, ylabel=&#39;val&#39;&gt; . - 예시2 . sns.lineplot(data=df2, x=&#39;idx&#39;,y=&#39;val&#39;,style=&#39;cat&#39;,hue=&#39;cat&#39;,markers=True) . &lt;AxesSubplot:xlabel=&#39;idx&#39;, ylabel=&#39;val&#39;&gt; . - 예시3 . sns.lineplot(data=df2, x=&#39;idx&#39;,y=&#39;val&#39;,style=&#39;cat&#39;,hue=&#39;cat&#39;,dashes=[(3,1),(3,3)],markers=[&#39;o&#39;,&#39;o&#39;]) . &lt;AxesSubplot:xlabel=&#39;idx&#39;, ylabel=&#39;val&#39;&gt; . &#49689;&#51228; . - 아래의 그림에 대응하는 그림을 seaborn을 이용하여 그려라. . y1 = np.random.randn(90).cumsum() y2 = np.random.randn(120).cumsum() . plt.plot(y1,&#39;--o&#39;) plt.plot(y2,&#39;--o&#39;) . [&lt;matplotlib.lines.Line2D at 0x7fd4f3172210&gt;] .",
            "url": "https://guebin.github.io/DV2022/2022/09/28/(4%EC%A3%BC%EC%B0%A8)-9%EC%9B%9428%EC%9D%BC.html",
            "relUrl": "/2022/09/28/(4%EC%A3%BC%EC%B0%A8)-9%EC%9B%9428%EC%9D%BC.html",
            "date": " • Sep 28, 2022"
        }
        
    
  
    
        ,"post10": {
            "title": "(4주차) 9월28일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . imports . import seaborn as sns import matplotlib.pyplot as plt import numpy as np import pandas as pd . seaborn &#53945;&#51669; . - 특1: 입력으로 데이터프레임을 선호한다. (matplotlib은 array를 선호) . 그렇다고 해서 데이터프레임이 아닌 경우 그림이 아예 안 그려지지는 않는다. | 데이터프레임 형태는 long form 과 wide form 이 있다. (ref) // 참고로 long form이 더 우수한 저장형태에요! | wide-df = [array1,array2,array3] | long-df = [array_val, array_cat] | . - 특2: matplotlib을 존경함. (ref) . sns boxplot . - 데이터: 전북고등학교 . y1=[75,75,76,76,77,77,79,79,79,98] # A선생님에게 통계학을 배운 학생의 점수들 y2=[76,76,77,77,78,78,80,80,80,81] # B선생님에게 통계학을 배운 학생의 점수들 . plt &#48373;&#49845; . plt.boxplot([y1,y2]); . sns wide df . df1=pd.DataFrame({1:y1,2:y2}) df1 . 1 2 . 0 75 | 76 | . 1 75 | 76 | . 2 76 | 77 | . 3 76 | 77 | . 4 77 | 78 | . 5 77 | 78 | . 6 79 | 80 | . 7 79 | 80 | . 8 79 | 80 | . 9 98 | 81 | . - 예시1 . sns.boxplot(data=df1) #sns.boxplot(data=np.stack([y1,y2],axis=1)) # &lt;- 잘 쓰진 않아요, 그냥 심심해서 해봤는데 되더라고요..? . &lt;AxesSubplot:&gt; . sns long df . df2=pd.DataFrame({&#39;score&#39;:y1+y2,&#39;class&#39;:[&#39;A&#39;]*len(y1)+[&#39;B&#39;]*len(y2)}) df2 . score class . 0 75 | A | . 1 75 | A | . 2 76 | A | . 3 76 | A | . 4 77 | A | . 5 77 | A | . 6 79 | A | . 7 79 | A | . 8 79 | A | . 9 98 | A | . 10 76 | B | . 11 76 | B | . 12 77 | B | . 13 77 | B | . 14 78 | B | . 15 78 | B | . 16 80 | B | . 17 80 | B | . 18 80 | B | . 19 81 | B | . - 예시1 . sns.boxplot(data=df2,x=&#39;class&#39;,y=&#39;score&#39;) . &lt;AxesSubplot:xlabel=&#39;class&#39;, ylabel=&#39;score&#39;&gt; . sns: array . - 예시1 . sns.boxplot(data=y1) . &lt;AxesSubplot:&gt; . - 예시2 . sns.boxplot(y=y1) . &lt;AxesSubplot:&gt; . - 예시3 . sns.boxplot(x=y1) . &lt;AxesSubplot:&gt; . sns histplot . - 데이터 . x= np.random.randn(10000) y= np.random.randn(10000) +1 . plt &#48373;&#49845; . - 예시1 . plt.hist(x,alpha=0.5) plt.hist(y,alpha=0.5); . - 예시2 . plt.hist([x,y]); . sns: wide df . df1=pd.DataFrame({&#39;x&#39;:x,&#39;y&#39;:y}) df1 . x y . 0 -2.110587 | 0.712687 | . 1 0.176404 | 1.587615 | . 2 0.592212 | 0.362025 | . 3 0.957655 | 0.485939 | . 4 1.689412 | 0.582304 | . ... ... | ... | . 9995 -0.935895 | 0.047778 | . 9996 1.521599 | 1.946658 | . 9997 -0.595255 | 0.671715 | . 9998 0.952991 | 2.263997 | . 9999 0.850642 | 1.578771 | . 10000 rows × 2 columns . - 예시1 . sns.histplot(data=df1) . &lt;AxesSubplot:ylabel=&#39;Count&#39;&gt; . - 예시2 . sns.histplot(data=df1,bins=20) . &lt;AxesSubplot:ylabel=&#39;Count&#39;&gt; . - 예시3 . sns.histplot(data=df1,bins=20,kde=True) . &lt;AxesSubplot:ylabel=&#39;Count&#39;&gt; . - 예시4 . sns.histplot(data=df1,bins=20,kde=True,element=&quot;step&quot;) . &lt;AxesSubplot:ylabel=&#39;Count&#39;&gt; . - 예시5 . sns.histplot(data=df1,bins=20,kde=True,element=&quot;step&quot;,lw=5) # mpl에 대한 존경심 확인 . &lt;AxesSubplot:ylabel=&#39;Count&#39;&gt; . sns: long df . df2=pd.DataFrame({&#39;val&#39;:np.concatenate([x,y]), &#39;var&#39;:[&#39;x&#39;]*len(x) + [&#39;y&#39;]*len(y)}) df2 . val var . 0 -2.110587 | x | . 1 0.176404 | x | . 2 0.592212 | x | . 3 0.957655 | x | . 4 1.689412 | x | . ... ... | ... | . 19995 0.047778 | y | . 19996 1.946658 | y | . 19997 0.671715 | y | . 19998 2.263997 | y | . 19999 1.578771 | y | . 20000 rows × 2 columns . - 예시1 . sns.histplot(data=df2,x=&#39;val&#39;,hue=&#39;var&#39;,bins=20,kde=True,lw=0) . &lt;AxesSubplot:xlabel=&#39;val&#39;, ylabel=&#39;Count&#39;&gt; . - 예시2 . sns.histplot(data=df2,y=&#39;val&#39;,hue=&#39;var&#39;,bins=20,lw=0,kde=True) . &lt;AxesSubplot:xlabel=&#39;Count&#39;, ylabel=&#39;val&#39;&gt; . sns: array . - 예시1 . sns.histplot(data=x) . &lt;AxesSubplot:ylabel=&#39;Count&#39;&gt; . - 예시2 . sns.histplot(x=x) . &lt;AxesSubplot:ylabel=&#39;Count&#39;&gt; . - 예시3 . sns.histplot(x=x,color=&#39;C0&#39;,bins=20,lw=0) sns.histplot(x=y,color=&#39;C1&#39;,bins=20,lw=0) . &lt;AxesSubplot:ylabel=&#39;Count&#39;&gt; . sns lineplot . - data . np.random.seed(43052) ϵ = np.random.randn(100) . y = np.cumsum(ϵ) . plt &#48373;&#49845; . plt.plot(ϵ,&#39;--o&#39;) . [&lt;matplotlib.lines.Line2D at 0x7fd4f71b9810&gt;] . plt.plot(y,&#39;--o&#39;) . [&lt;matplotlib.lines.Line2D at 0x7fd4f7131950&gt;] . sns: array . - 예시1 . sns.lineplot(data=ϵ) . &lt;AxesSubplot:&gt; . - 예시2 . sns.lineplot(data=y) . &lt;AxesSubplot:&gt; . sns: wide df . df1=pd.DataFrame({&#39;eps&#39;:ϵ, &#39;y&#39;:y}) df1 . eps y . 0 0.383420 | 0.383420 | . 1 1.084175 | 1.467595 | . 2 1.142778 | 2.610373 | . 3 0.307894 | 2.918267 | . 4 0.237787 | 3.156054 | . ... ... | ... | . 95 1.308688 | -10.598788 | . 96 0.405376 | -10.193412 | . 97 -0.185070 | -10.378481 | . 98 1.055388 | -9.323094 | . 99 1.187014 | -8.136079 | . 100 rows × 2 columns . - 예시1 . sns.lineplot(data=df1) . &lt;AxesSubplot:&gt; . - 예시2 . sns.lineplot(data=df1,dashes=False) . &lt;AxesSubplot:&gt; . - 예시3 . # sns.lineplot(data=df1,dashes=[(3,1),(3,1)]) # 이코드는 최신버전의 sns에서 동작하지 않으므로 삭제합니다. (collab 에서는 정상동작) . - 예시4 . # sns.lineplot(data=df1,dashes=[(3,1),(15,3)],markers=[&#39;o&#39;,&#39;o&#39;]) # 이코드는 최신버전의 sns에서 동작하지 않으므로 삭제합니다. (collab 에서는 정상동작) . sns: long df . df2= pd.DataFrame({&#39;idx&#39;:list(range(100))*2,&#39;val&#39;:np.concatenate([ϵ,y]),&#39;cat&#39;:[&#39;eps&#39;]*100 + [&#39;y&#39;]*100 }) df2 . idx val cat . 0 0 | 0.383420 | eps | . 1 1 | 1.084175 | eps | . 2 2 | 1.142778 | eps | . 3 3 | 0.307894 | eps | . 4 4 | 0.237787 | eps | . ... ... | ... | ... | . 195 95 | -10.598788 | y | . 196 96 | -10.193412 | y | . 197 97 | -10.378481 | y | . 198 98 | -9.323094 | y | . 199 99 | -8.136079 | y | . 200 rows × 3 columns . - 예시1 . sns.lineplot(data=df2, x=&#39;idx&#39;,y=&#39;val&#39;,hue=&#39;cat&#39;) . &lt;AxesSubplot:xlabel=&#39;idx&#39;, ylabel=&#39;val&#39;&gt; . - 예시2 . sns.lineplot(data=df2, x=&#39;idx&#39;,y=&#39;val&#39;,style=&#39;cat&#39;,hue=&#39;cat&#39;,markers=True) . &lt;AxesSubplot:xlabel=&#39;idx&#39;, ylabel=&#39;val&#39;&gt; . - 예시3 . sns.lineplot(data=df2, x=&#39;idx&#39;,y=&#39;val&#39;,style=&#39;cat&#39;,hue=&#39;cat&#39;,dashes=[(3,1),(3,3)],markers=[&#39;o&#39;,&#39;o&#39;]) . &lt;AxesSubplot:xlabel=&#39;idx&#39;, ylabel=&#39;val&#39;&gt; . &#49689;&#51228; . - 아래의 그림에 대응하는 그림을 seaborn을 이용하여 그려라. . y1 = np.random.randn(90).cumsum() y2 = np.random.randn(120).cumsum() . plt.plot(y1,&#39;--o&#39;) plt.plot(y2,&#39;--o&#39;) . [&lt;matplotlib.lines.Line2D at 0x7fd4f3172210&gt;] .",
            "url": "https://guebin.github.io/DV2022/2022/09/28/(4%EC%A3%BC%EC%B0%A8)-9%EC%9B%9428%EC%9D%BC.html",
            "relUrl": "/2022/09/28/(4%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1)-9%E1%84%8B%E1%85%AF%E1%86%AF28%E1%84%8B%E1%85%B5%E1%86%AF.html",
            "date": " • Sep 28, 2022"
        }
        
    
  
    
        ,"post11": {
            "title": "(4주차) 9월26일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . imports . import matplotlib.pyplot as plt import numpy as np import pandas as pd . &#49328;&#51216;&#46020; &#51025;&#50857;&#50696;&#51228; 4 (&#47924;&#49345;&#44288;&#44284; &#46021;&#47549;) . &#50696;&#51228;&#51088;&#47308; . 예시1: 사각형 . x1 = np.random.uniform(low=-1,high=1,size=10000) y1 = np.random.uniform(low=-1,high=1,size=10000) . plt.plot(x1,y1,&#39;,&#39;) . [&lt;matplotlib.lines.Line2D at 0x7efe739fa410&gt;] . 예시2: 원 . _r2 = x1**2+y1**2 . x2=x1[_r2&lt;1] y2=y1[_r2&lt;1] . plt.plot(x2,y2,&#39;,&#39;) . [&lt;matplotlib.lines.Line2D at 0x7efe73ae5410&gt;] . 예시3: 이변량정규분포 . x3 = np.random.randn(10000) y3 = np.random.randn(10000) . plt.plot(x3,y3,&#39;,&#39;) . [&lt;matplotlib.lines.Line2D at 0x7efe7396aad0&gt;] . &#49345;&#44288;&#44228;&#49688; . - 예시1, 예시2, 예시3의 산점도를 보고 상관계수가 얼마인지 예상해보라. 실제 계산결과와 확인하라. . np.corrcoef([x1,y1]) . array([[ 1. , -0.00255095], [-0.00255095, 1. ]]) . np.corrcoef([x2,y2]) . array([[ 1. , -0.01437794], [-0.01437794, 1. ]]) . np.corrcoef([x3,y3]) . array([[ 1. , -0.02282708], [-0.02282708, 1. ]]) . &#46021;&#47549; . - 예시1,2,3 중 독립인것은 무엇인가? . - 예시1 vs 예시2 . fig, ax = plt.subplots(1,2,figsize=(8,4)) ax[0].plot(x1,y1,&#39;,&#39;,color=&#39;gray&#39;) ax[1].plot(x2,y2,&#39;,&#39;,color=&#39;gray&#39;) . [&lt;matplotlib.lines.Line2D at 0x7efe69fbf750&gt;] . def g(intval, data, ax, col = &#39;r&#39;): a,b = intval x,y = data idx = (a&lt;x)&amp;(x&lt;b) ax.plot(x[idx],y[idx],&#39;,&#39;,color=col) . g([-0.1,0.1],[x1,y1],ax[0]) g([-0.1,0.1],[x2,y2],ax[1]) fig . g([0.79,0.99],[x1,y1],ax[0],col=&#39;b&#39;) g([0.79,0.99],[x2,y2],ax[1],col=&#39;b&#39;) fig . - 예시3 . fig,ax = plt.subplots() ax.plot(x3,y3,&#39;,&#39;,color=&#39;gray&#39;) . [&lt;matplotlib.lines.Line2D at 0x7efe695e41d0&gt;] . g([-2.5,-1.5],[x3,y3],ax,col=&#39;r&#39;) g([-0.5,+0.5],[x3,y3],ax,col=&#39;b&#39;) g([+1.5,+2.5],[x3,y3],ax,col=&#39;g&#39;) fig . def h(intval, data, ax, col): a,b = intval x,y = data idx = (a&lt;x) &amp; (x&lt;b) ax.hist(y[idx],color=col) . fig,ax = plt.subplots(5,2,figsize=(8,16)) ax[0,0].plot(x3,y3,&#39;,&#39;,color=&#39;gray&#39;); g([-2.5,-1.5],[x3,y3],ax[0,0],col=&#39;r&#39;) ax[1,0].plot(x3,y3,&#39;,&#39;,color=&#39;gray&#39;); g([-1.5,-0.5],[x3,y3],ax[1,0],col=&#39;g&#39;) ax[2,0].plot(x3,y3,&#39;,&#39;,color=&#39;gray&#39;); g([-0.5,+0.5],[x3,y3],ax[2,0],col=&#39;b&#39;) ax[3,0].plot(x3,y3,&#39;,&#39;,color=&#39;gray&#39;); g([+0.5,+1.5],[x3,y3],ax[3,0],col=&#39;m&#39;) ax[4,0].plot(x3,y3,&#39;,&#39;,color=&#39;gray&#39;); g([+1.5,+2.5],[x3,y3],ax[4,0],col=&#39;lime&#39;) h([-2.5,-1.5],[x3,y3],ax[0,1],col=&#39;r&#39;) h([-1.5,-0.5],[x3,y3],ax[1,1],col=&#39;g&#39;) h([-0.5,+0.5],[x3,y3],ax[2,1],col=&#39;b&#39;) h([+0.5,+1.5],[x3,y3],ax[3,1],col=&#39;m&#39;) h([+1.5,+2.5],[x3,y3],ax[4,1],col=&#39;lime&#39;) . mpl&#50640; &#45824;&#54620; &#48120;&#49464;&#47676;&#51648; &#54017; (1) . &#44536;&#47548;&#47564; &#48372;&#44256; &#49910;&#51012;&#46412; . plt.plot([1,2,3,4],[2,3,4,5]); . marker size, line width . plt.plot([1,2,3,4],[2,3,4,2],&#39;o&#39;,ms=10) . [&lt;matplotlib.lines.Line2D at 0x7f5883561350&gt;] . plt.plot([1,2,3,4],[2,3,4,5],&#39;--&#39;,lw=10) . [&lt;matplotlib.lines.Line2D at 0x7f5883c04ed0&gt;] . label + legend . plt.plot([1,2,3,4],[1,2,3,2],&#39;--o&#39;,label=&#39;A&#39;) plt.plot([1,2,3,4],[3,2.1,1,3],&#39;--o&#39;,label=&#39;B&#39;) plt.legend() . &lt;matplotlib.legend.Legend at 0x7f5889ead210&gt; . &#49353;&#44628;&#51312;&#51221; (C0,C1,...) . plt.plot([1,2,3,4],[1,2,3,2],&#39;--o&#39;,label=&#39;A&#39;,color=&#39;C1&#39;) plt.plot([1,2,3,4],[3,2.1,1,3],&#39;--o&#39;,label=&#39;B&#39;,color=&#39;C0&#39;) plt.legend() . &lt;matplotlib.legend.Legend at 0x7f588a29ef10&gt; . title &#49444;&#51221; . - (방법1) . plt.plot([1,2,3,4],[1,2,3,2],&#39;--o&#39;,label=&#39;A&#39;,color=&#39;C1&#39;) plt.plot([1,2,3,4],[3,2.1,1,3],&#39;--o&#39;,label=&#39;B&#39;,color=&#39;C0&#39;) plt.legend() plt.title(&#39;title&#39;) . Text(0.5, 1.0, &#39;title&#39;) . - (방법2) . fig, ax = plt.subplots() ax.plot([1,2,3,4],[1,2,3,2],&#39;--o&#39;,label=&#39;A&#39;,color=&#39;C1&#39;) ax.plot([1,2,3,4],[3,2.1,1,3],&#39;--o&#39;,label=&#39;B&#39;,color=&#39;C0&#39;) ax.legend() ax.set_title(&#39;title&#39;) . Text(0.5, 1.0, &#39;title&#39;) . suptitle &#49444;&#51221; . fig, ax = plt.subplots(2,2) ax[0,0].plot([1,2,3,2],&#39;--o&#39;,label=&#39;A&#39;,color=&#39;C0&#39;) ax[0,0].set_title(&#39;(a)&#39;) ax[0,1].plot([3,2.1,1,3],&#39;--o&#39;,label=&#39;B&#39;,color=&#39;C1&#39;) ax[0,1].set_title(&#39;(b)&#39;) ax[1,0].plot([-3,-2.1,-1,-3],&#39;--o&#39;,label=&#39;B&#39;,color=&#39;C2&#39;) ax[1,0].set_title(&#39;(c)&#39;) ax[1,1].plot([3,-2.1,1,-3],&#39;--o&#39;,label=&#39;B&#39;,color=&#39;C3&#39;) ax[1,1].set_title(&#39;(d)&#39;) #plt.suptitle(&#39;suptitle&#39;) fig.suptitle(&#39;suptitle&#39;) . Text(0.5, 0.98, &#39;suptitle&#39;) . tight_layout() . fig . fig.tight_layout() . fig . fig, ax, plt &#49548;&#49549; . - 일단 그림 하나 그리고 이야기좀 해보자. . fig, ax = plt.subplots() ax.plot([1,2,3,1]) . [&lt;matplotlib.lines.Line2D at 0x7efe4bdd9950&gt;] . - fig에는 있고 ax에는 없는 것 . add_axes, tight_layout, suptitle, ... . - ax에는 있고 fig에는 없는 것 . boxplot, hist, plot, set_title, ... . - plt는 대부분 다 있음. (의미상 명확한건 대충 알아서 fig, ax에 접근해서 처리해준다) . plt.tight_layout, plt.suptitle, plt.boxplot, plt.hist, plot.plot | plt.set_title 은 없지만 plt.title 은 있음 | plt.add_axes 는 없음.. | . x&#52629;, y&#52629; label &#49444;&#51221; . ax.xaxis.set_label_text(&#39;xlabel&#39;,size=16,family=&#39;serif&#39;,weight=1000,style=&#39;italic&#39;) #_fontsettings={&#39;size&#39;:16,&#39;family&#39;:&#39;serif&#39;,&#39;weight&#39;=1000,&#39;style&#39;:&#39;italic&#39;} #ax.xaxis.set_label_text(&#39;xlabel&#39;,_fontsettings) fig . 폰트ref . size: | fontweight: 0~1000 | family: &#39;serif&#39;, &#39;sans-serif&#39;, &#39;monospace&#39; | style: &#39;normal&#39;, &#39;italic&#39; | . ax.set_ylabel(&#39;ylabel&#39;,size=16) fig . &#49689;&#51228; (&#45212;&#51060;&#46020; &#49345;) -- &#45796;&#51020;&#49884;&#44036;&#50640; &#54400;&#50612;&#51460;&#44144;&#50640;&#50836; . 아래와 같이 표준정규분포에서 100개의 난수를 생성하여 $ boldsymbol{ epsilon}=( epsilon_1, epsilon_2, dots, epsilon_{100})$ 와 같은 벡터를 만들었다고 하자. . np.random.seed(43052) ϵ = np.random.randn(100) . 아래는 $(t, epsilon_t)$를 그린 그림이다. (단 $t=1,2, dots,100$) . plt.plot(np.arange(1,101),ϵ,&#39;--o&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f59b74466d0&gt;] . (1) $ epsilon_t$ 와 $ epsilon_{t-1}$은 독립이라고 보여지는가? . (2) 아래의 수식을 만족하는 벡터 ${ boldsymbol y} = (y_1,y_2, dots, y_{100})$ 을 생성하라. (단 $y_1= epsilon_1$) . $$ y_t = y_{t-1} + epsilon_t$$ . (3) $(t,y_t)$의 dot-connected plot을 그려라. . # 아래와 같은 그림이 나와야 한다. . [&lt;matplotlib.lines.Line2D at 0x7f59b8f81850&gt;] . (4) $y_t$와 $y_{t-1}$은 독립이라고 볼 수 있는가? .",
            "url": "https://guebin.github.io/DV2022/2022/09/26/(4%EC%A3%BC%EC%B0%A8)-9%EC%9B%9426%EC%9D%BC.html",
            "relUrl": "/2022/09/26/(4%EC%A3%BC%EC%B0%A8)-9%EC%9B%9426%EC%9D%BC.html",
            "date": " • Sep 26, 2022"
        }
        
    
  
    
        ,"post12": {
            "title": "(4주차) 9월26일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . imports . import matplotlib.pyplot as plt import numpy as np import pandas as pd . &#49328;&#51216;&#46020; &#51025;&#50857;&#50696;&#51228; 4 (&#47924;&#49345;&#44288;&#44284; &#46021;&#47549;) . &#50696;&#51228;&#51088;&#47308; . 예시1: 사각형 . x1 = np.random.uniform(low=-1,high=1,size=10000) y1 = np.random.uniform(low=-1,high=1,size=10000) . plt.plot(x1,y1,&#39;,&#39;) . [&lt;matplotlib.lines.Line2D at 0x7efe739fa410&gt;] . 예시2: 원 . _r2 = x1**2+y1**2 . x2=x1[_r2&lt;1] y2=y1[_r2&lt;1] . plt.plot(x2,y2,&#39;,&#39;) . [&lt;matplotlib.lines.Line2D at 0x7efe73ae5410&gt;] . 예시3: 이변량정규분포 . x3 = np.random.randn(10000) y3 = np.random.randn(10000) . plt.plot(x3,y3,&#39;,&#39;) . [&lt;matplotlib.lines.Line2D at 0x7efe7396aad0&gt;] . &#49345;&#44288;&#44228;&#49688; . - 예시1, 예시2, 예시3의 산점도를 보고 상관계수가 얼마인지 예상해보라. 실제 계산결과와 확인하라. . np.corrcoef([x1,y1]) . array([[ 1. , -0.00255095], [-0.00255095, 1. ]]) . np.corrcoef([x2,y2]) . array([[ 1. , -0.01437794], [-0.01437794, 1. ]]) . np.corrcoef([x3,y3]) . array([[ 1. , -0.02282708], [-0.02282708, 1. ]]) . &#46021;&#47549; . - 예시1,2,3 중 독립인것은 무엇인가? . - 예시1 vs 예시2 . fig, ax = plt.subplots(1,2,figsize=(8,4)) ax[0].plot(x1,y1,&#39;,&#39;,color=&#39;gray&#39;) ax[1].plot(x2,y2,&#39;,&#39;,color=&#39;gray&#39;) . [&lt;matplotlib.lines.Line2D at 0x7efe69fbf750&gt;] . def g(intval, data, ax, col = &#39;r&#39;): a,b = intval x,y = data idx = (a&lt;x)&amp;(x&lt;b) ax.plot(x[idx],y[idx],&#39;,&#39;,color=col) . g([-0.1,0.1],[x1,y1],ax[0]) g([-0.1,0.1],[x2,y2],ax[1]) fig . g([0.79,0.99],[x1,y1],ax[0],col=&#39;b&#39;) g([0.79,0.99],[x2,y2],ax[1],col=&#39;b&#39;) fig . - 예시3 . fig,ax = plt.subplots() ax.plot(x3,y3,&#39;,&#39;,color=&#39;gray&#39;) . [&lt;matplotlib.lines.Line2D at 0x7efe695e41d0&gt;] . g([-2.5,-1.5],[x3,y3],ax,col=&#39;r&#39;) g([-0.5,+0.5],[x3,y3],ax,col=&#39;b&#39;) g([+1.5,+2.5],[x3,y3],ax,col=&#39;g&#39;) fig . def h(intval, data, ax, col): a,b = intval x,y = data idx = (a&lt;x) &amp; (x&lt;b) ax.hist(y[idx],color=col) . fig,ax = plt.subplots(5,2,figsize=(8,16)) ax[0,0].plot(x3,y3,&#39;,&#39;,color=&#39;gray&#39;); g([-2.5,-1.5],[x3,y3],ax[0,0],col=&#39;r&#39;) ax[1,0].plot(x3,y3,&#39;,&#39;,color=&#39;gray&#39;); g([-1.5,-0.5],[x3,y3],ax[1,0],col=&#39;g&#39;) ax[2,0].plot(x3,y3,&#39;,&#39;,color=&#39;gray&#39;); g([-0.5,+0.5],[x3,y3],ax[2,0],col=&#39;b&#39;) ax[3,0].plot(x3,y3,&#39;,&#39;,color=&#39;gray&#39;); g([+0.5,+1.5],[x3,y3],ax[3,0],col=&#39;m&#39;) ax[4,0].plot(x3,y3,&#39;,&#39;,color=&#39;gray&#39;); g([+1.5,+2.5],[x3,y3],ax[4,0],col=&#39;lime&#39;) h([-2.5,-1.5],[x3,y3],ax[0,1],col=&#39;r&#39;) h([-1.5,-0.5],[x3,y3],ax[1,1],col=&#39;g&#39;) h([-0.5,+0.5],[x3,y3],ax[2,1],col=&#39;b&#39;) h([+0.5,+1.5],[x3,y3],ax[3,1],col=&#39;m&#39;) h([+1.5,+2.5],[x3,y3],ax[4,1],col=&#39;lime&#39;) . mpl&#50640; &#45824;&#54620; &#48120;&#49464;&#47676;&#51648; &#54017; (1) . &#44536;&#47548;&#47564; &#48372;&#44256; &#49910;&#51012;&#46412; . plt.plot([1,2,3,4],[2,3,4,5]); . marker size, line width . plt.plot([1,2,3,4],[2,3,4,2],&#39;o&#39;,ms=10) . [&lt;matplotlib.lines.Line2D at 0x7f5883561350&gt;] . plt.plot([1,2,3,4],[2,3,4,5],&#39;--&#39;,lw=10) . [&lt;matplotlib.lines.Line2D at 0x7f5883c04ed0&gt;] . label + legend . plt.plot([1,2,3,4],[1,2,3,2],&#39;--o&#39;,label=&#39;A&#39;) plt.plot([1,2,3,4],[3,2.1,1,3],&#39;--o&#39;,label=&#39;B&#39;) plt.legend() . &lt;matplotlib.legend.Legend at 0x7f5889ead210&gt; . &#49353;&#44628;&#51312;&#51221; (C0,C1,...) . plt.plot([1,2,3,4],[1,2,3,2],&#39;--o&#39;,label=&#39;A&#39;,color=&#39;C1&#39;) plt.plot([1,2,3,4],[3,2.1,1,3],&#39;--o&#39;,label=&#39;B&#39;,color=&#39;C0&#39;) plt.legend() . &lt;matplotlib.legend.Legend at 0x7f588a29ef10&gt; . title &#49444;&#51221; . - (방법1) . plt.plot([1,2,3,4],[1,2,3,2],&#39;--o&#39;,label=&#39;A&#39;,color=&#39;C1&#39;) plt.plot([1,2,3,4],[3,2.1,1,3],&#39;--o&#39;,label=&#39;B&#39;,color=&#39;C0&#39;) plt.legend() plt.title(&#39;title&#39;) . Text(0.5, 1.0, &#39;title&#39;) . - (방법2) . fig, ax = plt.subplots() ax.plot([1,2,3,4],[1,2,3,2],&#39;--o&#39;,label=&#39;A&#39;,color=&#39;C1&#39;) ax.plot([1,2,3,4],[3,2.1,1,3],&#39;--o&#39;,label=&#39;B&#39;,color=&#39;C0&#39;) ax.legend() ax.set_title(&#39;title&#39;) . Text(0.5, 1.0, &#39;title&#39;) . suptitle &#49444;&#51221; . fig, ax = plt.subplots(2,2) ax[0,0].plot([1,2,3,2],&#39;--o&#39;,label=&#39;A&#39;,color=&#39;C0&#39;) ax[0,0].set_title(&#39;(a)&#39;) ax[0,1].plot([3,2.1,1,3],&#39;--o&#39;,label=&#39;B&#39;,color=&#39;C1&#39;) ax[0,1].set_title(&#39;(b)&#39;) ax[1,0].plot([-3,-2.1,-1,-3],&#39;--o&#39;,label=&#39;B&#39;,color=&#39;C2&#39;) ax[1,0].set_title(&#39;(c)&#39;) ax[1,1].plot([3,-2.1,1,-3],&#39;--o&#39;,label=&#39;B&#39;,color=&#39;C3&#39;) ax[1,1].set_title(&#39;(d)&#39;) #plt.suptitle(&#39;suptitle&#39;) fig.suptitle(&#39;suptitle&#39;) . Text(0.5, 0.98, &#39;suptitle&#39;) . tight_layout() . fig . fig.tight_layout() . fig . fig, ax, plt &#49548;&#49549; . - 일단 그림 하나 그리고 이야기좀 해보자. . fig, ax = plt.subplots() ax.plot([1,2,3,1]) . [&lt;matplotlib.lines.Line2D at 0x7efe4bdd9950&gt;] . - fig에는 있고 ax에는 없는 것 . add_axes, tight_layout, suptitle, ... . - ax에는 있고 fig에는 없는 것 . boxplot, hist, plot, set_title, ... . - plt는 대부분 다 있음. (의미상 명확한건 대충 알아서 fig, ax에 접근해서 처리해준다) . plt.tight_layout, plt.suptitle, plt.boxplot, plt.hist, plot.plot | plt.set_title 은 없지만 plt.title 은 있음 | plt.add_axes 는 없음.. | . x&#52629;, y&#52629; label &#49444;&#51221; . ax.xaxis.set_label_text(&#39;xlabel&#39;,size=16,family=&#39;serif&#39;,weight=1000,style=&#39;italic&#39;) #_fontsettings={&#39;size&#39;:16,&#39;family&#39;:&#39;serif&#39;,&#39;weight&#39;=1000,&#39;style&#39;:&#39;italic&#39;} #ax.xaxis.set_label_text(&#39;xlabel&#39;,_fontsettings) fig . 폰트ref . size: | fontweight: 0~1000 | family: &#39;serif&#39;, &#39;sans-serif&#39;, &#39;monospace&#39; | style: &#39;normal&#39;, &#39;italic&#39; | . ax.set_ylabel(&#39;ylabel&#39;,size=16) fig . &#49689;&#51228; (&#45212;&#51060;&#46020; &#49345;) -- &#45796;&#51020;&#49884;&#44036;&#50640; &#54400;&#50612;&#51460;&#44144;&#50640;&#50836; . 아래와 같이 표준정규분포에서 100개의 난수를 생성하여 $ boldsymbol{ epsilon}=( epsilon_1, epsilon_2, dots, epsilon_{100})$ 와 같은 벡터를 만들었다고 하자. . np.random.seed(43052) ϵ = np.random.randn(100) . 아래는 $(t, epsilon_t)$를 그린 그림이다. (단 $t=1,2, dots,100$) . plt.plot(np.arange(1,101),ϵ,&#39;--o&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f59b74466d0&gt;] . (1) $ epsilon_t$ 와 $ epsilon_{t-1}$은 독립이라고 보여지는가? . (2) 아래의 수식을 만족하는 벡터 ${ boldsymbol y} = (y_1,y_2, dots, y_{100})$ 을 생성하라. (단 $y_1= epsilon_1$) . $$ y_t = y_{t-1} + epsilon_t$$ . (3) $(t,y_t)$의 dot-connected plot을 그려라. . # 아래와 같은 그림이 나와야 한다. . [&lt;matplotlib.lines.Line2D at 0x7f59b8f81850&gt;] . (4) $y_t$와 $y_{t-1}$은 독립이라고 볼 수 있는가? .",
            "url": "https://guebin.github.io/DV2022/2022/09/26/(4%EC%A3%BC%EC%B0%A8)-9%EC%9B%9426%EC%9D%BC.html",
            "relUrl": "/2022/09/26/(4%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1)-9%E1%84%8B%E1%85%AF%E1%86%AF26%E1%84%8B%E1%85%B5%E1%86%AF.html",
            "date": " • Sep 26, 2022"
        }
        
    
  
    
        ,"post13": {
            "title": "(3주차) 9월21일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . imports . import matplotlib.pyplot as plt import numpy as np import plotly.express as px from IPython.display import HTML . &#49328;&#51216;&#46020; &#51025;&#50857;&#50696;&#51228;1 - &#54364;&#48376;&#49345;&#44288;&#44228;&#49688; . &#50696;&#51228;&#49548;&#44060; . - 아래와 같은 자료를 수집하였다고 하자. . 몸무게 = [44,48,49,58,62,68,69,70,76,79] | 키 = [159,160,162,165,167,162,165,175,165,172] | . x=[44,48,49,58,62,68,69,70,76,79] y=[159,160,162,165,167,162,165,175,165,172] . plt.plot(x,y,&#39;o&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f49354a0ad0&gt;] . 키가 큰 사람일수록 몸무게도 많이 나간다. (반대도 성립) | 키와 몸무게는 관계가 있어보인다. (정비례) | . - 얼만큼 정비례인지? . 이 질문에 대답하기 위해서는 상관계수의 개념을 알아야 한다. | 상관계수는 산점도에서 가장 중요한 개념중 하나. | . &#49345;&#44288;&#44228;&#49688;&#51032; &#51221;&#51032; . - (표본)상관계수 . $$r= frac{ sum_{i=1}^{n}(x_i- bar{x})(y_i- bar{y}) }{ sqrt{ sum_{i=1}^{n}(x_i- bar{x})^2 sum_{i=1}^{n}(y_i- bar{y})^2 }}= sum_{i=1}^{n} tilde{x}_i tilde{y}_i $$ . 단, $ tilde{x}_i= frac{(x_i- bar{x})}{ sqrt{ sum_{i=1}^n(x_i- bar{x})^2}}$, $ tilde{y}_i= frac{(y_i- bar{y})}{ sqrt{ sum_{i=1}^n(y_i- bar{y})^2}}$ | . * 표본의 의미 . 평균과 표본평균 . np.random.seed(43052) x = np.random.randn(10) x . array([ 0.38342049, 1.0841745 , 1.14277825, 0.30789368, 0.23778744, 0.35595116, -1.66307542, -1.38277318, -1.92684484, -1.4862163 ]) . x는 의 각 원소는 모두 평균이 0인 정규분포에서 추출했다고 표현 | . np.mean(x) . 0.09434107867212947 . ${ tt x}=(x_1, dots, x_{10})$의 표본평균은 ${ bar x}=0.09434107867212947$ 라고 표현 | . &#49345;&#44288;&#44228;&#49688;&#51032; &#51032;&#48120; . - 의미? . x=np.array(x) y=np.array(y) . fig, (ax1,ax2,ax3) = plt.subplots(1,3,figsize=(9,4)) . ax1.plot(x,y,&#39;o&#39;) ax2.plot(x-np.mean(x),y-np.mean(y),&#39;o&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f03567ef610&gt;] . fig . - $ tilde{x}_i$와 $ tilde{y}_i$를 계산하기 위해서 $a= sqrt{ sum_{i=1}^{n}(x_i- bar{x})^2}, b= sqrt{ sum_{i=1}^{n}(y_i- bar{y})^2}$를 계산하자. . (방법1) . a=np.sqrt(np.sum((x-np.mean(x))**2)) b=np.sqrt(np.sum((y-np.mean(y))**2)) a,b . (2.8842557251032446, 15.218409903797438) . 해석: $a&gt;b$ 이므로 $ {x_i }$들이 $ {y_i }$들 보다 좀 더 퍼져있다. (=평균근처에 몰려있지 않다) | . (방법2) . - 사실 $a,b$는 아래와 같이 계산할 수 있다. . $a= sqrt{n} times{ tt np.std(x)}$ . $b= sqrt{n} times{ tt np.std(y)}$ . n=len(x) np.sqrt(n)*np.std(x), np.sqrt(n)*np.std(y) . (2.8842557251032446, 15.21840990379744) . ${ tt np.std(x)}= sqrt{ frac{1}{n} sum_{i=1}^{n}(x_i- bar{x})^2}$ | ${ tt np.std(y)}= sqrt{ frac{1}{n} sum_{i=1}^{n}(y_i- bar{y})^2}$ | . . Note: ${ tt np.std(x,ddof=1)}= sqrt{ frac{1}{n-1} sum_{i=1}^{n}(x_i- bar{x})^2}$ . - 이제 $( tilde{x}_i, tilde{y}_i)$를 ax3에 그려보자. . xx= (x-np.mean(x))/a yy= (y-np.mean(y))/b ax3.plot(xx,yy,&#39;o&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f03567b4290&gt;] . fig . 질문: $r$의 값이 양수인가? 음수인가? . - plotly 사용하여 $( tilde{x}_i, tilde{y}_i)$를 그려보자. . fig=px.scatter(x=xx, y=yy) HTML(fig.to_html(include_plotlyjs=&#39;cdn&#39;,include_mathjax=False)) . . . $ tilde{x}_i$, $ tilde{y}_i$ 를 곱한값이 양수인것과 음수인것을 체크해보자. | 양수인쪽이 많은지 음수인쪽이 많은지 생각해보자. | $r= sum_{i=1}^{n} tilde{x}_i tilde{y}_i$ 의 부호는? | . &#44536;&#47548;&#51012; &#48372;&#44256; &#49345;&#44288;&#44228;&#49688;&#51032; &#48512;&#54840;&#47484; &#50508;&#50500;&#45236;&#45716; &#48169;&#48277; . - $(x_i,y_i)$의 산점도를 보고 $( tilde{x}_i, tilde{y}_i)$ 의 산점도를 상상 $ to$ 1,3 분면에 점들이 많으면 양수, 2,4 분면에 점들이 많으면 음수 . &#44536;&#47548;&#51012; &#48372;&#44256; &#49345;&#44288;&#44228;&#49688;&#51032; &#51208;&#45824;&#44050;&#51012; &#50508;&#50500;&#45236;&#45716; &#48169;&#48277; . - 이해를 위한 예시 . x=np.arange(0,10,0.1) y1=x+np.random.normal(loc=0,scale=1.0,size=len(x)) y2=x+np.random.normal(loc=0,scale=7.0,size=len(x)) . plt.plot(x,y1,&#39;o&#39;) plt.plot(x,y2,&#39;x&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f03566c0650&gt;] . 각 데이터셋의 표준상관계수를 각각 $r_1$(파란색), $r_2$(주황색)라고 하자. . (1) $r_1$, $r_2$의 부호는 양수인가? 음수인가? --&gt; 양수 . (2) $r_1,r_2$의 값중 어떠한 값이 더 절대값이 큰가? --&gt; 잘모르겠음. 따져보자. . def tilde(x): n= len(x) return (x-np.mean(x)) / (np.std(x)*np.sqrt(n)) . xx= tilde(x) yy1= tilde(y1) yy2= tilde(y2) . fig, ax = plt.subplots(1,2) ax[0].plot(x,y1,&#39;o&#39;) ax[0].plot(x,y2,&#39;x&#39;) ax[1].plot(x,yy1,&#39;o&#39;) ax[1].plot(x,yy2,&#39;x&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f035666bc50&gt;] . r1, r2 = sum(xx*yy1), sum(xx*yy2) r1, r2 . (0.9473089524539402, 0.4445681691326099) . - 그림을 보고 상관계수의 절대값을 알아내는 방법!: 직선근처에 몰려있으면 절대값이 커요! . &#49328;&#51216;&#46020; &#51025;&#50857;&#50696;&#51228;2 -- &#50532;&#49828;&#53092;&#51032; 4&#48516;&#54624; . - Anscombe&#39;s quartet: 교과서에 나오는 그림임. . - 교훈1: 데이터를 분석하기 전에 항상 시각화를 하라. . x = [10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5] y1 = [8.04, 6.95, 7.58, 8.81, 8.33, 9.96, 7.24, 4.26, 10.84, 4.82, 5.68] y2 = [9.14, 8.14, 8.74, 8.77, 9.26, 8.10, 6.13, 3.10, 9.13, 7.26, 4.74] y3 = [7.46, 6.77, 12.74, 7.11, 7.81, 8.84, 6.08, 5.39, 8.15, 6.42, 5.73] x4 = [8, 8, 8, 8, 8, 8, 8, 19, 8, 8, 8] y4 = [6.58, 5.76, 7.71, 8.84, 8.47, 7.04, 5.25, 12.50, 5.56, 7.91, 6.89] . fig, ((ax1,ax2),(ax3,ax4)) = plt.subplots(2,2) ax1.plot(x,y1,&#39;o&#39;) ax2.plot(x,y2,&#39;o&#39;) ax3.plot(x,y3,&#39;o&#39;) ax4.plot(x4,y4,&#39;o&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f035648d290&gt;] . - 첫번째 그림의 상관계수를 구해보자. 즉 corr(x,y1)을 구해보자. . _xx = tilde(x) _yy1 = tilde(y1) . np.sum(_xx*_yy1) . 0.8164205163448399 . - 사실 아래와 같이 구해도 된다. . np.corrcoef([x,y1]) . array([[1. , 0.81642052], [0.81642052, 1. ]]) . - corr(x,y1), corr(x,y2), corr(x,y3)를 구해보자. . np.corrcoef([x,y1,y2,y3]) . array([[1. , 0.81642052, 0.81623651, 0.81628674], [0.81642052, 1. , 0.7500054 , 0.46871668], [0.81623651, 0.7500054 , 1. , 0.58791933], [0.81628674, 0.46871668, 0.58791933, 1. ]]) . 앤스콤의 4분할중 1,2,3 번째 그림의 상관계수는 0.81642052, 0.81623651, 0.81628674 이라는 의미 | 즉 corr(x,y1)=0.81642052, corr(x,y2)=0.81623651, corr(x,y3)=0.81628674 임 | . * 참고로 np.corrcoef([x,y1,y2,y3])의 계산결과는 정확하게 . $$ begin{bmatrix} corr(x,x) &amp; corr(x,y1) &amp; corr(x,y2) &amp; corr(x,y3) corr(y1,x) &amp; corr(y1,y1) &amp; corr(y1,y2) &amp; corr(y1,y3) corr(y2,x) &amp; corr(y2,y1) &amp; corr(y2,y2) &amp; corr(y2,y3) corr(y3,x) &amp; corr(y3,y1) &amp; corr(y3,y2) &amp; corr(y3,y3) end{bmatrix}$$ . 를 의미함 . - 앤스콤플랏의 4개의 그림은 모두 같은 상관계수를 가진다. $ to$ 하지만 4개의 그림은 느낌이 전혀 다르다. . - 같은 표본상관계수를 가진다고 하여 같은 관계성을 가지는 것은 아니다. 표본상관계수는 x,y의 비례정도를 측정하는데 그 값이 1에 가깝다고 하여 꼭 정비례의 관계가 있음을 의미하는게 아니다. $(x_i,y_i)$의 산점도가 선형성을 보일때만 &quot;표본상관계수가 1이므로 정비례의 관계에 있다&quot; 라는 논리전개가 성립한다. . 앤스콤의 1번째 플랏: 산점도가 선형 $ to$ 표본상관계수가 0.816 = 정비례의 관계가 0.816 정도 | 앤스콤의 2번째 플랏: 산점도가 선형이 아님 $ to$ 표본상관계수가 크게 의미없음 | 앤스콤의 3번째 플랏: 산점도가 선형인듯 보이나 하나의 이상치가 있음 $ to$ 하나의 이상치가 표본상관계수의 값을 무너뜨릴 수 있으므로 표본상관계수값을 신뢰할 수 없음. | 앤스콤의 4번째 플랏: 산점도를 그려보니 이상한그림 $ to$ 표존상관계수를 계산할수는 있음. 그런데 그게 무슨 의미가 있을지? | . - 앤스콤의 3번째 플랏: 하나의 이상치가 상관계수를 무너뜨리는 경우 시각화 . plt.plot(x,y1,&#39;x&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f0355d7e6d0&gt;] . 하나의 점을 잘 추가하면 이 상관계수값을 -1에 수렴시킬 수 있다? | . plt.plot(x+[99],y1+[-99],&#39;x&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f0355e77dd0&gt;] . np.corrcoef(x+[99],y1+[-99]) . array([[ 1. , -0.98450679], [-0.98450679, 1. ]]) . - 교훈2: 상관계수를 해석하기에 앞서서 산점도가 선형성을 보이는지 체크할 것! 항상 통계학과에서 배우는 통계량 (혹은 논리전개)는 적절한 가정하에서만 말이된다는 사실을 기억할 것! . &#49328;&#51216;&#46020; &#51025;&#50857;&#50696;&#51228;3 -- &#47924;&#49345;&#44288;&#51008; &#44288;&#44228;&#44032; &#50630;&#45796;&#45716; &#46907;? . np.random.seed(43052) x=np.linspace(-1,1,100,endpoint=True) y=x**2+np.random.normal(scale=0.1,size=100) . plt.plot(x,y,&#39;o&#39;) plt.title(&#39;y=x**2&#39;) . Text(0.5, 1.0, &#39;y=x**2&#39;) . np.corrcoef(x,y) . array([[1. , 0.00688718], [0.00688718, 1. ]]) . - 표본상관계수의 값이 0에 가까운 것은 두 변수의 직선관계가 약한것을 의미한 것이지 두 변수 사이에 아무런 함수관계가 없다는 것을 의미하는 것은 아니다. . &#49689;&#51228; . 아래의 그림을 보고 물음에 답하라. . . (1) 산점도 (a) - (f) 중 표본상관계수가 양수라 생각되는 그림은? . (2) 산점도 (a) - (f) 중 표본상관계수의 절대값이 가장 큰 그림은? 절대값이 가장 작은 그림은? .",
            "url": "https://guebin.github.io/DV2022/2022/09/21/(3%EC%A3%BC%EC%B0%A8)-9%EC%9B%9421%EC%9D%BC.html",
            "relUrl": "/2022/09/21/(3%EC%A3%BC%EC%B0%A8)-9%EC%9B%9421%EC%9D%BC.html",
            "date": " • Sep 21, 2022"
        }
        
    
  
    
        ,"post14": {
            "title": "(3주차) 9월21일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . imports . import matplotlib.pyplot as plt import numpy as np import plotly.express as px from IPython.display import HTML . &#49328;&#51216;&#46020; &#51025;&#50857;&#50696;&#51228;1 - &#54364;&#48376;&#49345;&#44288;&#44228;&#49688; . &#50696;&#51228;&#49548;&#44060; . - 아래와 같은 자료를 수집하였다고 하자. . 몸무게 = [44,48,49,58,62,68,69,70,76,79] | 키 = [159,160,162,165,167,162,165,175,165,172] | . x=[44,48,49,58,62,68,69,70,76,79] y=[159,160,162,165,167,162,165,175,165,172] . plt.plot(x,y,&#39;o&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f49354a0ad0&gt;] . 키가 큰 사람일수록 몸무게도 많이 나간다. (반대도 성립) | 키와 몸무게는 관계가 있어보인다. (정비례) | . - 얼만큼 정비례인지? . 이 질문에 대답하기 위해서는 상관계수의 개념을 알아야 한다. | 상관계수는 산점도에서 가장 중요한 개념중 하나. | . &#49345;&#44288;&#44228;&#49688;&#51032; &#51221;&#51032; . - (표본)상관계수 . $$r= frac{ sum_{i=1}^{n}(x_i- bar{x})(y_i- bar{y}) }{ sqrt{ sum_{i=1}^{n}(x_i- bar{x})^2 sum_{i=1}^{n}(y_i- bar{y})^2 }}= sum_{i=1}^{n} tilde{x}_i tilde{y}_i $$ . 단, $ tilde{x}_i= frac{(x_i- bar{x})}{ sqrt{ sum_{i=1}^n(x_i- bar{x})^2}}$, $ tilde{y}_i= frac{(y_i- bar{y})}{ sqrt{ sum_{i=1}^n(y_i- bar{y})^2}}$ | . * 표본의 의미 . 평균과 표본평균 . np.random.seed(43052) x = np.random.randn(10) x . array([ 0.38342049, 1.0841745 , 1.14277825, 0.30789368, 0.23778744, 0.35595116, -1.66307542, -1.38277318, -1.92684484, -1.4862163 ]) . x는 의 각 원소는 모두 평균이 0인 정규분포에서 추출했다고 표현 | . np.mean(x) . 0.09434107867212947 . ${ tt x}=(x_1, dots, x_{10})$의 표본평균은 ${ bar x}=0.09434107867212947$ 라고 표현 | . &#49345;&#44288;&#44228;&#49688;&#51032; &#51032;&#48120; . - 의미? . x=np.array(x) y=np.array(y) . fig, (ax1,ax2,ax3) = plt.subplots(1,3,figsize=(9,4)) . ax1.plot(x,y,&#39;o&#39;) ax2.plot(x-np.mean(x),y-np.mean(y),&#39;o&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f03567ef610&gt;] . fig . - $ tilde{x}_i$와 $ tilde{y}_i$를 계산하기 위해서 $a= sqrt{ sum_{i=1}^{n}(x_i- bar{x})^2}, b= sqrt{ sum_{i=1}^{n}(y_i- bar{y})^2}$를 계산하자. . (방법1) . a=np.sqrt(np.sum((x-np.mean(x))**2)) b=np.sqrt(np.sum((y-np.mean(y))**2)) a,b . (2.8842557251032446, 15.218409903797438) . 해석: $a&gt;b$ 이므로 $ {x_i }$들이 $ {y_i }$들 보다 좀 더 퍼져있다. (=평균근처에 몰려있지 않다) | . (방법2) . - 사실 $a,b$는 아래와 같이 계산할 수 있다. . $a= sqrt{n} times{ tt np.std(x)}$ . $b= sqrt{n} times{ tt np.std(y)}$ . n=len(x) np.sqrt(n)*np.std(x), np.sqrt(n)*np.std(y) . (2.8842557251032446, 15.21840990379744) . ${ tt np.std(x)}= sqrt{ frac{1}{n} sum_{i=1}^{n}(x_i- bar{x})^2}$ | ${ tt np.std(y)}= sqrt{ frac{1}{n} sum_{i=1}^{n}(y_i- bar{y})^2}$ | . . Note: ${ tt np.std(x,ddof=1)}= sqrt{ frac{1}{n-1} sum_{i=1}^{n}(x_i- bar{x})^2}$ . - 이제 $( tilde{x}_i, tilde{y}_i)$를 ax3에 그려보자. . xx= (x-np.mean(x))/a yy= (y-np.mean(y))/b ax3.plot(xx,yy,&#39;o&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f03567b4290&gt;] . fig . 질문: $r$의 값이 양수인가? 음수인가? . - plotly 사용하여 $( tilde{x}_i, tilde{y}_i)$를 그려보자. . fig=px.scatter(x=xx, y=yy) HTML(fig.to_html(include_plotlyjs=&#39;cdn&#39;,include_mathjax=False)) . . . $ tilde{x}_i$, $ tilde{y}_i$ 를 곱한값이 양수인것과 음수인것을 체크해보자. | 양수인쪽이 많은지 음수인쪽이 많은지 생각해보자. | $r= sum_{i=1}^{n} tilde{x}_i tilde{y}_i$ 의 부호는? | . &#44536;&#47548;&#51012; &#48372;&#44256; &#49345;&#44288;&#44228;&#49688;&#51032; &#48512;&#54840;&#47484; &#50508;&#50500;&#45236;&#45716; &#48169;&#48277; . - $(x_i,y_i)$의 산점도를 보고 $( tilde{x}_i, tilde{y}_i)$ 의 산점도를 상상 $ to$ 1,3 분면에 점들이 많으면 양수, 2,4 분면에 점들이 많으면 음수 . &#44536;&#47548;&#51012; &#48372;&#44256; &#49345;&#44288;&#44228;&#49688;&#51032; &#51208;&#45824;&#44050;&#51012; &#50508;&#50500;&#45236;&#45716; &#48169;&#48277; . - 이해를 위한 예시 . x=np.arange(0,10,0.1) y1=x+np.random.normal(loc=0,scale=1.0,size=len(x)) y2=x+np.random.normal(loc=0,scale=7.0,size=len(x)) . plt.plot(x,y1,&#39;o&#39;) plt.plot(x,y2,&#39;x&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f03566c0650&gt;] . 각 데이터셋의 표준상관계수를 각각 $r_1$(파란색), $r_2$(주황색)라고 하자. . (1) $r_1$, $r_2$의 부호는 양수인가? 음수인가? --&gt; 양수 . (2) $r_1,r_2$의 값중 어떠한 값이 더 절대값이 큰가? --&gt; 잘모르겠음. 따져보자. . def tilde(x): n= len(x) return (x-np.mean(x)) / (np.std(x)*np.sqrt(n)) . xx= tilde(x) yy1= tilde(y1) yy2= tilde(y2) . fig, ax = plt.subplots(1,2) ax[0].plot(x,y1,&#39;o&#39;) ax[0].plot(x,y2,&#39;x&#39;) ax[1].plot(x,yy1,&#39;o&#39;) ax[1].plot(x,yy2,&#39;x&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f035666bc50&gt;] . r1, r2 = sum(xx*yy1), sum(xx*yy2) r1, r2 . (0.9473089524539402, 0.4445681691326099) . - 그림을 보고 상관계수의 절대값을 알아내는 방법!: 직선근처에 몰려있으면 절대값이 커요! . &#49328;&#51216;&#46020; &#51025;&#50857;&#50696;&#51228;2 -- &#50532;&#49828;&#53092;&#51032; 4&#48516;&#54624; . - Anscombe&#39;s quartet: 교과서에 나오는 그림임. . - 교훈1: 데이터를 분석하기 전에 항상 시각화를 하라. . x = [10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5] y1 = [8.04, 6.95, 7.58, 8.81, 8.33, 9.96, 7.24, 4.26, 10.84, 4.82, 5.68] y2 = [9.14, 8.14, 8.74, 8.77, 9.26, 8.10, 6.13, 3.10, 9.13, 7.26, 4.74] y3 = [7.46, 6.77, 12.74, 7.11, 7.81, 8.84, 6.08, 5.39, 8.15, 6.42, 5.73] x4 = [8, 8, 8, 8, 8, 8, 8, 19, 8, 8, 8] y4 = [6.58, 5.76, 7.71, 8.84, 8.47, 7.04, 5.25, 12.50, 5.56, 7.91, 6.89] . fig, ((ax1,ax2),(ax3,ax4)) = plt.subplots(2,2) ax1.plot(x,y1,&#39;o&#39;) ax2.plot(x,y2,&#39;o&#39;) ax3.plot(x,y3,&#39;o&#39;) ax4.plot(x4,y4,&#39;o&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f035648d290&gt;] . - 첫번째 그림의 상관계수를 구해보자. 즉 corr(x,y1)을 구해보자. . _xx = tilde(x) _yy1 = tilde(y1) . np.sum(_xx*_yy1) . 0.8164205163448399 . - 사실 아래와 같이 구해도 된다. . np.corrcoef([x,y1]) . array([[1. , 0.81642052], [0.81642052, 1. ]]) . - corr(x,y1), corr(x,y2), corr(x,y3)를 구해보자. . np.corrcoef([x,y1,y2,y3]) . array([[1. , 0.81642052, 0.81623651, 0.81628674], [0.81642052, 1. , 0.7500054 , 0.46871668], [0.81623651, 0.7500054 , 1. , 0.58791933], [0.81628674, 0.46871668, 0.58791933, 1. ]]) . 앤스콤의 4분할중 1,2,3 번째 그림의 상관계수는 0.81642052, 0.81623651, 0.81628674 이라는 의미 | 즉 corr(x,y1)=0.81642052, corr(x,y2)=0.81623651, corr(x,y3)=0.81628674 임 | . * 참고로 np.corrcoef([x,y1,y2,y3])의 계산결과는 정확하게 . $$ begin{bmatrix} corr(x,x) &amp; corr(x,y1) &amp; corr(x,y2) &amp; corr(x,y3) corr(y1,x) &amp; corr(y1,y1) &amp; corr(y1,y2) &amp; corr(y1,y3) corr(y2,x) &amp; corr(y2,y1) &amp; corr(y2,y2) &amp; corr(y2,y3) corr(y3,x) &amp; corr(y3,y1) &amp; corr(y3,y2) &amp; corr(y3,y3) end{bmatrix}$$ . 를 의미함 . - 앤스콤플랏의 4개의 그림은 모두 같은 상관계수를 가진다. $ to$ 하지만 4개의 그림은 느낌이 전혀 다르다. . - 같은 표본상관계수를 가진다고 하여 같은 관계성을 가지는 것은 아니다. 표본상관계수는 x,y의 비례정도를 측정하는데 그 값이 1에 가깝다고 하여 꼭 정비례의 관계가 있음을 의미하는게 아니다. $(x_i,y_i)$의 산점도가 선형성을 보일때만 &quot;표본상관계수가 1이므로 정비례의 관계에 있다&quot; 라는 논리전개가 성립한다. . 앤스콤의 1번째 플랏: 산점도가 선형 $ to$ 표본상관계수가 0.816 = 정비례의 관계가 0.816 정도 | 앤스콤의 2번째 플랏: 산점도가 선형이 아님 $ to$ 표본상관계수가 크게 의미없음 | 앤스콤의 3번째 플랏: 산점도가 선형인듯 보이나 하나의 이상치가 있음 $ to$ 하나의 이상치가 표본상관계수의 값을 무너뜨릴 수 있으므로 표본상관계수값을 신뢰할 수 없음. | 앤스콤의 4번째 플랏: 산점도를 그려보니 이상한그림 $ to$ 표존상관계수를 계산할수는 있음. 그런데 그게 무슨 의미가 있을지? | . - 앤스콤의 3번째 플랏: 하나의 이상치가 상관계수를 무너뜨리는 경우 시각화 . plt.plot(x,y1,&#39;x&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f0355d7e6d0&gt;] . 하나의 점을 잘 추가하면 이 상관계수값을 -1에 수렴시킬 수 있다? | . plt.plot(x+[99],y1+[-99],&#39;x&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f0355e77dd0&gt;] . np.corrcoef(x+[99],y1+[-99]) . array([[ 1. , -0.98450679], [-0.98450679, 1. ]]) . - 교훈2: 상관계수를 해석하기에 앞서서 산점도가 선형성을 보이는지 체크할 것! 항상 통계학과에서 배우는 통계량 (혹은 논리전개)는 적절한 가정하에서만 말이된다는 사실을 기억할 것! . &#49328;&#51216;&#46020; &#51025;&#50857;&#50696;&#51228;3 -- &#47924;&#49345;&#44288;&#51008; &#44288;&#44228;&#44032; &#50630;&#45796;&#45716; &#46907;? . np.random.seed(43052) x=np.linspace(-1,1,100,endpoint=True) y=x**2+np.random.normal(scale=0.1,size=100) . plt.plot(x,y,&#39;o&#39;) plt.title(&#39;y=x**2&#39;) . Text(0.5, 1.0, &#39;y=x**2&#39;) . np.corrcoef(x,y) . array([[1. , 0.00688718], [0.00688718, 1. ]]) . - 표본상관계수의 값이 0에 가까운 것은 두 변수의 직선관계가 약한것을 의미한 것이지 두 변수 사이에 아무런 함수관계가 없다는 것을 의미하는 것은 아니다. . &#49689;&#51228; . 아래의 그림을 보고 물음에 답하라. . . (1) 산점도 (a) - (f) 중 표본상관계수가 양수라 생각되는 그림은? . (2) 산점도 (a) - (f) 중 표본상관계수의 절대값이 가장 큰 그림은? 절대값이 가장 작은 그림은? .",
            "url": "https://guebin.github.io/DV2022/2022/09/21/(3%EC%A3%BC%EC%B0%A8)-9%EC%9B%9421%EC%9D%BC.html",
            "relUrl": "/2022/09/21/(3%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1)-9%E1%84%8B%E1%85%AF%E1%86%AF21%E1%84%8B%E1%85%B5%E1%86%AF.html",
            "date": " • Sep 21, 2022"
        }
        
    
  
    
        ,"post15": {
            "title": "(3주차) 9월19일 -- 숙제제출방법 영상추가",
            "content": "&#44053;&#51032;&#50689;&#49345; . . &#50724;&#45720; &#48176;&#50872; &#45236;&#50857;? . - 라인플랏과 산점도를 그리는 방법 . - 여러 그림그리기 (한 플랏에 그림을 겹치는 방법, subplot을 그리는 방법) . - fig, axes의 개념이해 (객체지향적 프로그래밍) . imports . import matplotlib.pyplot as plt import numpy as np . Line plot . &#44592;&#48376;&#54540;&#46991; . - 예시1 . x=[1,2,3,4] y=[1,2,4,3] . plt.plot(x,y) . [&lt;matplotlib.lines.Line2D at 0x7f3b261797d0&gt;] . &#47784;&#50577;&#48320;&#44221; . - 예시1 . plt.plot(x,y,&#39;--&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b260867d0&gt;] . - 예시2 . plt.plot(x,y,&#39;:&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b25f950d0&gt;] . - 예시3 . plt.plot(x,y,&#39;-.&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b25f15810&gt;] . &#49353;&#49345;&#48320;&#44221; . - 예시1 . plt.plot(x,y,&#39;r&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b25e1e9d0&gt;] . - 예시2 . plt.plot(x,y,&#39;k&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b25dad290&gt;] . &#47784;&#50577; + &#49353;&#49345;&#48320;&#44221; . - 예시1 . plt.plot(x,y,&#39;--r&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b25b2ab10&gt;] . - 예시2: 순서변경 가능 . plt.plot(x,y,&#39;r--&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b25942d10&gt;] . &#50896;&#47532;? . - r--등의 옵션은 Markers + Line Styles + Colors 의 조합으로 표현가능 . ref: https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html . --r: 점선(dashed)스타일 + 빨간색 | r--: 빨간색 + 점선(dashed)스타일 | :k: 점선(dotted)스타일 + 검은색 | k:: 검은색 + 점선(dotted)스타일 | . - 우선 Marker를 무시하면 Line Styles + Color로 표현가능한 조합은 $4 times 8=32$ 개 . (Line Styles) 모두 4개 . character description . &#39;-&#39; | solid line style | . &#39;--&#39; | dashed line style | . &#39;-.&#39; | dash-dot line style | . &#39;:&#39; | dotted line style | . (Color) 모두 8개 . character color . &#39;b&#39; | blue | . &#39;g&#39; | green | . &#39;r&#39; | red | . &#39;c&#39; | cyan | . &#39;m&#39; | magenta | . &#39;y&#39; | yellow | . &#39;k&#39; | black | . &#39;w&#39; | white | . - 예시1 . plt.plot(x,y,&#39;--m&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b25840e90&gt;] . - 예시2 . plt.plot(x,y,&#39;-.c&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b257c99d0&gt;] . - 예시3: line style + color 조합으로 사용하든 color + line style 조합으로 사용하든 상관없음 . plt.plot(x,y,&#39;-.c&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b256ea050&gt;] . plt.plot(x,y,&#39;c-.&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b256679d0&gt;] . - 예시4: line style을 중복으로 사용하거나 color를 중복으로 쓸 수 는 없다. . plt.plot(x,y,&#39;--:&#39;) . ValueError Traceback (most recent call last) /tmp/ipykernel_105674/54727817.py in &lt;module&gt; -&gt; 1 plt.plot(x,y,&#39;--:&#39;) ~/anaconda3/envs/py37/lib/python3.7/site-packages/matplotlib/pyplot.py in plot(scalex, scaley, data, *args, **kwargs) 2767 return gca().plot( 2768 *args, scalex=scalex, scaley=scaley, -&gt; 2769 **({&#34;data&#34;: data} if data is not None else {}), **kwargs) 2770 2771 ~/anaconda3/envs/py37/lib/python3.7/site-packages/matplotlib/axes/_axes.py in plot(self, scalex, scaley, data, *args, **kwargs) 1633 &#34;&#34;&#34; 1634 kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D) -&gt; 1635 lines = [*self._get_lines(*args, data=data, **kwargs)] 1636 for line in lines: 1637 self.add_line(line) ~/anaconda3/envs/py37/lib/python3.7/site-packages/matplotlib/axes/_base.py in __call__(self, data, *args, **kwargs) 310 this += args[0], 311 args = args[1:] --&gt; 312 yield from self._plot_args(this, kwargs) 313 314 def get_next_color(self): ~/anaconda3/envs/py37/lib/python3.7/site-packages/matplotlib/axes/_base.py in _plot_args(self, tup, kwargs, return_kwargs) 447 # xy is tup with fmt stripped (could still be (y,) only) 448 *xy, fmt = tup --&gt; 449 linestyle, marker, color = _process_plot_format(fmt) 450 elif len(tup) == 3: 451 raise ValueError(&#39;third arg must be a format string&#39;) ~/anaconda3/envs/py37/lib/python3.7/site-packages/matplotlib/axes/_base.py in _process_plot_format(fmt) 171 if linestyle is not None: 172 raise ValueError( --&gt; 173 &#39;Illegal format string &#34;%s&#34;; two linestyle symbols&#39; % fmt) 174 linestyle = fmt[i:i+2] 175 i += 2 ValueError: Illegal format string &#34;--:&#34;; two linestyle symbols . plt.plot(x,y,&#39;rb&#39;) . ValueError Traceback (most recent call last) /tmp/ipykernel_105674/3007505469.py in &lt;module&gt; -&gt; 1 plt.plot(x,y,&#39;rb&#39;) ~/anaconda3/envs/py37/lib/python3.7/site-packages/matplotlib/pyplot.py in plot(scalex, scaley, data, *args, **kwargs) 2767 return gca().plot( 2768 *args, scalex=scalex, scaley=scaley, -&gt; 2769 **({&#34;data&#34;: data} if data is not None else {}), **kwargs) 2770 2771 ~/anaconda3/envs/py37/lib/python3.7/site-packages/matplotlib/axes/_axes.py in plot(self, scalex, scaley, data, *args, **kwargs) 1633 &#34;&#34;&#34; 1634 kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D) -&gt; 1635 lines = [*self._get_lines(*args, data=data, **kwargs)] 1636 for line in lines: 1637 self.add_line(line) ~/anaconda3/envs/py37/lib/python3.7/site-packages/matplotlib/axes/_base.py in __call__(self, data, *args, **kwargs) 310 this += args[0], 311 args = args[1:] --&gt; 312 yield from self._plot_args(this, kwargs) 313 314 def get_next_color(self): ~/anaconda3/envs/py37/lib/python3.7/site-packages/matplotlib/axes/_base.py in _plot_args(self, tup, kwargs, return_kwargs) 447 # xy is tup with fmt stripped (could still be (y,) only) 448 *xy, fmt = tup --&gt; 449 linestyle, marker, color = _process_plot_format(fmt) 450 elif len(tup) == 3: 451 raise ValueError(&#39;third arg must be a format string&#39;) ~/anaconda3/envs/py37/lib/python3.7/site-packages/matplotlib/axes/_base.py in _process_plot_format(fmt) 189 if color is not None: 190 raise ValueError( --&gt; 191 &#39;Illegal format string &#34;%s&#34;; two color symbols&#39; % fmt) 192 color = c 193 i += 1 ValueError: Illegal format string &#34;rb&#34;; two color symbols . - 예시5: 색이 사실 8개만 있는건 아니다. . ref: https://matplotlib.org/2.0.2/examples/color/named_colors.html . plt.plot(x,y,&#39;--&#39;,color=&#39;lime&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b2511edd0&gt;] . - 예시6: 색을 바꾸려면 Hex코드를 밖아 넣는 방법이 젤 깔끔함 . ref: https://htmlcolorcodes.com/ . plt.plot(x,y,color=&#39;#277E41&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b2502dd90&gt;] . - 예시7: 당연히 라인스타일도 4개만 있진 않겠지 . ref: https://matplotlib.org/stable/gallery/lines_bars_and_markers/linestyles.html . plt.plot(x,y,linestyle=&#39;dashed&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b2707bd10&gt;] . plt.plot(x,y,linestyle=(0, (20, 5))) . [&lt;matplotlib.lines.Line2D at 0x7f3b240cd110&gt;] . Scatter plot . &#50896;&#47532; . - 그냥 마커를 설정하면 끝! . ref: https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html . character description . &#39;.&#39; | point marker | . &#39;,&#39; | pixel marker | . &#39;o&#39; | circle marker | . &#39;v&#39; | triangle_down marker | . &#39;^&#39; | triangle_up marker | . &#39;&lt;&#39; | triangle_left marker | . &#39;&gt;&#39; | triangle_right marker | . &#39;1&#39; | tri_down marker | . &#39;2&#39; | tri_up marker | . &#39;3&#39; | tri_left marker | . &#39;4&#39; | tri_right marker | . &#39;8&#39; | octagon marker | . &#39;s&#39; | square marker | . &#39;p&#39; | pentagon marker | . &#39;P&#39; | plus (filled) marker | . &#39;*&#39; | star marker | . &#39;h&#39; | hexagon1 marker | . &#39;H&#39; | hexagon2 marker | . &#39;+&#39; | plus marker | . &#39;x&#39; | x marker | . &#39;X&#39; | x (filled) marker | . &#39;D&#39; | diamond marker | . &#39;d&#39; | thin_diamond marker | . &#39;|&#39; | vline marker | . &#39;_&#39; | hline marker | . plt.plot(x,y,&#39;o&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b23934110&gt;] . &#44592;&#48376;&#54540;&#46991; . - 예시1 . plt.plot(x,y,&#39;.&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b237eaa10&gt;] . - 예시2 . plt.plot(x,y,&#39;x&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b235f4290&gt;] . &#49353;&#44628;&#48320;&#44221; . - 예시1 . plt.plot(x,y,&#39;or&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b2365c2d0&gt;] . - 예시2 . plt.plot(x,y,&#39;db&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b234bcb90&gt;] . - 예시3 . plt.plot(x,y,&#39;bx&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b233e4b10&gt;] . dot-connected plot . - 예시1: 마커와 라인스타일을 동시에 사용하면 dot-connected plot이 된다. . plt.plot(x,y,&#39;o-&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b232f3590&gt;] . - 예시2: 당연히 색도 적용가능함 . plt.plot(x,y,&#39;o--r&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b23200550&gt;] . - 예시3: 서로 순서를 바꿔도 상관없다. . plt.plot(x,y,&#39;ro--&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b23109590&gt;] . &#50668;&#47084; &#44536;&#47548; &#44536;&#47532;&#44592; . &#44217;&#52432;&#44536;&#47532;&#44592; . - 예시1 . x = np.arange(-5,5,0.1) ϵ = np.random.randn(100) y = 2*x + ϵ . plt.plot(x,y,&#39;.b&#39;) plt.plot(x,2*x,&#39;r&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b225d80d0&gt;] . &#46384;&#47196;&#44536;&#47532;&#44592; (subplot) // &#50808;&#50864;&#49464;&#50836; &#51060;&#44144; . - 예시1 . fig, axs = plt.subplots(2) axs[0].plot(x,y,&#39;.b&#39;) axs[1].plot(x,2*x,&#39;r&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b225274d0&gt;] . - 예시2 . fig, axs = plt.subplots(2,2) axs[0,0].plot(x,2*x,&#39;--b&#39;) axs[0,1].plot(x,ϵ,&#39;.r&#39;) axs[1,0].plot(x,y,&#39;.r&#39;) axs[1,1].plot(x,y,&#39;.r&#39;) axs[1,1].plot(x,2*x,&#39;-b&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b2193f390&gt;] . fig&#50752; axes&#51032; &#51060;&#54644; : matplotlib&#51004;&#47196; &#50612;&#47157;&#44172; &#44536;&#47548;&#51012; &#44536;&#47532;&#45716; &#48169;&#48277; . &#50696;&#51228;1 . - 목표: plt.plot()을 이용하지 않고 아래의 그림을 그려보자. . plt.plot([1,2,3,4],[1,2,4,3],&#39;or--&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b1f950a10&gt;] . - 구조: axis $ subset$ axes $ subset$ figure . ref: https://matplotlib.org/stable/gallery/showcase/anatomy.html#sphx-glr-gallery-showcase-anatomy-py . . - 전략: Fig을 만들고 (도화지를 준비) $ to$ axes를 만들고 (네모틀) $ to$ axes에 그림을 그린다. . - 그림객체를 생성한다. . fig = plt.figure() . &lt;Figure size 432x288 with 0 Axes&gt; . fig # 지금은 아무것도 없다. . &lt;Figure size 432x288 with 0 Axes&gt; . - 그림객체에는 여러 인스턴스 + 함수가 있는데 그중에서 axes도 있다. (그런데 그와중에 plot method는 없다) . fig.axes # 비어있는 리스트 . [] . - axes 추가 . fig.add_axes([0,0,1,1]) # (0,0)의 위치에 (1,1)인 액시즈(=네모틀)을 만들어라. . &lt;Axes:&gt; . fig.axes . [&lt;Axes:&gt;] . fig # 도화지안에 네모틀이 들어가 있다. . - 첫번째 액시즈를 ax1로 받음 (원래 axes1이어야하는데 그냥 편의상) . ax1 = fig.axes[0] . id(fig.axes[0]),id(ax1) . (139891930961872, 139891930961872) . - 잠깐만! (fig 오브젝트와 ax1 오브젝트는 포함관계에 있다) . id(fig.axes[0]),id(ax1) . (139891930961872, 139891930961872) . - 또 잠깐만! (fig 오브젝트에는 plot이 없지만 ax1 오브젝트에는 plot이 있다) . set(dir(fig)) &amp; {&#39;plot&#39;} . set() . set(dir(ax1)) &amp; {&#39;plot&#39;} . {&#39;plot&#39;} . - ax1.plot()을 사용하여 그림을 그려보자. . ax1.plot([1,2,3,4],[1,2,4,3],&#39;--or&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b1f8f8e10&gt;] . fig . &#50696;&#51228;2: &#50696;&#51228;1&#51032; &#51025;&#50857; . - 예제1상황 . fig . - 여기서 축을 하나 더 추가할거에요 . fig.axes . [&lt;Axes:&gt;] . fig.add_axes([1,1,1,1]) . &lt;Axes:&gt; . fig.axes . [&lt;Axes:&gt;, &lt;Axes:&gt;] . fig . ax1,ax2 = fig.axes . - ax2에 파란선으로 그림을 그리자. . ax2.plot([1,2,3,4],[1,2,4,3],&#39;--ob&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b2028e390&gt;] . fig . &#50696;&#51228;3: &#45908; &#51025;&#50857;! (&#48120;&#45768;&#47605;) . - 지금 상황 . fig . - 액시즈를 하나 더 추가 . fig.add_axes([0.65,0.1,0.3,0.3]) . &lt;Axes:&gt; . fig . fig.axes[-1].plot([1,2,3,4],[1,2,4,3],&#39;xr&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b1ff16690&gt;] . fig . &#50696;&#51228;4: &#51116;&#54644;&#49437;1 . (ver1) . plt.plot([1,2,3,4],[1,2,4,3]) . [&lt;matplotlib.lines.Line2D at 0x7f3b200c55d0&gt;] . (ver2) . ver1은 사실 아래가 연속적으로 실행된 축약구문임 . fig = plt.figure() fig.add_axes([?,?,?,?]) ax1 = fig.axes[0] ax1.plot([1,2,3,4],[1,2,4,3]) fig . &#50696;&#51228;5: &#51116;&#54644;&#49437;2 . - 아래의 코드도 재해석하자. . fig, axs = plt.subplots(2,2) . fig, axs = plt.subplots(2,2) axs[0,0].plot([1,2,3,4],[1,2,4,3],&#39;.&#39;) axs[0,1].plot([1,2,3,4],[1,2,4,3],&#39;--r&#39;) axs[1,0].plot([1,2,3,4],[1,2,4,3],&#39;o--&#39;) axs[1,1].plot([1,2,3,4],[1,2,4,3],&#39;o--&#39;,color=&#39;lime&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b206b2c90&gt;] . - fig, axs = plt.subplots(2,2)의 축약버전을 이해하면된다. . (ver1) . fig, axs = plt.subplots(2,2) . (ver2) . ver1은 사실 아래의 축약! . fig = plt.figure() fig.add_axes([?,?,?,?]) fig.add_axes([?,?,?,?]) fig.add_axes([?,?,?,?]) fig.add_axes([?,?,?,?]) ax1,ax2,ax3,ax4 = fig.axes axs = np.array(((ax1,ax2),(ax3,ax4))) . (ver3) . ver1은 아래와 같이 표현할 수도 있다. . fig = plt.figure() axs = fig.subplots(2,2) . HW . 제출: 이름(학번).ipynb, 이름(학번).html 형태로 정리하여 2개의 파일을 제출할 것 (작성방법 모르면 아래영상참고할것) . 즉 주피터노트북파일과 html파일을 모두 제출할 것 | . . 영상1: 코랩으로 실습하는 경우 | 영상2: local 아나콘다로 실습하는 경우 | . 1. &#50500;&#47000;&#50752; &#44057;&#51008; &#44536;&#47548;&#51012; &#44536;&#47140;&#46972;. . x,y = [1,2,3,4], [1,2,4,3] . . [&lt;matplotlib.lines.Line2D at 0x7f3b1ed2d1d0&gt;] . 2. &#50500;&#47000;&#50752; &#44057;&#51008; &#44536;&#47548;&#51012; &#44536;&#47140;&#46972;. . x,y = [1,2,3,4], [1,2,1,1] . . [&lt;matplotlib.lines.Line2D at 0x7f3b1e8ad0d0&gt;] . 3. &#50500;&#47000;&#50752; &#44057;&#51008; &#44536;&#47548;&#51012; &#44536;&#47140;&#46972;. . x = np.arange(-5,5,0.1) y1 = np.sin(x) y2 = np.sin(2*x) + 2 y3 = np.sin(4*x) + 4 y4 = np.sin(8*x) + 6 . . [&lt;matplotlib.lines.Line2D at 0x7f3b1cf24e10&gt;] .",
            "url": "https://guebin.github.io/DV2022/2022/09/19/(3%EC%A3%BC%EC%B0%A8)-9%EC%9B%9419%EC%9D%BC.html",
            "relUrl": "/2022/09/19/(3%EC%A3%BC%EC%B0%A8)-9%EC%9B%9419%EC%9D%BC.html",
            "date": " • Sep 19, 2022"
        }
        
    
  
    
        ,"post16": {
            "title": "(3주차) 9월19일 -- 숙제제출방법 영상추가",
            "content": "&#44053;&#51032;&#50689;&#49345; . . &#50724;&#45720; &#48176;&#50872; &#45236;&#50857;? . - 라인플랏과 산점도를 그리는 방법 . - 여러 그림그리기 (한 플랏에 그림을 겹치는 방법, subplot을 그리는 방법) . - fig, axes의 개념이해 (객체지향적 프로그래밍) . imports . import matplotlib.pyplot as plt import numpy as np . Line plot . &#44592;&#48376;&#54540;&#46991; . - 예시1 . x=[1,2,3,4] y=[1,2,4,3] . plt.plot(x,y) . [&lt;matplotlib.lines.Line2D at 0x7f3b261797d0&gt;] . &#47784;&#50577;&#48320;&#44221; . - 예시1 . plt.plot(x,y,&#39;--&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b260867d0&gt;] . - 예시2 . plt.plot(x,y,&#39;:&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b25f950d0&gt;] . - 예시3 . plt.plot(x,y,&#39;-.&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b25f15810&gt;] . &#49353;&#49345;&#48320;&#44221; . - 예시1 . plt.plot(x,y,&#39;r&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b25e1e9d0&gt;] . - 예시2 . plt.plot(x,y,&#39;k&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b25dad290&gt;] . &#47784;&#50577; + &#49353;&#49345;&#48320;&#44221; . - 예시1 . plt.plot(x,y,&#39;--r&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b25b2ab10&gt;] . - 예시2: 순서변경 가능 . plt.plot(x,y,&#39;r--&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b25942d10&gt;] . &#50896;&#47532;? . - r--등의 옵션은 Markers + Line Styles + Colors 의 조합으로 표현가능 . ref: https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html . --r: 점선(dashed)스타일 + 빨간색 | r--: 빨간색 + 점선(dashed)스타일 | :k: 점선(dotted)스타일 + 검은색 | k:: 검은색 + 점선(dotted)스타일 | . - 우선 Marker를 무시하면 Line Styles + Color로 표현가능한 조합은 $4 times 8=32$ 개 . (Line Styles) 모두 4개 . character description . &#39;-&#39; | solid line style | . &#39;--&#39; | dashed line style | . &#39;-.&#39; | dash-dot line style | . &#39;:&#39; | dotted line style | . (Color) 모두 8개 . character color . &#39;b&#39; | blue | . &#39;g&#39; | green | . &#39;r&#39; | red | . &#39;c&#39; | cyan | . &#39;m&#39; | magenta | . &#39;y&#39; | yellow | . &#39;k&#39; | black | . &#39;w&#39; | white | . - 예시1 . plt.plot(x,y,&#39;--m&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b25840e90&gt;] . - 예시2 . plt.plot(x,y,&#39;-.c&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b257c99d0&gt;] . - 예시3: line style + color 조합으로 사용하든 color + line style 조합으로 사용하든 상관없음 . plt.plot(x,y,&#39;-.c&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b256ea050&gt;] . plt.plot(x,y,&#39;c-.&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b256679d0&gt;] . - 예시4: line style을 중복으로 사용하거나 color를 중복으로 쓸 수 는 없다. . plt.plot(x,y,&#39;--:&#39;) . ValueError Traceback (most recent call last) /tmp/ipykernel_105674/54727817.py in &lt;module&gt; -&gt; 1 plt.plot(x,y,&#39;--:&#39;) ~/anaconda3/envs/py37/lib/python3.7/site-packages/matplotlib/pyplot.py in plot(scalex, scaley, data, *args, **kwargs) 2767 return gca().plot( 2768 *args, scalex=scalex, scaley=scaley, -&gt; 2769 **({&#34;data&#34;: data} if data is not None else {}), **kwargs) 2770 2771 ~/anaconda3/envs/py37/lib/python3.7/site-packages/matplotlib/axes/_axes.py in plot(self, scalex, scaley, data, *args, **kwargs) 1633 &#34;&#34;&#34; 1634 kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D) -&gt; 1635 lines = [*self._get_lines(*args, data=data, **kwargs)] 1636 for line in lines: 1637 self.add_line(line) ~/anaconda3/envs/py37/lib/python3.7/site-packages/matplotlib/axes/_base.py in __call__(self, data, *args, **kwargs) 310 this += args[0], 311 args = args[1:] --&gt; 312 yield from self._plot_args(this, kwargs) 313 314 def get_next_color(self): ~/anaconda3/envs/py37/lib/python3.7/site-packages/matplotlib/axes/_base.py in _plot_args(self, tup, kwargs, return_kwargs) 447 # xy is tup with fmt stripped (could still be (y,) only) 448 *xy, fmt = tup --&gt; 449 linestyle, marker, color = _process_plot_format(fmt) 450 elif len(tup) == 3: 451 raise ValueError(&#39;third arg must be a format string&#39;) ~/anaconda3/envs/py37/lib/python3.7/site-packages/matplotlib/axes/_base.py in _process_plot_format(fmt) 171 if linestyle is not None: 172 raise ValueError( --&gt; 173 &#39;Illegal format string &#34;%s&#34;; two linestyle symbols&#39; % fmt) 174 linestyle = fmt[i:i+2] 175 i += 2 ValueError: Illegal format string &#34;--:&#34;; two linestyle symbols . plt.plot(x,y,&#39;rb&#39;) . ValueError Traceback (most recent call last) /tmp/ipykernel_105674/3007505469.py in &lt;module&gt; -&gt; 1 plt.plot(x,y,&#39;rb&#39;) ~/anaconda3/envs/py37/lib/python3.7/site-packages/matplotlib/pyplot.py in plot(scalex, scaley, data, *args, **kwargs) 2767 return gca().plot( 2768 *args, scalex=scalex, scaley=scaley, -&gt; 2769 **({&#34;data&#34;: data} if data is not None else {}), **kwargs) 2770 2771 ~/anaconda3/envs/py37/lib/python3.7/site-packages/matplotlib/axes/_axes.py in plot(self, scalex, scaley, data, *args, **kwargs) 1633 &#34;&#34;&#34; 1634 kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D) -&gt; 1635 lines = [*self._get_lines(*args, data=data, **kwargs)] 1636 for line in lines: 1637 self.add_line(line) ~/anaconda3/envs/py37/lib/python3.7/site-packages/matplotlib/axes/_base.py in __call__(self, data, *args, **kwargs) 310 this += args[0], 311 args = args[1:] --&gt; 312 yield from self._plot_args(this, kwargs) 313 314 def get_next_color(self): ~/anaconda3/envs/py37/lib/python3.7/site-packages/matplotlib/axes/_base.py in _plot_args(self, tup, kwargs, return_kwargs) 447 # xy is tup with fmt stripped (could still be (y,) only) 448 *xy, fmt = tup --&gt; 449 linestyle, marker, color = _process_plot_format(fmt) 450 elif len(tup) == 3: 451 raise ValueError(&#39;third arg must be a format string&#39;) ~/anaconda3/envs/py37/lib/python3.7/site-packages/matplotlib/axes/_base.py in _process_plot_format(fmt) 189 if color is not None: 190 raise ValueError( --&gt; 191 &#39;Illegal format string &#34;%s&#34;; two color symbols&#39; % fmt) 192 color = c 193 i += 1 ValueError: Illegal format string &#34;rb&#34;; two color symbols . - 예시5: 색이 사실 8개만 있는건 아니다. . ref: https://matplotlib.org/2.0.2/examples/color/named_colors.html . plt.plot(x,y,&#39;--&#39;,color=&#39;lime&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b2511edd0&gt;] . - 예시6: 색을 바꾸려면 Hex코드를 밖아 넣는 방법이 젤 깔끔함 . ref: https://htmlcolorcodes.com/ . plt.plot(x,y,color=&#39;#277E41&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b2502dd90&gt;] . - 예시7: 당연히 라인스타일도 4개만 있진 않겠지 . ref: https://matplotlib.org/stable/gallery/lines_bars_and_markers/linestyles.html . plt.plot(x,y,linestyle=&#39;dashed&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b2707bd10&gt;] . plt.plot(x,y,linestyle=(0, (20, 5))) . [&lt;matplotlib.lines.Line2D at 0x7f3b240cd110&gt;] . Scatter plot . &#50896;&#47532; . - 그냥 마커를 설정하면 끝! . ref: https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html . character description . &#39;.&#39; | point marker | . &#39;,&#39; | pixel marker | . &#39;o&#39; | circle marker | . &#39;v&#39; | triangle_down marker | . &#39;^&#39; | triangle_up marker | . &#39;&lt;&#39; | triangle_left marker | . &#39;&gt;&#39; | triangle_right marker | . &#39;1&#39; | tri_down marker | . &#39;2&#39; | tri_up marker | . &#39;3&#39; | tri_left marker | . &#39;4&#39; | tri_right marker | . &#39;8&#39; | octagon marker | . &#39;s&#39; | square marker | . &#39;p&#39; | pentagon marker | . &#39;P&#39; | plus (filled) marker | . &#39;*&#39; | star marker | . &#39;h&#39; | hexagon1 marker | . &#39;H&#39; | hexagon2 marker | . &#39;+&#39; | plus marker | . &#39;x&#39; | x marker | . &#39;X&#39; | x (filled) marker | . &#39;D&#39; | diamond marker | . &#39;d&#39; | thin_diamond marker | . &#39;|&#39; | vline marker | . &#39;_&#39; | hline marker | . plt.plot(x,y,&#39;o&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b23934110&gt;] . &#44592;&#48376;&#54540;&#46991; . - 예시1 . plt.plot(x,y,&#39;.&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b237eaa10&gt;] . - 예시2 . plt.plot(x,y,&#39;x&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b235f4290&gt;] . &#49353;&#44628;&#48320;&#44221; . - 예시1 . plt.plot(x,y,&#39;or&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b2365c2d0&gt;] . - 예시2 . plt.plot(x,y,&#39;db&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b234bcb90&gt;] . - 예시3 . plt.plot(x,y,&#39;bx&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b233e4b10&gt;] . dot-connected plot . - 예시1: 마커와 라인스타일을 동시에 사용하면 dot-connected plot이 된다. . plt.plot(x,y,&#39;o-&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b232f3590&gt;] . - 예시2: 당연히 색도 적용가능함 . plt.plot(x,y,&#39;o--r&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b23200550&gt;] . - 예시3: 서로 순서를 바꿔도 상관없다. . plt.plot(x,y,&#39;ro--&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b23109590&gt;] . &#50668;&#47084; &#44536;&#47548; &#44536;&#47532;&#44592; . &#44217;&#52432;&#44536;&#47532;&#44592; . - 예시1 . x = np.arange(-5,5,0.1) ϵ = np.random.randn(100) y = 2*x + ϵ . plt.plot(x,y,&#39;.b&#39;) plt.plot(x,2*x,&#39;r&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b225d80d0&gt;] . &#46384;&#47196;&#44536;&#47532;&#44592; (subplot) // &#50808;&#50864;&#49464;&#50836; &#51060;&#44144; . - 예시1 . fig, axs = plt.subplots(2) axs[0].plot(x,y,&#39;.b&#39;) axs[1].plot(x,2*x,&#39;r&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b225274d0&gt;] . - 예시2 . fig, axs = plt.subplots(2,2) axs[0,0].plot(x,2*x,&#39;--b&#39;) axs[0,1].plot(x,ϵ,&#39;.r&#39;) axs[1,0].plot(x,y,&#39;.r&#39;) axs[1,1].plot(x,y,&#39;.r&#39;) axs[1,1].plot(x,2*x,&#39;-b&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b2193f390&gt;] . fig&#50752; axes&#51032; &#51060;&#54644; : matplotlib&#51004;&#47196; &#50612;&#47157;&#44172; &#44536;&#47548;&#51012; &#44536;&#47532;&#45716; &#48169;&#48277; . &#50696;&#51228;1 . - 목표: plt.plot()을 이용하지 않고 아래의 그림을 그려보자. . plt.plot([1,2,3,4],[1,2,4,3],&#39;or--&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b1f950a10&gt;] . - 구조: axis $ subset$ axes $ subset$ figure . ref: https://matplotlib.org/stable/gallery/showcase/anatomy.html#sphx-glr-gallery-showcase-anatomy-py . . - 전략: Fig을 만들고 (도화지를 준비) $ to$ axes를 만들고 (네모틀) $ to$ axes에 그림을 그린다. . - 그림객체를 생성한다. . fig = plt.figure() . &lt;Figure size 432x288 with 0 Axes&gt; . fig # 지금은 아무것도 없다. . &lt;Figure size 432x288 with 0 Axes&gt; . - 그림객체에는 여러 인스턴스 + 함수가 있는데 그중에서 axes도 있다. (그런데 그와중에 plot method는 없다) . fig.axes # 비어있는 리스트 . [] . - axes 추가 . fig.add_axes([0,0,1,1]) # (0,0)의 위치에 (1,1)인 액시즈(=네모틀)을 만들어라. . &lt;Axes:&gt; . fig.axes . [&lt;Axes:&gt;] . fig # 도화지안에 네모틀이 들어가 있다. . - 첫번째 액시즈를 ax1로 받음 (원래 axes1이어야하는데 그냥 편의상) . ax1 = fig.axes[0] . id(fig.axes[0]),id(ax1) . (139891930961872, 139891930961872) . - 잠깐만! (fig 오브젝트와 ax1 오브젝트는 포함관계에 있다) . id(fig.axes[0]),id(ax1) . (139891930961872, 139891930961872) . - 또 잠깐만! (fig 오브젝트에는 plot이 없지만 ax1 오브젝트에는 plot이 있다) . set(dir(fig)) &amp; {&#39;plot&#39;} . set() . set(dir(ax1)) &amp; {&#39;plot&#39;} . {&#39;plot&#39;} . - ax1.plot()을 사용하여 그림을 그려보자. . ax1.plot([1,2,3,4],[1,2,4,3],&#39;--or&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b1f8f8e10&gt;] . fig . &#50696;&#51228;2: &#50696;&#51228;1&#51032; &#51025;&#50857; . - 예제1상황 . fig . - 여기서 축을 하나 더 추가할거에요 . fig.axes . [&lt;Axes:&gt;] . fig.add_axes([1,1,1,1]) . &lt;Axes:&gt; . fig.axes . [&lt;Axes:&gt;, &lt;Axes:&gt;] . fig . ax1,ax2 = fig.axes . - ax2에 파란선으로 그림을 그리자. . ax2.plot([1,2,3,4],[1,2,4,3],&#39;--ob&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b2028e390&gt;] . fig . &#50696;&#51228;3: &#45908; &#51025;&#50857;! (&#48120;&#45768;&#47605;) . - 지금 상황 . fig . - 액시즈를 하나 더 추가 . fig.add_axes([0.65,0.1,0.3,0.3]) . &lt;Axes:&gt; . fig . fig.axes[-1].plot([1,2,3,4],[1,2,4,3],&#39;xr&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b1ff16690&gt;] . fig . &#50696;&#51228;4: &#51116;&#54644;&#49437;1 . (ver1) . plt.plot([1,2,3,4],[1,2,4,3]) . [&lt;matplotlib.lines.Line2D at 0x7f3b200c55d0&gt;] . (ver2) . ver1은 사실 아래가 연속적으로 실행된 축약구문임 . fig = plt.figure() fig.add_axes([?,?,?,?]) ax1 = fig.axes[0] ax1.plot([1,2,3,4],[1,2,4,3]) fig . &#50696;&#51228;5: &#51116;&#54644;&#49437;2 . - 아래의 코드도 재해석하자. . fig, axs = plt.subplots(2,2) . fig, axs = plt.subplots(2,2) axs[0,0].plot([1,2,3,4],[1,2,4,3],&#39;.&#39;) axs[0,1].plot([1,2,3,4],[1,2,4,3],&#39;--r&#39;) axs[1,0].plot([1,2,3,4],[1,2,4,3],&#39;o--&#39;) axs[1,1].plot([1,2,3,4],[1,2,4,3],&#39;o--&#39;,color=&#39;lime&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f3b206b2c90&gt;] . - fig, axs = plt.subplots(2,2)의 축약버전을 이해하면된다. . (ver1) . fig, axs = plt.subplots(2,2) . (ver2) . ver1은 사실 아래의 축약! . fig = plt.figure() fig.add_axes([?,?,?,?]) fig.add_axes([?,?,?,?]) fig.add_axes([?,?,?,?]) fig.add_axes([?,?,?,?]) ax1,ax2,ax3,ax4 = fig.axes axs = np.array(((ax1,ax2),(ax3,ax4))) . (ver3) . ver1은 아래와 같이 표현할 수도 있다. . fig = plt.figure() axs = fig.subplots(2,2) . HW . 제출: 이름(학번).ipynb, 이름(학번).html 형태로 정리하여 2개의 파일을 제출할 것 (작성방법 모르면 아래영상참고할것) . 즉 주피터노트북파일과 html파일을 모두 제출할 것 | . . 영상1: 코랩으로 실습하는 경우 | 영상2: local 아나콘다로 실습하는 경우 | . 1. &#50500;&#47000;&#50752; &#44057;&#51008; &#44536;&#47548;&#51012; &#44536;&#47140;&#46972;. . x,y = [1,2,3,4], [1,2,4,3] . . [&lt;matplotlib.lines.Line2D at 0x7f3b1ed2d1d0&gt;] . 2. &#50500;&#47000;&#50752; &#44057;&#51008; &#44536;&#47548;&#51012; &#44536;&#47140;&#46972;. . x,y = [1,2,3,4], [1,2,1,1] . . [&lt;matplotlib.lines.Line2D at 0x7f3b1e8ad0d0&gt;] . 3. &#50500;&#47000;&#50752; &#44057;&#51008; &#44536;&#47548;&#51012; &#44536;&#47140;&#46972;. . x = np.arange(-5,5,0.1) y1 = np.sin(x) y2 = np.sin(2*x) + 2 y3 = np.sin(4*x) + 4 y4 = np.sin(8*x) + 6 . . [&lt;matplotlib.lines.Line2D at 0x7f3b1cf24e10&gt;] .",
            "url": "https://guebin.github.io/DV2022/2022/09/19/(3%EC%A3%BC%EC%B0%A8)-9%EC%9B%9419%EC%9D%BC.html",
            "relUrl": "/2022/09/19/(3%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1)-9%E1%84%8B%E1%85%AF%E1%86%AF19%E1%84%8B%E1%85%B5%E1%86%AF.html",
            "date": " • Sep 19, 2022"
        }
        
    
  
    
        ,"post17": {
            "title": "(2주차) 9월14일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . &#52280;&#44256;&#51088;&#47308; . - 넘파이 문법이 약하다면? (reshape, concatenate, stack) . (1) reshape: 아래 링크의 넘파이공부 2단계 reshape 참고 . https://guebin.github.io/IP2022/2022/04/06/(6%EC%A3%BC%EC%B0%A8)-4%EC%9B%946%EC%9D%BC.html | . (2) concatenate, stack: 아래 링크의 넘파이공부 4단계 참고 . https://guebin.github.io/IP2022/2022/04/11/(6%EC%A3%BC%EC%B0%A8)-4%EC%9B%9411%EC%9D%BC.html | . - 주피터에서 !로 시작하는 명령의 기원, 혹은 원리를 알고싶다면? 아래링크에서 3세대 프로그래머의 삶까지 살펴볼 것 . https://guebin.github.io/IP2022/2022/03/28/(4%EC%A3%BC%EC%B0%A8)-3%EC%9B%9428%EC%9D%BC.html | . - import, from ... import ... 등 모듈을 임포트하는 방식이 낯설다면? . https://guebin.github.io/IP2022/2022/04/03/(5%EC%A3%BC%EC%B0%A8)-4%EC%9B%942%EC%9D%BC.html | . &#50724;&#45720; &#48176;&#50872; &#45236;&#50857;? . - 히스토그램의 활용: 정규분포인지 판단 &lt;- 지난시간 내용 . - 히스토그램의 활용2: 이미지 보정! 히스토그램 이퀄라이제이션 &lt;-- 오늘소개할 내용 . imports . !pip install opencv-python . import cv2 import matplotlib.pyplot as plt import pandas as pd import numpy as np . &#51060;&#48120;&#51648;&#51088;&#47308; &#45796;&#50868;&#47196;&#46300; . !wget https://upload.wikimedia.org/wikipedia/commons/0/08/Unequalized_Hawkes_Bay_NZ.jpg img = cv2.imread(&#39;Unequalized_Hawkes_Bay_NZ.jpg&#39;) . --2022-09-14 17:57:58-- https://upload.wikimedia.org/wikipedia/commons/0/08/Unequalized_Hawkes_Bay_NZ.jpg Resolving upload.wikimedia.org (upload.wikimedia.org)... 103.102.166.240, 2001:df2:e500:ed1a::2:b Connecting to upload.wikimedia.org (upload.wikimedia.org)|103.102.166.240|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 110895 (108K) [image/jpeg] Saving to: ‘Unequalized_Hawkes_Bay_NZ.jpg.5’ Unequalized_Hawkes_ 100%[===================&gt;] 108.30K 505KB/s in 0.2s 2022-09-14 17:57:59 (505 KB/s) - ‘Unequalized_Hawkes_Bay_NZ.jpg.5’ saved [110895/110895] . img.shape . (683, 1024, 3) . plt.imshow(img) . &lt;matplotlib.image.AxesImage at 0x7f385c732850&gt; . &#51060;&#48120;&#51648;&#51088;&#47308;&#51032; &#51060;&#54644; . &#48708;&#48128;1: &#51060;&#48120;&#51648;&#45716; &#49324;&#49892; &#49707;&#51088;&#46308;&#51032; &#51665;&#54633;&#51060;&#50632;&#51020;. . - 예시1 . _img1 = np.array([0,30,90,120,150,180,210,240,255]).reshape(3,3) _img1 . array([[ 0, 30, 90], [120, 150, 180], [210, 240, 255]]) . plt.imshow(_img1,cmap=&#39;gray&#39;) plt.colorbar() . &lt;matplotlib.colorbar.Colorbar at 0x7f385a14c450&gt; . - 예시2 . _img2 = np.array([0,20,40,60,80,100,120,140,160]).reshape(3,3) _img2 . array([[ 0, 20, 40], [ 60, 80, 100], [120, 140, 160]]) . plt.imshow(_img2,cmap=&#39;gray&#39;,vmin=0,vmax=255) plt.colorbar() . &lt;matplotlib.colorbar.Colorbar at 0x7f385a04e590&gt; . - 예시3 . _img3 = np.concatenate([_img1,_img2],axis=1) _img3 . array([[ 0, 30, 90, 0, 20, 40], [120, 150, 180, 60, 80, 100], [210, 240, 255, 120, 140, 160]]) . plt.imshow(_img3,cmap=&#39;gray&#39;) . &lt;matplotlib.image.AxesImage at 0x7f3859fda8d0&gt; . &#48708;&#48128;2: &#52860;&#46972;&#51060;&#48120;&#51648;&#45716; red + green + blue &#51032; &#51312;&#54633;&#51004;&#47196; &#54364;&#54788;&#44032;&#45733; (&#45796;&#47480;&#48169;&#49885;&#46020; &#44032;&#45733;) . - 예시1 . r = np.array([0]*25*3).reshape(5,5,3) g = np.array([0]*25*3).reshape(5,5,3) b = np.array([0]*25*3).reshape(5,5,3) . r[:3,:3,0] = 255 g[:3,2:,1] = 255 b[2:,:,2] = 255 . plt.imshow(r) . &lt;matplotlib.image.AxesImage at 0x7f3859f00a50&gt; . plt.imshow(g) . &lt;matplotlib.image.AxesImage at 0x7f3859e8a4d0&gt; . plt.imshow(b) . &lt;matplotlib.image.AxesImage at 0x7f3859e47590&gt; . plt.imshow(r+g+b) . &lt;matplotlib.image.AxesImage at 0x7f3859dd67d0&gt; . - 예시2: R,G,B를 같은 비율로 섞으면 무채색이 된다. . r = np.array([0]*25*3).reshape(5,5,3) g = np.array([0]*25*3).reshape(5,5,3) b = np.array([0]*25*3).reshape(5,5,3) r[:3,:3,0] = 80 g[:3,2:,1] = 80 b[2:,:,2] = 80 . plt.imshow(r+g+b) . &lt;matplotlib.image.AxesImage at 0x7f3859d53610&gt; . - 예시3: 우리가 관심있는 자료 . img.shape . (683, 1024, 3) . img_red = img * 0 img_green = img * 0 img_blue = img * 0 . img_red[...,0] = img[...,0] img_green[...,1] = img[...,1] img_blue[...,2] = img[...,2] . plt.imshow(img_blue) . &lt;matplotlib.image.AxesImage at 0x7f3859ccb750&gt; . &#55176;&#49828;&#53664;&#44536;&#47016; &#51060;&#53252;&#46972;&#51060;&#51228;&#51060;&#49496; . - 이미지를 rgb로 각각 분리하고 각 색깔들의 히스토그램을 그려보자. . plt.hist(img[:,:,0].reshape(-1)) . (array([ 3691., 56282., 235628., 170392., 120545., 60511., 22052., 14354., 15246., 691.]), array([114. , 123.4, 132.8, 142.2, 151.6, 161. , 170.4, 179.8, 189.2, 198.6, 208. ]), &lt;BarContainer object of 10 artists&gt;) . 히스토그램 그림1 | . _fig = plt.hist(img[:,:,0].reshape(-1),bins=255, range=[0,255]) . 히스토그램 그림2 | 120-200 사이에 값이 몰려있음 | 그런데 컴퓨터가 표현가능한 색은 0~255.. | 만약에 120-200까지의 분포된 모양은 그대로 유지하면서 range를 0-255 까지 늘린다면? | . - 분포의 모양은 대략적으로 유지하면서 값을 퍼트리자! . img2_red = cv2.equalizeHist(img[...,0]) . plt.hist(img2_red.reshape(-1)) . (array([59973., 57426., 82721., 73706., 61999., 76539., 72114., 72030., 72601., 70283.]), array([ 0. , 25.5, 51. , 76.5, 102. , 127.5, 153. , 178.5, 204. , 229.5, 255. ]), &lt;BarContainer object of 10 artists&gt;) . _fig=plt.hist(img2_red.reshape(-1),bins=255,range=(0,255)) . - red말고 다른채널에도 이와 같은 변환을 정의한다면? . img2 = np.stack([img2_red,img2_red,img2_red],axis=-1) . plt.imshow(img2) . &lt;matplotlib.image.AxesImage at 0x7f3848570810&gt; . plt.imshow(img) . &lt;matplotlib.image.AxesImage at 0x7f38484eea90&gt; . plt.imshow(np.concatenate([img,img2],axis=1)) . &lt;matplotlib.image.AxesImage at 0x7f3848446ad0&gt; . &#55176;&#49828;&#53664;&#44536;&#47016; &#51060;&#53252;&#46972;&#51060;&#51228;&#51060;&#49496; (&#55121;&#48177;&#48260;&#51204;) . img_black = cv2.imread(&#39;Unequalized_Hawkes_Bay_NZ.jpg&#39;,0) . img_black2 = cv2.equalizeHist(img_black) . plt.imshow(np.concatenate([img_black,img_black2],axis=1),cmap=&#39;gray&#39;) . &lt;matplotlib.image.AxesImage at 0x7f384840bc90&gt; . &#49689;&#51228; . - HE(Histogram Equalization)을 이용하여 아래주소에 저장된 이미지의 명암비를 보존하라 . https://raw.githubusercontent.com/guebin/2021DV/master/_notebooks/hw_img.png .",
            "url": "https://guebin.github.io/DV2022/2022/09/14/(2%EC%A3%BC%EC%B0%A8)-9%EC%9B%9414%EC%9D%BC.html",
            "relUrl": "/2022/09/14/(2%EC%A3%BC%EC%B0%A8)-9%EC%9B%9414%EC%9D%BC.html",
            "date": " • Sep 14, 2022"
        }
        
    
  
    
        ,"post18": {
            "title": "(2주차) 9월14일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . &#52280;&#44256;&#51088;&#47308; . - 넘파이 문법이 약하다면? (reshape, concatenate, stack) . (1) reshape: 아래 링크의 넘파이공부 2단계 reshape 참고 . https://guebin.github.io/IP2022/2022/04/06/(6%EC%A3%BC%EC%B0%A8)-4%EC%9B%946%EC%9D%BC.html | . (2) concatenate, stack: 아래 링크의 넘파이공부 4단계 참고 . https://guebin.github.io/IP2022/2022/04/11/(6%EC%A3%BC%EC%B0%A8)-4%EC%9B%9411%EC%9D%BC.html | . - 주피터에서 !로 시작하는 명령의 기원, 혹은 원리를 알고싶다면? 아래링크에서 3세대 프로그래머의 삶까지 살펴볼 것 . https://guebin.github.io/IP2022/2022/03/28/(4%EC%A3%BC%EC%B0%A8)-3%EC%9B%9428%EC%9D%BC.html | . - import, from ... import ... 등 모듈을 임포트하는 방식이 낯설다면? . https://guebin.github.io/IP2022/2022/04/03/(5%EC%A3%BC%EC%B0%A8)-4%EC%9B%942%EC%9D%BC.html | . &#50724;&#45720; &#48176;&#50872; &#45236;&#50857;? . - 히스토그램의 활용: 정규분포인지 판단 &lt;- 지난시간 내용 . - 히스토그램의 활용2: 이미지 보정! 히스토그램 이퀄라이제이션 &lt;-- 오늘소개할 내용 . imports . !pip install opencv-python . import cv2 import matplotlib.pyplot as plt import pandas as pd import numpy as np . &#51060;&#48120;&#51648;&#51088;&#47308; &#45796;&#50868;&#47196;&#46300; . !wget https://upload.wikimedia.org/wikipedia/commons/0/08/Unequalized_Hawkes_Bay_NZ.jpg img = cv2.imread(&#39;Unequalized_Hawkes_Bay_NZ.jpg&#39;) . --2022-09-14 17:57:58-- https://upload.wikimedia.org/wikipedia/commons/0/08/Unequalized_Hawkes_Bay_NZ.jpg Resolving upload.wikimedia.org (upload.wikimedia.org)... 103.102.166.240, 2001:df2:e500:ed1a::2:b Connecting to upload.wikimedia.org (upload.wikimedia.org)|103.102.166.240|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 110895 (108K) [image/jpeg] Saving to: ‘Unequalized_Hawkes_Bay_NZ.jpg.5’ Unequalized_Hawkes_ 100%[===================&gt;] 108.30K 505KB/s in 0.2s 2022-09-14 17:57:59 (505 KB/s) - ‘Unequalized_Hawkes_Bay_NZ.jpg.5’ saved [110895/110895] . img.shape . (683, 1024, 3) . plt.imshow(img) . &lt;matplotlib.image.AxesImage at 0x7f385c732850&gt; . &#51060;&#48120;&#51648;&#51088;&#47308;&#51032; &#51060;&#54644; . &#48708;&#48128;1: &#51060;&#48120;&#51648;&#45716; &#49324;&#49892; &#49707;&#51088;&#46308;&#51032; &#51665;&#54633;&#51060;&#50632;&#51020;. . - 예시1 . _img1 = np.array([0,30,90,120,150,180,210,240,255]).reshape(3,3) _img1 . array([[ 0, 30, 90], [120, 150, 180], [210, 240, 255]]) . plt.imshow(_img1,cmap=&#39;gray&#39;) plt.colorbar() . &lt;matplotlib.colorbar.Colorbar at 0x7f385a14c450&gt; . - 예시2 . _img2 = np.array([0,20,40,60,80,100,120,140,160]).reshape(3,3) _img2 . array([[ 0, 20, 40], [ 60, 80, 100], [120, 140, 160]]) . plt.imshow(_img2,cmap=&#39;gray&#39;,vmin=0,vmax=255) plt.colorbar() . &lt;matplotlib.colorbar.Colorbar at 0x7f385a04e590&gt; . - 예시3 . _img3 = np.concatenate([_img1,_img2],axis=1) _img3 . array([[ 0, 30, 90, 0, 20, 40], [120, 150, 180, 60, 80, 100], [210, 240, 255, 120, 140, 160]]) . plt.imshow(_img3,cmap=&#39;gray&#39;) . &lt;matplotlib.image.AxesImage at 0x7f3859fda8d0&gt; . &#48708;&#48128;2: &#52860;&#46972;&#51060;&#48120;&#51648;&#45716; red + green + blue &#51032; &#51312;&#54633;&#51004;&#47196; &#54364;&#54788;&#44032;&#45733; (&#45796;&#47480;&#48169;&#49885;&#46020; &#44032;&#45733;) . - 예시1 . r = np.array([0]*25*3).reshape(5,5,3) g = np.array([0]*25*3).reshape(5,5,3) b = np.array([0]*25*3).reshape(5,5,3) . r[:3,:3,0] = 255 g[:3,2:,1] = 255 b[2:,:,2] = 255 . plt.imshow(r) . &lt;matplotlib.image.AxesImage at 0x7f3859f00a50&gt; . plt.imshow(g) . &lt;matplotlib.image.AxesImage at 0x7f3859e8a4d0&gt; . plt.imshow(b) . &lt;matplotlib.image.AxesImage at 0x7f3859e47590&gt; . plt.imshow(r+g+b) . &lt;matplotlib.image.AxesImage at 0x7f3859dd67d0&gt; . - 예시2: R,G,B를 같은 비율로 섞으면 무채색이 된다. . r = np.array([0]*25*3).reshape(5,5,3) g = np.array([0]*25*3).reshape(5,5,3) b = np.array([0]*25*3).reshape(5,5,3) r[:3,:3,0] = 80 g[:3,2:,1] = 80 b[2:,:,2] = 80 . plt.imshow(r+g+b) . &lt;matplotlib.image.AxesImage at 0x7f3859d53610&gt; . - 예시3: 우리가 관심있는 자료 . img.shape . (683, 1024, 3) . img_red = img * 0 img_green = img * 0 img_blue = img * 0 . img_red[...,0] = img[...,0] img_green[...,1] = img[...,1] img_blue[...,2] = img[...,2] . plt.imshow(img_blue) . &lt;matplotlib.image.AxesImage at 0x7f3859ccb750&gt; . &#55176;&#49828;&#53664;&#44536;&#47016; &#51060;&#53252;&#46972;&#51060;&#51228;&#51060;&#49496; . - 이미지를 rgb로 각각 분리하고 각 색깔들의 히스토그램을 그려보자. . plt.hist(img[:,:,0].reshape(-1)) . (array([ 3691., 56282., 235628., 170392., 120545., 60511., 22052., 14354., 15246., 691.]), array([114. , 123.4, 132.8, 142.2, 151.6, 161. , 170.4, 179.8, 189.2, 198.6, 208. ]), &lt;BarContainer object of 10 artists&gt;) . 히스토그램 그림1 | . _fig = plt.hist(img[:,:,0].reshape(-1),bins=255, range=[0,255]) . 히스토그램 그림2 | 120-200 사이에 값이 몰려있음 | 그런데 컴퓨터가 표현가능한 색은 0~255.. | 만약에 120-200까지의 분포된 모양은 그대로 유지하면서 range를 0-255 까지 늘린다면? | . - 분포의 모양은 대략적으로 유지하면서 값을 퍼트리자! . img2_red = cv2.equalizeHist(img[...,0]) . plt.hist(img2_red.reshape(-1)) . (array([59973., 57426., 82721., 73706., 61999., 76539., 72114., 72030., 72601., 70283.]), array([ 0. , 25.5, 51. , 76.5, 102. , 127.5, 153. , 178.5, 204. , 229.5, 255. ]), &lt;BarContainer object of 10 artists&gt;) . _fig=plt.hist(img2_red.reshape(-1),bins=255,range=(0,255)) . - red말고 다른채널에도 이와 같은 변환을 정의한다면? . img2 = np.stack([img2_red,img2_red,img2_red],axis=-1) . plt.imshow(img2) . &lt;matplotlib.image.AxesImage at 0x7f3848570810&gt; . plt.imshow(img) . &lt;matplotlib.image.AxesImage at 0x7f38484eea90&gt; . plt.imshow(np.concatenate([img,img2],axis=1)) . &lt;matplotlib.image.AxesImage at 0x7f3848446ad0&gt; . &#55176;&#49828;&#53664;&#44536;&#47016; &#51060;&#53252;&#46972;&#51060;&#51228;&#51060;&#49496; (&#55121;&#48177;&#48260;&#51204;) . img_black = cv2.imread(&#39;Unequalized_Hawkes_Bay_NZ.jpg&#39;,0) . img_black2 = cv2.equalizeHist(img_black) . plt.imshow(np.concatenate([img_black,img_black2],axis=1),cmap=&#39;gray&#39;) . &lt;matplotlib.image.AxesImage at 0x7f384840bc90&gt; . &#49689;&#51228; . - HE(Histogram Equalization)을 이용하여 아래주소에 저장된 이미지의 명암비를 보존하라 . https://raw.githubusercontent.com/guebin/2021DV/master/_notebooks/hw_img.png .",
            "url": "https://guebin.github.io/DV2022/2022/09/14/(2%EC%A3%BC%EC%B0%A8)-9%EC%9B%9414%EC%9D%BC.html",
            "relUrl": "/2022/09/14/(2%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1)-9%E1%84%8B%E1%85%AF%E1%86%AF14%E1%84%8B%E1%85%B5%E1%86%AF.html",
            "date": " • Sep 14, 2022"
        }
        
    
  
    
        ,"post19": {
            "title": "(1주차) 9월5일에 대한 보강",
            "content": "&#44053;&#51032;&#50689;&#49345; . . import . import matplotlib.pyplot as plt import numpy as np . boxplot . motivating example . (예제1) 전북고등학교: 평균은 좋은 측정값인가? . - 전북고등학교에서 통계학을 수업하는 A선생님과 B선생님의 있다. A선생님에게서 수업을 들을 학생들의 평균은 79.1이고 B선생님에게서 수업을 들은 학생들의 평균은 78.3이다. . y1=[75,75,76,76,77,77,79,79,79,98] # A선생님에게 통계학을 배운 학생의 점수들 y2=[76,76,77,77,78,78,80,80,80,81] # B선생님에게 통계학을 배운 학생의 점수들 . np.mean(y1),np.mean(y2) . (79.1, 78.3) . - 의사결정: A선생님에게 배운 학생들의 실력이 평균적으로 더 좋을 것이다. . - 평균은 A반(=A선생님에게 통계학을 배운 반)이 더 높다. 그런데 98점을 받은 학생이 A반에 포함되어서 A반이 전체평균이 높게 나온것이고 나머지 학생들은 전체적으로 B반 학생들이 더 시험을 잘 보았다고 해석할 수 있다. . - 교훈: 단순한 평균비교보다 학생들이 받은 점수의 분포를 비교해보는 것이 중요하다. 분포를 살펴보는 방법 중 유용한 방법이 박스플랏이다. . matplotlib&#51004;&#47196; boxplot &#44536;&#47532;&#44592; . - A반 학생들의 박스플랏 그리기 . plt.boxplot(y1) . {&#39;whiskers&#39;: [&lt;matplotlib.lines.Line2D at 0x7f5261164550&gt;, &lt;matplotlib.lines.Line2D at 0x7f5261164810&gt;], &#39;caps&#39;: [&lt;matplotlib.lines.Line2D at 0x7f5261164b50&gt;, &lt;matplotlib.lines.Line2D at 0x7f5261164e90&gt;], &#39;boxes&#39;: [&lt;matplotlib.lines.Line2D at 0x7f5261164310&gt;], &#39;medians&#39;: [&lt;matplotlib.lines.Line2D at 0x7f52609a4250&gt;], &#39;fliers&#39;: [&lt;matplotlib.lines.Line2D at 0x7f52609a4550&gt;], &#39;means&#39;: []} . - B반 학생들의 박스플랏 그리기 . plt.boxplot(y2) . {&#39;whiskers&#39;: [&lt;matplotlib.lines.Line2D at 0x7f52608abc10&gt;, &lt;matplotlib.lines.Line2D at 0x7f52608abf50&gt;], &#39;caps&#39;: [&lt;matplotlib.lines.Line2D at 0x7f52608b32d0&gt;, &lt;matplotlib.lines.Line2D at 0x7f52608b3610&gt;], &#39;boxes&#39;: [&lt;matplotlib.lines.Line2D at 0x7f52608ab910&gt;], &#39;medians&#39;: [&lt;matplotlib.lines.Line2D at 0x7f52608b3990&gt;], &#39;fliers&#39;: [&lt;matplotlib.lines.Line2D at 0x7f52608b3cd0&gt;], &#39;means&#39;: []} . - A반 학생들의 점수와 B반 학생들의 점수를 나란히 박스플랏으로 그리자. . plt.boxplot([y1,y2]) . {&#39;whiskers&#39;: [&lt;matplotlib.lines.Line2D at 0x7f526082bc10&gt;, &lt;matplotlib.lines.Line2D at 0x7f526082bf50&gt;, &lt;matplotlib.lines.Line2D at 0x7f52608413d0&gt;, &lt;matplotlib.lines.Line2D at 0x7f52608416d0&gt;], &#39;caps&#39;: [&lt;matplotlib.lines.Line2D at 0x7f52608322d0&gt;, &lt;matplotlib.lines.Line2D at 0x7f5260832610&gt;, &lt;matplotlib.lines.Line2D at 0x7f5260841a10&gt;, &lt;matplotlib.lines.Line2D at 0x7f5260841d50&gt;], &#39;boxes&#39;: [&lt;matplotlib.lines.Line2D at 0x7f526082b990&gt;, &lt;matplotlib.lines.Line2D at 0x7f5260841090&gt;], &#39;medians&#39;: [&lt;matplotlib.lines.Line2D at 0x7f5260832990&gt;, &lt;matplotlib.lines.Line2D at 0x7f526084d0d0&gt;], &#39;fliers&#39;: [&lt;matplotlib.lines.Line2D at 0x7f5260832cd0&gt;, &lt;matplotlib.lines.Line2D at 0x7f526084d410&gt;], &#39;means&#39;: []} . boxplot&#51060;&#46976;? . - ref: https://github.com/mGalarnyk/Python_Tutorials/blob/master/Statistics/boxplot/box_plot.ipynb . np.random.seed(916170) # connection path is here: https://stackoverflow.com/questions/6146290/plotting-a-line-over-several-graphs mu, sigma = 0, 1 # mean and standard deviation s = np.random.normal(mu, sigma, 1000) fig, axes = plt.subplots(nrows = 1, ncols = 1, figsize=(10, 5)) # rectangular box plot bplot = axes.boxplot(s, vert=False, patch_artist=True, showfliers=True, # This would show outliers (the remaining .7% of the data) positions = [0], boxprops = dict(linestyle=&#39;--&#39;, linewidth=2, color=&#39;Black&#39;, facecolor = &#39;red&#39;, alpha = .4), medianprops = dict(linestyle=&#39;-&#39;, linewidth=2, color=&#39;Yellow&#39;), whiskerprops = dict(linestyle=&#39;-&#39;, linewidth=2, color=&#39;Blue&#39;, alpha = .4), capprops = dict(linestyle=&#39;-&#39;, linewidth=2, color=&#39;Black&#39;), flierprops = dict(marker=&#39;o&#39;, markerfacecolor=&#39;green&#39;, markersize=10, linestyle=&#39;none&#39;, alpha = .4), widths = .3, zorder = 1) axes.set_xlim(-4, 4) plt.xticks(fontsize = 14) axes.set_yticks([]) axes.annotate(r&#39;&#39;, xy=(-.73, .205), xycoords=&#39;data&#39;, xytext=(.66, .205), textcoords=&#39;data&#39;, arrowprops=dict(arrowstyle=&quot;|-|&quot;, connectionstyle=&quot;arc3&quot;) ); axes.text(0, .25, &quot;Interquartile Range n(IQR)&quot;, horizontalalignment=&#39;center&#39;, fontsize=18) axes.text(0, -.21, r&quot;Median&quot;, horizontalalignment=&#39;center&#39;, fontsize=16); axes.text(2.65, -.15, &quot; &quot;Maximum &quot;&quot;, horizontalalignment=&#39;center&#39;, fontsize=18); axes.text(-2.65, -.15, &quot; &quot;Minimum &quot;&quot;, horizontalalignment=&#39;center&#39;, fontsize=18); axes.text(-.68, -.24, r&quot;Q1&quot;, horizontalalignment=&#39;center&#39;, fontsize=18); axes.text(-2.65, -.21, r&quot;(Q1 - 1.5*IQR)&quot;, horizontalalignment=&#39;center&#39;, fontsize=16); axes.text(.6745, -.24, r&quot;Q3&quot;, horizontalalignment=&#39;center&#39;, fontsize=18); axes.text(.6745, -.30, r&quot;(75th Percentile)&quot;, horizontalalignment=&#39;center&#39;, fontsize=12); axes.text(-.68, -.30, r&quot;(25th Percentile)&quot;, horizontalalignment=&#39;center&#39;, fontsize=12); axes.text(2.65, -.21, r&quot;(Q3 + 1.5*IQR)&quot;, horizontalalignment=&#39;center&#39;, fontsize=16); axes.annotate(&#39;Outliers&#39;, xy=(2.93,0.015), xytext=(2.52,0.20), fontsize = 18, arrowprops={&#39;arrowstyle&#39;: &#39;-&gt;&#39;, &#39;color&#39;: &#39;black&#39;, &#39;lw&#39;: 2}, va=&#39;center&#39;); axes.annotate(&#39;Outliers&#39;, xy=(-3.01,0.015), xytext=(-3.41,0.20), fontsize = 18, arrowprops={&#39;arrowstyle&#39;: &#39;-&gt;&#39;, &#39;color&#39;: &#39;black&#39;, &#39;lw&#39;: 2}, va=&#39;center&#39;); . . plotly&#47196; boxplot &#44536;&#47532;&#44592; . - 로컬에서 하기 위해서는 아래를 설치 (코랩은 필요없음) . !pip install plotly !pip install ipywidgets !pip install jupyter-dash !pip install dash !pip install pandas . import plotly.express as px import pandas as pd from IPython.display import HTML . df= pd.DataFrame({&#39;score&#39;:y1+y2,&#39;class&#39;:[&#39;A&#39;]*len(y1) + [&#39;B&#39;]*len(y2)}) df . score class . 0 75 | A | . 1 75 | A | . 2 76 | A | . 3 76 | A | . 4 77 | A | . 5 77 | A | . 6 79 | A | . 7 79 | A | . 8 79 | A | . 9 98 | A | . 10 76 | B | . 11 76 | B | . 12 77 | B | . 13 77 | B | . 14 78 | B | . 15 78 | B | . 16 80 | B | . 17 80 | B | . 18 80 | B | . 19 81 | B | . fig = px.box(df,x=&#39;class&#39;,y=&#39;score&#39;) HTML(fig.to_html(include_plotlyjs=&#39;cdn&#39;,include_mathjax=False)) . . . histogram . motivating example . - 전북고예제에서 우리의 소망: 그냥 A반 B반 중에 어떤 반이 공부를 더 잘하냐? . 보통 이러한 질문은 중심경향값 중 하나를 골라서 비교하면 되었다. | 여기에서 중심경향값이란 데이터 분포의 중심을 보여주는 값으로 자료 전체를 대표할 수 있는 값을 말함. 평균, 중앙값등이 대표적인 중심경향값이다. | . - 전북고예제에서는 &quot;A반 B반 중에서 어떤 반이 공부를 더 잘하냐?&quot; 라는 질문의 대답으로 단순평균비교로는 의미가 없었다. 오히려 결과론적으로 보면 중앙값이 더 타당해 보인다. . - 그런데 사실 생각해보면 중앙값을 기준으로 B반이 공부를 더 잘했다고 주장하는 것도 애매하다. 어쨌든 가장 공부잘한 학생은 A반에 있으니까! (에이 한명 뿐이잖아요? 라고 생각할 수 있는데 그 한명이 2명 3명으로 점점 늘어난다고 생각해보자, 합리적인 기준을 제시할 수 있는가?) . - 사실 &quot;A반 B반중에 누가 더 공부를 잘하냐?&quot; 라는 질문은 굉장히 대답하기 곤란한 질문이다. 왜냐하면 . 이슈1: 단순 평균비교로 이러한 질문에 답을 하기 어렵다. | 이슈2: 박스플랏으로 전체분포를 파악해도 어떠한 반이 더 공부를 잘한다는 기준을 잡는게 애매하다. | . 그런데 특수한 경우에는 &quot;A반 B반중에 누가 더 공부를 잘하냐?&quot; 라는 질문에 대한 대답을 깔끔하게 할 수 있다. . (예제2) 정규분포 전북고등학교: 평균은 좋은 측정값인가? . - A반과 B반의 통계학 성적이 아래와 같다고 하자. . np.random.seed(43052) y1 = np.random.randn(10000) y2 = np.random.randn(10000) + 0.5 . np.mean(y1),np.mean(y2) . (-0.011790879905079434, 0.4979147460611458) . np.mean(y2) - np.mean(y1) . 0.5097056259662253 . y2의 값이 y1의 값보다 전체적으로 0.5097056259662253 정도 높다고 볼 수 있다? . plt.boxplot([y1,y2]) . {&#39;whiskers&#39;: [&lt;matplotlib.lines.Line2D at 0x7f525cf74250&gt;, &lt;matplotlib.lines.Line2D at 0x7f525cf74d10&gt;, &lt;matplotlib.lines.Line2D at 0x7f525cf9ca90&gt;, &lt;matplotlib.lines.Line2D at 0x7f525cf9cf10&gt;], &#39;caps&#39;: [&lt;matplotlib.lines.Line2D at 0x7f525cee43d0&gt;, &lt;matplotlib.lines.Line2D at 0x7f525cee4e90&gt;, &lt;matplotlib.lines.Line2D at 0x7f525dc05c90&gt;, &lt;matplotlib.lines.Line2D at 0x7f525cf29090&gt;], &#39;boxes&#39;: [&lt;matplotlib.lines.Line2D at 0x7f525cf74950&gt;, &lt;matplotlib.lines.Line2D at 0x7f525cf9c310&gt;], &#39;medians&#39;: [&lt;matplotlib.lines.Line2D at 0x7f525cee4a10&gt;, &lt;matplotlib.lines.Line2D at 0x7f525cf27990&gt;], &#39;fliers&#39;: [&lt;matplotlib.lines.Line2D at 0x7f525cee47d0&gt;, &lt;matplotlib.lines.Line2D at 0x7f525cf27690&gt;], &#39;means&#39;: []} . 분포의 모양이 거의 비슷, 왼쪽그림을 컨트롤+C 하여 오른쪽에 붙인다음 0.5정도 y축으로 올린느낌이다! | . - 이러한 상황에서는 &quot;B반의 성적 $ approx$ A반의 성적 + 0.5&quot; 라고 주장해도 큰 무리가 없어보인다. 따라서 이 경우에는 &quot;A반 B반 중에 어떤반이 더 공부를 잘하냐?&quot; 라는 질문에 대하여 &quot;B반이 평균적으로 0.5점정도 더 공부를 잘합니다&quot; 라고 대답해도 괜찮다. . - 결론: 정규분포 분포가정을 한다면 이슈1,2에 대한 문제를 한번에 해결가능함 . - 정규분포가정은 어떻게 할 수 있나? (= 데이터를 보고 어떻게 정규분포라고 알 수 있는가?): 데이터의 히스토그램을 그려서 종 모양이 되는지 확인해본다. (아직 초보단걔라서 이것밖에 모를 수 있어요) . histogram &#51060;&#46976;? . - 히스토그램: X축이 변수의 구간, Y축은 그 구간에 포함된 빈도를 의미하는 그림 . matplotlib&#51004;&#47196; histogram &#44536;&#47532;&#44592; . - 히스토그램의 예시1 . y=[10,11,12,15,16,20,21,22,23,24,25] . plt.hist(y) . (array([2., 1., 0., 1., 1., 0., 1., 1., 2., 2.]), array([10. , 11.5, 13. , 14.5, 16. , 17.5, 19. , 20.5, 22. , 23.5, 25. ]), &lt;BarContainer object of 10 artists&gt;) . plt.hist(y,bins=10) . (array([2., 1., 0., 1., 1., 0., 1., 1., 2., 2.]), array([10. , 11.5, 13. , 14.5, 16. , 17.5, 19. , 20.5, 22. , 23.5, 25. ]), &lt;BarContainer object of 10 artists&gt;) . - 히스토그램 예시2 . plt.hist(y,bins=2) #plt.hist(y,bins=1) . (array([5., 6.]), array([10. , 17.5, 25. ]), &lt;BarContainer object of 2 artists&gt;) . - 히스토그램 예시3 . plt.hist(y,bins=3) . (array([3., 2., 6.]), array([10., 15., 20., 25.]), &lt;BarContainer object of 3 artists&gt;) . 가장 큰 값은 25, 가장 작은 값은 10이므로 range는 15이다. | range / bins = 15 / 3 = 5 이므로 각 구간의 간격은 5이다. | 구간은 [10,15), [15,20), [20,25] 로 나눈다. | 각 구간에 포함된 자료의 수는 3,2,6 이다. | . - 히스토그램 예시4 . plt.hist(y,bins=7) . (array([3., 0., 2., 0., 1., 2., 3.]), array([10. , 12.14285714, 14.28571429, 16.42857143, 18.57142857, 20.71428571, 22.85714286, 25. ]), &lt;BarContainer object of 7 artists&gt;) . 가장 큰 값은 25, 가장 작은 값은 10이므로 range는 15이다. | range / bins = 15 / 7 = 2.142857142857143 이므로 각 구간의 간격은 2.142857142857143이다. | 구간은 [10,12.14285714), [12.14285714,14.28571429,), [22.85714286,25] 로 나눈다. | 각 구간에 포함된 자료의 수는 3,0,2,0,1,2,3 이다. | . - 히스토그램 예시5 . # np.random.seed(43052) # y1 = np.random.randn(10000) # y2 = np.random.randn(10000) + 0.5 plt.hist([y1,y2],bins=50) . (array([[ 1., 1., 3., 0., 2., 4., 9., 14., 16., 33., 44., 54., 95., 136., 168., 243., 293., 327., 406., 514., 531., 606., 664., 661., 719., 641., 622., 587., 531., 486., 385., 312., 249., 188., 150., 91., 66., 47., 33., 20., 19., 13., 8., 4., 2., 1., 0., 1., 0., 0.], [ 0., 0., 0., 1., 0., 3., 2., 5., 5., 6., 10., 23., 26., 43., 78., 104., 123., 158., 244., 284., 374., 396., 468., 542., 595., 680., 701., 715., 636., 592., 590., 496., 437., 394., 323., 250., 194., 145., 123., 75., 49., 38., 29., 20., 11., 3., 3., 4., 1., 1.]]), array([-4.12186916, -3.95213741, -3.78240567, -3.61267392, -3.44294217, -3.27321042, -3.10347867, -2.93374692, -2.76401517, -2.59428342, -2.42455167, -2.25481992, -2.08508817, -1.91535642, -1.74562467, -1.57589292, -1.40616117, -1.23642942, -1.06669767, -0.89696592, -0.72723417, -0.55750243, -0.38777068, -0.21803893, -0.04830718, 0.12142457, 0.29115632, 0.46088807, 0.63061982, 0.80035157, 0.97008332, 1.13981507, 1.30954682, 1.47927857, 1.64901032, 1.81874207, 1.98847382, 2.15820557, 2.32793732, 2.49766906, 2.66740081, 2.83713256, 3.00686431, 3.17659606, 3.34632781, 3.51605956, 3.68579131, 3.85552306, 4.02525481, 4.19498656, 4.36471831]), &lt;a list of 2 BarContainer objects&gt;) . seaborn&#51004;&#47196; histogram &#44536;&#47532;&#44592; . import seaborn as sns . df=pd.DataFrame({&#39;score&#39;:np.concatenate([y1,y2]), &#39;class&#39;:[&#39;A&#39;]*len(y1)+[&#39;B&#39;]*len(y2)}) df . score class . 0 0.383420 | A | . 1 1.084175 | A | . 2 1.142778 | A | . 3 0.307894 | A | . 4 0.237787 | A | . ... ... | ... | . 19995 0.493276 | B | . 19996 0.619512 | B | . 19997 -0.500529 | B | . 19998 1.267551 | B | . 19999 1.004863 | B | . 20000 rows × 2 columns . sns.histplot(df,x=&#39;score&#39;,hue=&#39;class&#39;) . &lt;AxesSubplot:xlabel=&#39;score&#39;, ylabel=&#39;Count&#39;&gt; . plotnine&#51004;&#47196; histogram &#44536;&#47532;&#44592; . from plotnine import * . ggplot(df) + geom_histogram(aes(x=&#39;score&#39;,fill=&#39;class&#39;),position=&#39;identity&#39;,alpha=0.5) . /home/cgb2/anaconda3/envs/py37/lib/python3.7/site-packages/plotnine/stats/stat_bin.py:95: PlotnineWarning: &#39;stat_bin()&#39; using &#39;bins = 84&#39;. Pick better value with &#39;binwidth&#39;. . &lt;ggplot: (8749427142589)&gt; . ggplot(df) + geom_histogram(aes(x=&#39;score&#39;,fill=&#39;class&#39;),alpha=0.5) ## 비교를 위해서 관찰만 할것 . /home/cgb2/anaconda3/envs/py37/lib/python3.7/site-packages/plotnine/stats/stat_bin.py:95: PlotnineWarning: &#39;stat_bin()&#39; using &#39;bins = 84&#39;. Pick better value with &#39;binwidth&#39;. . &lt;ggplot: (8749427066673)&gt; . plotly&#47196; histogram &#44536;&#47532;&#44592; . import plotly.figure_factory as ff hist_data = [y1, y2] group_labels = [&#39;A&#39;, &#39;B&#39;] # Create distplot with curve_type set to &#39;normal&#39; fig = ff.create_distplot(hist_data, group_labels, bin_size=.2, show_rug=False) HTML(fig.to_html(include_plotlyjs=&#39;cdn&#39;,include_mathjax=False)) . . . &#49689;&#51228; . (1) 자기학번으로 np.random.seed(202043052)를 만들고 . (2) y1, y2 // 10만개의 정규분포를 생성해서 저장 . y1: 평균 0, 표준편차=1 | y2: 평균 1, 표준편차=1 | . (3) plotly 를 활용하여 히스토그램을 겹쳐서 그려보는것. .",
            "url": "https://guebin.github.io/DV2022/2022/09/10/(1%EC%A3%BC%EC%B0%A8)-9%EC%9B%945%EC%9D%BC.html",
            "relUrl": "/2022/09/10/(1%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1)-9%E1%84%8B%E1%85%AF%E1%86%AF5%E1%84%8B%E1%85%B5%E1%86%AF.html",
            "date": " • Sep 10, 2022"
        }
        
    
  
    
        ,"post20": {
            "title": "(A2) 데이터시각화 강의소개",
            "content": "&#44596;&#44553;&#44277;&#51648; . - 강의실 변경: (221 $ to$ 227 (?)) . - 노트북 지참필수 . 노트북이 없으면? 자연대 2호관 121호 빅데이터사업단, 조성균 선생님 (063-219-5627) 에게 (1) 신분증(or 학생증) (2) 시간표를 출력하여 방문할 시 한학기 동안 대여 가능 | . - 휴강: 9월5일, 7일, 12일 휴강 -&gt; 강의영상업로드로 보충 . &#51068;&#48152;&#44277;&#51648; . - 강의노트는 어디에? . 2022년 강의노트 | 2021년 강의노트 &lt;- 2021년 중간고사/기말고사 기출문제 + 풀이포함 | . - 학점은 어떻게? . F가 나갈 수 있음!! | . - 출석? . 고민중 | . - 질문하는 방법? (여기로 가서 적당한 방법으로) . 인사생략하고 용건만 간단히! | . &#51452;&#51032;&#49324;&#54637; (&#51060; &#49688;&#50629;&#51012; &#46307;&#51648; &#47568;&#50500;&#50556; &#54624; &#51060;&#50976;?) . - 시험문제의 난이도 . - 수업시간이 너무 길다 . - 재미없음 . - cost-effective 하지 않음.. (특히 파이썬입문을 듣지 않았다면!) .",
            "url": "https://guebin.github.io/DV2022/2022/09/05/(A2)-%EA%B0%95%EC%9D%98%EC%86%8C%EA%B0%9C.html",
            "relUrl": "/2022/09/05/(A2)-%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%E1%84%89%E1%85%A9%E1%84%80%E1%85%A2.html",
            "date": " • Sep 5, 2022"
        }
        
    
  
    
        ,"post21": {
            "title": "(A1) 깃허브와 fastpages를 이용하여 블로그 개설하기",
            "content": "About this doc . - 본 포스트는 2021년 1학기 Python 입문 강의내용중 일부를 업로드 하였음. . - Github, fastpages를 사용하여 블로그를 개설하고 관리하는 방법에 대한 설명임. . .",
            "url": "https://guebin.github.io/DV2022/2021/08/17/(A1)-%EA%B9%83%ED%97%88%EB%B8%8C%EC%99%80-fastpages%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EA%B0%9C%EC%84%A4%ED%95%98%EA%B8%B0.html",
            "relUrl": "/2021/08/17/(A1)-%E1%84%80%E1%85%B5%E1%86%BA%E1%84%92%E1%85%A5%E1%84%87%E1%85%B3%E1%84%8B%E1%85%AA-fastpages%E1%84%85%E1%85%B3%E1%86%AF-%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%92%E1%85%A1%E1%84%8B%E1%85%A7-%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3-%E1%84%80%E1%85%A2%E1%84%89%E1%85%A5%E1%86%AF%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5.html",
            "date": " • Aug 17, 2021"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "최규빈 . guebin@jbnu.ac.kr | 자연과학대학교 본관 205호 | 카카오톡 오픈채널1 | . 2022년 2학기 종료 후 폐쇄 예정 &#8617; . |",
          "url": "https://guebin.github.io/DV2022/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://guebin.github.io/DV2022/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}